\section{The Compiler Targeting the rush VM}\label{sec:vm_compiler}

Since the rush VM interprets instructions directly, there must be a compiler targeting its architecture.
For this purpose, a compiler translating rush source code into instructions, which can be executed by the VM, was implemented.
Since the VM's architecture was developed with the features of rush in mind, the compiler sometimes requires surprisingly little effort for translating certain AST-nodes.
For instance, the compiler translates infix-expressions, such as `\texttt{n + m}', into instructions using the \qVerb{infix_expr} method.
This method is displayed in Listing~\ref{lst:vm_compile_infix_expr}.

\Lirsting[ranges={522-524, _536-543}, caption={Compilation of infix-expressions targeting the VM.}, label={lst:vm_compile_infix_expr}, float=h]{deps/rush/crates/rush-interpreter-vm/src/compiler.rs}

This method differentiates between the \qVerb{||}, \qVerb{&&}, and other possible operators since the former require extra code to be emitted.
Here, the focus only lies on the compilation of the latter, meaning any other type of infix-expression.
In line~538, the left-hand side expression is compiled first.
In the next line, the right-hand side is compiled too.
Finally, in line~540, the appropriate instruction representing the infix-operator is inserted.
The instruction is generated by a separate function, \qVerb{Instruction::from}, which converts an infix-operator into a matching instruction.
It is to be mentioned that most of the other rush compilers required significantly more code in order to implement the translation of infix-expressions.
The reason for the simplicity of this implementation is the fact that the rush VM implements one instruction for each infix-operator.
Since this VM implements all features of the source language, some complex operations are not required and thereby simplify the compiler's implementation.

\Lirsting[ranges={445-447,457-461}, caption={Compilation of expressions targeting the VM.}, label={lst:vm_compile_expr}, float=h]{deps/rush/crates/rush-interpreter-vm/src/compiler.rs}

Listing~\ref{lst:vm_compile_expr} shows the `\texttt{expression}' method which takes an \qVerb{AnalyzedExpresssion}.
However, the method does not return anything which represents the runtime value of the expression.
This is possible because the result of the expression is pushed onto the stack directly.
In line~447, the code for translating an integer literal can be seen.
Here, a \qVerb{push} instruction using the integer as its operand is inserted.
By pushing the values of expressions onto the stack, most methods do not need to return values.
Due to this, short and elegant code, like the one in Listing~\ref{lst:vm_compile_infix_expr}, can be implemented.
In other compilers, the method responsible for compiling expressions would usually return the register which will contain the value of the compiled expression at runtime.
Due to the values being saved on the VM's stack, other parts of the compiled program can still use the runtime values of compiled expressions.
Similar to the `\texttt{expression}' method of the analyzer, this method also dispatches the traversal of more complex expressions to specialized methods in order to keep its implementation simple.
For instance, the method for compiling infix-expressions is invoked in line~457.

Another reason for the compiler's simplicity regarding infix-expressions is that the rush VM includes a special instruction for the mathematical power operation.
In rush, the expression `\texttt{n ** m}' can be used to denote the mathematical expression $n^m$.
Since many real architectures lack an instruction for power operations, most other rush compilers demanded implementation of special edge-cases in order to make compiling power-expressions feasible.
The fact that the VM provides one instruction per operator shows how a carefully chosen target architecture simplifies the implementation of its compiler by a great deal.

However, there is also one aspect of the VM which made implementation of the compiler targeting the VM more demanding than usual.
For instance, in most assembly dialects, \emph{labels} can be used to allow jumps between blocks of code.
However, the VM intentionally does not support the use of such labels.
Since the VM would have to look up the exact instruction index of a label at runtime, each jump targeting a label would involve some additional overhead.
Like seen in the previous examples, VM jump instruction require the exact index of the destination instruction as their operand.
Therefore, the exact target index to which the instruction should jump must be determined at compile time.
To illustrate this issue, Listing~\ref{lst:vm_loops_rush} shows a rush program containing a loop, and Listing~\ref{lst:vm_loops_vm} displays the corresponding compiler output.
In the loop's body, the variable `\texttt{n}' is incremented by `1'.
Next, the `\texttt{break}' statement is used to terminate loop execution.
Therefore, the total amount of iterations is `1'.

\noindent
\begin{minipage}{.44\textwidth}
    \centering
    \Lirsting[float=H, caption={A rush program containing a loop.}, label={lst:vm_loops_rush}]{listings/vm_basic_loop.rush}
\end{minipage}%
\hfill
\begin{minipage}{.44\textwidth}
    \centering
    \Lirsting[float=H, caption={Compiler output for the rush program in Listing~\ref{lst:vm_loops_rush}}, label={lst:vm_loops_vm}]{listings/vm_basic_loop_instructions.s}
    \vspace{.1cm}
\end{minipage}

In lines~2 and 3 of Listing~\ref{lst:vm_loops_vm} the variable \qVerb{n} is initialized.
The instructions in lines~4--9 are used to increment `\texttt{n}' by `1'.
A new instruction which was not covered so far is the `\texttt{clone}' instruction.
This instruction duplicates the top item on the stack it without prior calls to `\texttt{pop}'.
Therefore, after the instruction has been executed, two identical values exist on the top of the stack.
This instruction is only used in assign-expressions in order to duplicate the address value of the assignee.

After `\texttt{n}' was incremented, the instruction in line~10 jumps to the instruction index `11'.
However, the last valid index is `10', it is represented by the `\texttt{jmp 3}' instruction in line~11.
If this jump is executed, the VM has no next instruction to fetch and therefore stops its fetch-decode-execute cycle.
Since it jumps to a position outside the loop, it represents the \qVerb{break} statement in line~5 of the source program.
The `\texttt{jmp}' instruction in line~11 is responsible for the repetition introduced by the loop.
It jumps to the first instruction of the loop's body in line~4.
Therefore, the instructions inside the loop's body are executed repeatedly.
The difficulty presented by this design is that the index of the jump's target instruction must be determined before the target instruction is inserted.
Listing~\ref{lst:rush_vm_compiler_loop} displays the method responsible for compiling loops.

\Lirsting[ranges={320-323,331-331,337-344}, caption={Implementation of loops in the rush VM compiler.}, label={lst:rush_vm_compiler_loop}, float=h]{deps/rush/crates/rush-interpreter-vm/src/compiler.rs}

In line~331, the loop's body is compiled and instructions generated during this process are inserted into the output sequence.
The next statement in line~337 inserts an instruction responsible for jumping back to the start of the loop's body.
The variable `\texttt{loop\_head\_pos}' was previously defined and specifies the index of the first instruction of the loop's body.

In line~340, the top loop is popped off the `\texttt{loops}' stack.
In line~322, this loop was previously pushed onto the \qVerb{loops} stack.
This stack is an internal field used by the compiler in order to save information about loops.
The top item on it always represents the loop currently traversed by the compiler.
Each loop item saves two lists, each containing the indices of jump instructions whose target index needs to be adjusted.
The first list contains the indices of jump instructions generated by `\texttt{break}' statements which were encountered during traversal of the loop's body.
The second list saves the indices of jump instructions emitted by `\texttt{continue}' statements.
For instance, if the compiler encounters a `\texttt{break}' statement, the code in Listing~\ref{lst:rush_vm_compiler_break} is executed.

\Lirsting[ranges={253-253,268-273,287-288}, caption={Compilation of \qVerb{break} statements in the rush VM compiler.}, label={lst:rush_vm_compiler_break}, float=h]{deps/rush/crates/rush-interpreter-vm/src/compiler.rs}

Here, the `\texttt{pos}' variable saves the index of the jump instruction to be inserted.
In line~271, this index is then inserted into the list containing the placeholder indices of the current loop.
Lastly, a `\texttt{jmp}' instruction is inserted containing a placeholder target index.
In line~342 of Listing~\ref{lst:rush_vm_compiler_loop}, the \qVerb{fill_blank_jmps} method is used to set the target indices of the specified jump instructions to `\texttt{pos}'.
The explanation of this method is omitted because it only iterates over the passed list of indices, replacing the target of each jump instruction during the process.
