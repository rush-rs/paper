\begin{abstract}
	\section*{Abstract}

    \timestamp

	Programming languages are undoubtedly of great importance for various aspects of
	modern-day life. Even if they remain unnoticed, digital systems running programs
	written in some sort of programming language are ubiquitous.
	However, there are numerous ways of implementing a programming language.
	A language designer could choose an interpreted or a compiled approach for their
	language's implementation. Both ways of program execution come with their own
	advantages and disadvantages.

	This paper aims to inform the reader about different means of program execution, focussing on compiler construction.
	However, we will only focus on the basics since implementing a programming language is often a demanding task.
	In order to include practical examples, we will explain concepts on the basis of our own programming language called \emph{rush}.
	During the implementation of rush, the focus for this paper has shifted slightly.
	As the title suggests, we originally planned on only implementing a compiler.
	However, there are numerous architectures which a compiler could target and settling on just one felt like the reader would miss out on too much.
	Therefore, we have implemented rush using one interpreter, one virtual machine, and five compilers.

	% To highlight the differences between the different methods of program execution, rush is implemented using different backends.
	% The features of rush are carefully chosen to match the scope of this paper.
	%
	% On the one hand, rush should include as many fundamental features as possible since these concepts can be applied to most other programming languages.
	% On the other hand, implementing too many features could result in the example being overwhelming.


	In chapter 1, we will give an introduction to implementing a programming language.
	Moreover, the rush programming language and its characteristics are presented.
	In chapter 2, the process of analyzing the program's syntax and semantics is explained.
	Chapter 3 focuses on how interpreters can be used in order to implement an interpreted programming language.
	Here, we will differentiate between a \emph{tree-walking interpreter} and a \emph{virtual machine}.
	The latter also serves as the target architecture for one of the five compilers.
	Chapter 4 illustrates how compilation to high-level\footnote{high-level targets: in this case machine independent} targets works.
	As examples for high-level targets, we will present the compiler targeting the virtual machine, a compiler targeting \emph{WebAssembly},
	and a compiler which uses the popular \emph{LLVM} framework.
	Chapter 5 focuses on how compilers targeting low-level\footnote{low-level targets: specific to one target architecture and operating system} architectures can be implemented.
	For this, we will present a compiler targeting \emph{RISC-V} assembly and another compiler targeting \emph{x86\_64} assembly.
    Lastly, Chapter 6 presents final thoughts and a conclusion on the topic of implementing a programming language.
\end{abstract}
