% chktex-file -2
\newpage
\section{x86\_64: Compiling to a CISC Architecture}

In addition to \emph{reduced instruction set computers (RISC)} there are also \emph{complex instruction set computers}, short \emph{CISC}.
The main differences lie in the instruction count and complexity.
For the purposes of this paper, the still widely used CISC architecture \emph{x86\_64}\footnote{later shortened to \emph{x64}} is used as an example, just like \riscv{} was used to represent RISC architectures in the previous section.
While \riscv{} with all extensions used by rush\footnote{The used extensions are RV32I, RV64I, RV32M, RV64M, RV32D, and RV64D.} has about 100 different instructions~\cite[Chapter~24]{Waterman2019}, x64 is estimated to have about 3600 instructions~\cite{Rodgers2017}.
This has the simple reason that at the time most CISC architectures were developed, many developers still programmed in assembly languages by hand, without the use of compilers.
Additional instructions for higher level concepts were therefore very helpful.

One example for such an instruction is the \qVerb{leave} instruction from x64.
It is used to release the current stack frame at the end of a procedure.
The \riscv{} compiler previously showed how this is done manually in Listing~\ref{lst:riscv_epilogue} on page~\pageref{lst:riscv_epilogue}.
First, the frame pointer register is copied into the stack pointer register, freeing the stack space allocated at the start of the procedure.
Then, the old frame pointer that was saved on the stack is popped off the stack back into the frame pointer register.
Restoring the return address and returning to the caller is both done by the \qVerb{ret} instruction in x64.

Another similar example is the \qVerb{call} instruction.
Although it is also usable in \riscv{} assembly, it is only provided by the assembler and resolves to multiple other \riscv{} instructions during assembly.
In x64 however, \qVerb{call} is a normal instruction just like every other one.

For x64 specifically, there are also some instructions that only operate on certain specific registers.
For instance, the \qVerb{idiv} instruction divides a signed 128-bit integer stored in the two 64-bit registers \qreg{rdx} and \qreg{rax} by the given operand, and stores the result in the \qreg{rax} register and the remainder in the \qreg{rdx} register. This makes any usage of such instructions significantly more involved, as values in these registers that should be preserved must temporarily be spilled to the stack.

\subsection{x64 Assembly}

\Lirsting[wrap=L, wrap width=0.4\textwidth, label={lst:x64_example}, caption={Example rush Program}]{listings/x64_simple.rush}

There are multiple different dialects of x64 assembly and multiple assemblers each supporting a different set of dialects.
The rush x64 compiler emits assembly code using Intel syntax that can be assembled by the \emph{GNU Assembler} (GAS).

Listing~\ref{lst:x64_example} contains another simple example program.
It defines a global variable called \qVerb{a} and assigns it the integer 2, increments it by one, defines a local boolean called \qVerb{b} to \qVerb{true}, and exits with the sum of \qVerb{a} plus \qVerb{b}.
The corresponding assembly code generated by the x64 rush compiler is shown in Listing~\ref{lst:x64_asm_example}.
It begins with the \qVerb{.intel_syntax} directive, indicating that the following assembly code uses the Intel syntax.
Then, similar to the \riscv{} assembly code shown in the previous section, the \qVerb{_start} symbol is marked as global, as this is again the entry point.
The sections are also the same, as these are defined by the ELF file format which is independent of ISAs.

\Lirsting[wrap=R, wrap width=0.6\textwidth, fancyvrb={numbers=right}, label={lst:x64_asm_example}, caption={Compiler Output for the rush Program in Listing~\ref{lst:x64_example}}]{listings/x64_simple.s}

The main differences between this and the shown \riscv{} assembly, and also the other x64 assembly dialects, are the instruction mnemonics and the register names.
When using the Intel syntax for x64, register names are always prepended by a percentage sign.
Another difference is the syntax used for pointers.
While \riscv{} uses \qVerb{-1(fp)} to take the value in the \qVerb{fp} register as a memory address, offset by $-1$, Intel x64 uses \qVerbCmd{byte ptr [\%rbp-1]} as seen in line~16.
It is obvious that the latter provides an additional constraint, the size of the value pointed to, here \qVerb{byte}.
\riscv{} assembly instead encodes this information in the instruction mnemonic.
To store a byte, one would use \qVerb{sb} (\textbf{s}tore \textbf{b}yte), whereas for storing a 64-bit integer, \qVerb{sd} (\textbf{s}tore \textbf{d}word) is used instead.

The naming of sizes other than `byte' was not explained yet, and this, too, differs between \riscv{} and x64.
Architectures usually define the size of one so-called \emph{word}.
In \riscv{} a word is defined as 32 bits, so 4 bytes, in x64 it is 16 bits, so 2 bytes.
All other sizes except for the byte are then named based on the word size.
Therefore, \riscv{} assigns 16-bit, 32-bit, and 64-bit the names \emph{half word}, \emph{word}, and \emph{double word} respectively.
For x64 they are instead called \emph{word}, \emph{double word}, and \emph{quadruple word}.
These names are usually shortened to only include the first letter of the factor, for instance a double word is called \emph{dword}.
In some instances, see line 28, alternative short forms are used.
Here the directive \qVerb{.quad} inserts a quadruple word.
\TODO{in x64 instructions the first source operand usually is also the destination}

\begin{table}[h]
	\centering
	\caption[x64 Integer Registers]{x64 Integer Registers~\cite[pp.~20,26]{Lu2022}}\label{tbl:x64_registers}
	\rowcolors{2}{gray!15}{}
	\begin{tabular}{c|ccc|c|l}
		\rowcolor{gray!25} 64-Bit & 32-Bit     & 16-Bit     & 8-Bit      & Caller-Saved & Purpose                                    \\
		\hline
		\reg{rax}                 & \reg{eax}  & \reg{ax}   & \reg{al}   & \checkmark{} & \nth{1} return register                    \\
		\reg{rbx}                 & \reg{ebx}  & \reg{bx}   & \reg{bl}   &              &                                            \\
		\reg{rcx}                 & \reg{ecx}  & \reg{cx}   & \reg{cl}   & \checkmark{} & \nth{4} argument register                  \\
		\reg{rdx}                 & \reg{edx}  & \reg{dx}   & \reg{dl}   & \checkmark{} & \gape{\makecell[l]{\nth{2} return register \\\nth{3} argument register}} \\
		\reg{rsi}                 & \reg{esi}  & \reg{si}   & \reg{sil}  & \checkmark{} & \nth{2} argument register                  \\
		\reg{rdi}                 & \reg{edi}  & \reg{di}   & \reg{dil}  & \checkmark{} & \nth{1} argument register                  \\
		\reg{rbp}                 & \reg{ebp}  & \reg{bp}   & \reg{bpl}  &              & base pointer / frame pointer               \\
		\reg{rsp}                 & \reg{esp}  & \reg{sp}   & \reg{spl}  & \checkmark{} & stack pointer                              \\
		\reg{r8}                  & \reg{r8d}  & \reg{r8w}  & \reg{r8b}  & \checkmark{} & \nth{5} argument register                  \\
		\reg{r9}                  & \reg{r9d}  & \reg{r9w}  & \reg{r9b}  & \checkmark{} & \nth{6} argument register                  \\
		\reg{r10}                 & \reg{r10d} & \reg{r10w} & \reg{r10b} & \checkmark{} &                                            \\
		\reg{r11}                 & \reg{r11d} & \reg{r11w} & \reg{r11b} & \checkmark{} &                                            \\
		\reg{r12}                 & \reg{r12d} & \reg{r12w} & \reg{r12b} &              &                                            \\
		\reg{r13}                 & \reg{r13d} & \reg{r13w} & \reg{r13b} &              &                                            \\
		\reg{r14}                 & \reg{r14d} & \reg{r14w} & \reg{r14b} &              &                                            \\
		\reg{r15}                 & \reg{r15d} & \reg{r15w} & \reg{r15b} &              &                                            \\
	\end{tabular}
\end{table}

\subsection{Registers}

The base x64 ISA provides 16 general purpose registers for 64-bit integers.
These are shown in Table~\ref{tbl:x64_registers}.
Additionally, three more sets of 16 registers are defined, each half the size as the previous one.
However, instead of these being additional storage, they simply alias to the lower half of the respective larger register.
For instance, when writing the byte $(2a)_{16}$ into \qreg{al}, the least significant byte of \qreg{ax}, \qreg{eax}, and \qreg{rax} changes to $(2a)_{16}$, too.
The upper bytes are untouched, however.
That means, if for example \qreg{ax} contains the value $(a455)_{16}$ before writing, it will contain $(a42a)_{16}$ afterwards, not $(002a)_{16}$.
\TODO{include parens?}

These registers for smaller sizes are not present for legacy reasons though.
Considering line~18 from Listing~\ref{lst:x64_asm_example}, the move of the value behind the \qVerb{byte ptr} requires the destination register to be of size \qVerb{byte}, too.
For this reason, the compiler uses the \qreg{sil} register here, instead of its 64-bit equivalent \qreg{rsi}.
Line 19 then performs the cast from the boolean, saved as a byte, to a 64-bit integer.
It does this by taking the 64-bit variant of the register, in this case \qreg{rsi}, and assuring all bits, except for the least significant eight, are zeros.
The latter is done using the \emph{bitwise AND} operation with the number $2^8-1=255$, which in binary is represented by eight ones.

Another special register is \qreg{rip}.
It stores the instruction pointer, that is, the address to the current instruction being executed.
The register is usually not modified directly, as branching can be achieved with instructions like \qVerb{call}, \qVerb{ret}, or \qVerb{jmp}.
Nevertheless, it is sometimes accessed manually, as seen in lines 15 and 17.
These read and write to the global \qVerb{a} variable, defined at the \qVerb{main..a} symbol.
Accesses like this simply require the offset by the instruction pointer in x64 Assembly.

In addition to these general purpose registers, x64 also defines 16 registers for floating point number calculations, each 128 bits in size and labelled \qreg{xmm0} through \qreg{xmm15}.
For the purposes of rush, only the lower 64 bits are ever used, since this is enough for double precision floating point numbers.
The additional 64 bits are provided for \emph{single instruction multiple data} (\emph{SIMD}) instructions.
They can be used by more optimized compilers to operate on multiple values at a time.
Any single one of these registers would then for instance hold two 64-bit values or four 32-bit values.

\begin{itemize}
	\item mention useless instructions?
	\item alignment?
	\item corelib?
	\item pointers? (should be the same as \riscv{})
\end{itemize}

\subsection{Stack Layout and Calling Convention}

\begin{wrapfigure}{O}{0.55\textwidth}
	\hspace{-1.75cm}
	\begin{tikzpicture}[xscale=0.9, yscale=0.7]
		\footnotesize

		% manually set counter to allow stack frame including the start dots
		\setcounter{cellnb}{0}
		\startframe
		\addtocounter{cellnb}{-1}

		% copied code from `\stacktop{}` to not reset counter to in turn allow `\startframe` above this
		\draw[freecell] (0,\value{cellnb})
		+(-2,.5) -- +(-2,-.5) -- +(2,-.5) -- +(2,.5);
		\draw (0,\value{cellnb}) node{...};

		\cell{n\textsuperscript{th} stack argument} \cellcom{\VerbCmd{\%rbp+}$16+8n$}
		\cell{...}
		\cell{\nth{1} stack argument} \cellcom{\VerbCmd{\%rbp+16}}
		\finishframe{previous}
		\startframe
		\cell{return address} \cellcom{\VerbCmd{\%rbp+8}}
		\cell{previous \qreg{rbp} value} \cellcom{\VerbCmd{\%rbp}}
		\bcell{unspecified} \cellcom{\VerbCmd{\%rbp-8}}
		\bcell{...}
		\bcell{variable size} \cellcom{\VerbCmd{\%rsp}}
		% \padding{3}{\makecell{unspecified\\variable size}} \cellcom{\VerbCmd{\%rbp-8}} \cellcom{\VerbCmd{\%rsp}}
		\stackbottom
		\finishframe{current}
	\end{tikzpicture}
	\caption[Stack Layout of x64]{Stack Layout of x64~\cite[p.~21]{Lu2022}}\label{fig:x64_stack}
\end{wrapfigure}

Alongside the instructions and registers defined by x64 itself, the \emph{System~V} ABI defines how programs should structure the stack during execution.
Figure~\ref{fig:x64_stack} shows this layout.
The overall outline is similar to that of \riscv{}, but some details differ.
For one, the order of the saved return address and the saved \qreg{rbp} register is inverted.
Secondly, the address \qreg{rbp} points to is different by 16 bytes.
Therefore, in x64 the first stack argument is accessed by offsetting \qreg{rbp} by 16, whereas in \riscv{} the \qVerb{fp} register already points to the first stack argument without any offset.
In both calling conventions every stack argument uses eight bytes of space.
In addition, x64 has no special return address register, but only stores the return address on the stack and retrieves it from there when needed.

The unspecified space between \qVerbCmd{\%rbp-8} and \qreg{rsp} can be freely used by the current function to save local variables.
Its internal layout may differ between programming languages.

\subsection{Implementation}

\Lirsting[ranges={14-14, 20-21, 46-47, 104-104}, wrap=L, caption={The \qVerb{Instruction} definition in the rush x64 compiler.}, label={lst:x64_instruction}]{deps/rush/crates/rush-compiler-x86-64/src/instruction.rs}

Even though many implementation details could be the same as for the \riscv{} compiler, there are some differences because we each created one separately and did not have any reference implementation.
One such difference is that the x64 compiler's \qVerb{Instruction} definition which is shown in Listing~\ref{lst:x64_instruction} not only includes actual instructions, but also directives and symbols.
This way, an entire assembly file can be represented as one \qVerb{Vec<Instruction>} with every \qverb{Instruction} representing one line of the assembly code.
A matching \qVerb{Display} implementation then simply emits the respective assembly representation.

Line 20 shows the definition of the \qVerb{.section} directive, simply holding an instance of another enumeration containing the valid sections.
Line 21 defines an assembly symbol, holding its name and a boolean whether a blank line should be added above.
\TODO{did I say what symbols / labels are?}
The name is saved as \textcolor{red}{a/an} \qVerb{Rc<str>} instead of a \qVerb{String} here to prevent some unnecessary cloning in some places.

The normal instructions, e.g., \qVerb{add} and \qVerb{sub}, also cannot simply take registers as operands, as x64 also allows memory pointers and immediate values in many places.
Instead, another enumeration, called \qVerb{IntValue}, is introduced to allow these three variants.
Listing~\ref{lst:x64_intvalue} shows its definition.

\subsubsection{Struct Fields}

\Lirsting[ranges={33-37}, wrap=R, wrap width={0.45\textwidth}, fancyvrb={numbers=right}, caption={The \qVerb{IntValue} definition in the rush x64 compiler.}, label={lst:x64_intvalue}]{deps/rush/crates/rush-compiler-x86-64/src/value.rs}

The compiler struct itself shown in Listing~\ref{lst:x64_compiler} is also a bit different.
Both compilers have a \qVerb{used_register} field, but this compiler does not need to store the size for each, because the registers themselves already have a defined size.
Both compilers have a \qVerb{scopes} field for storing variable locations, but this compiler uses an \qVerb{Option<_>} for variables of the unit and never types.
\TODO{why does \riscv{} not do this?}
Both compilers store the global variables, but this compiler has separate fields for every size for easier alignment in the static memory which is not required for \riscv{}.
\TODO{is this true?}
Both compilers have one field for accumulating the final assembly code, but this compiler saves a list of \qVerb{Instruction}s instead of \qVerb{Block}s.

\Lirsting[ranges={15-19, 25-31, 41-48, 55-60, 69-71}, float=h, caption={The x64 \qVerb{Compiler} struct definition.}, label={lst:x64_compiler}, path prefix={deps/rush}]{deps/rush/crates/rush-compiler-x86-64/src/compiler.rs}

\subsubsection{Memory Management}

\Lirsting[ranges={184-188}, float=h, caption={Alignment of values on the stack.}, label={lst:x64_align}, path prefix={deps/rush}]{deps/rush/crates/rush-compiler-x86-64/src/compiler.rs}

\subsubsection{Register Allocation}

\Lirsting[ranges={257-268}, float=h, caption={\TODO{think of good caption}}, label={lst:x64_intregister_next}]{deps/rush/crates/rush-compiler-x86-64/src/register.rs}

\subsubsection{Functions}

\subsubsection{Function Calls}

\Lirsting[ranges={37-44}, float=h, caption={Definition of the parameter registers and their order.}, label={lst:x64_int_param_regs}]{deps/rush/crates/rush-compiler-x86-64/src/register.rs}

\subsubsection{Control Flow}

\begin{itemize}
	\item if-else-expressions $\rightarrow$ conditional jumps
	\item loops
\end{itemize}

\begin{itemize}
	\item Calling convention
	\item \riscv{} Reader: \emph{ASCII adjust after addition} $\rightarrow$ \emph{aaa} $\rightarrow$ obsolete, collectively occupy 1.6\% of opcode space\cite[p.~4]{Patterson2017}
	\item
	      \enquote{Modular vs. Incremental ISAs Intel was betting its future on a high-end microprocessor, but that was still years away.
		      To counter Zilog, Intel developed a stop-gap processor and called it the 8086. It was intended to be short-lived and not have any successors,
		      but that’s not how things turned out. The high-end processor ended up being late to market, and when it did come out, it was too slow.
		      So the 8086 architecture lived on—it evolved into a 32-bit processor and eventually into a 64-bit one.
		      The names kept changing (80186, 80286, i386, i486, Pentium), but the underlying instruction set remained intact. —Stephen P. Morse, architect of the 8086}\cite{Morse2017}.
	      $\Rightarrow$ only meant as a temporary architecture
\end{itemize}
