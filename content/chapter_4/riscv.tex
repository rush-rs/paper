\newpage

\section{RISC-V: Compiling to a Modern RISC Architecture}

The \emph{RISC-V} \emph{ISA}\footnote{Short for: \enquote{instruction set architecture}} is a new and modern \emph{reduced instruction set} architecture focussing on simplicity and expandability.
The initial version was developed at \emph{UC Berkely} in the context of another related research project.
Since its introduction in 2011, the architecture has been rapidly growing in popularity.
Since the beginning, the project has been managed and led by the \emph{RISC-V foundation}, consisting of many individuals contributing to the project.
Today, corporate members of the RISC-V foundation include companies like \emph{Google}, \emph{Microsoft}, \emph{Samsung}, and \emph{IBM}.
Therefore, the general popularity and commercial attraction of the technology is apparent.
However, unlike most previous ISAs, the RISC-V architecture is a completely \emph{open-source} project and is therefore not controlled by a single large corporate entity.
This can be regarded as a large competitive advantage over other popular RISC architectures like \emph{ARM}.
In the past, many ISAs have failed due to them being too restrictive with their licensing, thus preventing widespread commercial adoption.
However, RISC-V is completely open and free to use, so that many companies like \emph{Google} can leverage the technology commercially while contributing to the project.
Unlike most of the previous ISAs, which were developed during the 1970s or 80s, RISC-V is one of the few which were developed this decade.
Therefore, it seems like RISC-V could be a significant architecture to be used in all sorts of devices in the near future~\cite[preface]{Patterson2017}.

\subsection{Register Layout}

\begin{wraptable}{r}{.4\textwidth}
	\centering
	\caption{Common Registers in RISC-V}{\cite[p.~155]{Waterman2019}}\label{tbl:riscv_regs}
	\begin{tabularx}{\linewidth}{l|L}
		\rowcolor{gray!10} Register   & Purpose                         \\ \hline
		\texttt{zero}                 & Hardwired zero                  \\ \hline
		\texttt{ra}                   & Return address                  \\ \hline
		\texttt{sp}                   & Stack pointer                   \\ \hline
		\texttt{t0} —  \texttt{t6}    & Temporary                       \\ \hline
		\texttt{fp}                   & Frame Pointer                   \\ \hline
		\texttt{a0}, \texttt{a1}      & Function argument, return value \\ \hline
		\texttt{a2} — \texttt{a7}     & Function argument               \\ \hline
		\texttt{s1} — \texttt{s11}    & Saved register                  \\ \hline
		\texttt{fa0}, \texttt{fa1}    & FP args, return value           \\ \hline
		\texttt{fa2} — \texttt{fa7}   & FP args                         \\ \hline
		\texttt{fs0} — \texttt{fs11}  & FP saved registers              \\ \hline
		\texttt{ft0} —  \texttt{ft11} & FP temporaries                  \\
	\end{tabularx}
\end{wraptable}

Most RISC architectures typically have a large count of registers~\cite[Chapter~2]{Dandamudi2005}.
When compared to other popular architectures, the truth of this statement becomes clear.
For instance, the \emph{x86\_32} architecture has 8 registers.
The popular RISC architecture \emph{ARM-32} provides twice that amount, meaning 16 registers.
However, a RISC-V CPU includes 32 registers, which is drastically more than the previously mentioned architectures.
Moreover, these 32 registers only include registers holding integer values.
Just for floating-point numbers, the ISA even provides another 32 registers.
Like previously explained, using more registers usually leads to increased efficiency of the output program.
Therefore, a register allocation algorithm targeting the RISC-V architecture could be more aggressive compared to one targeting x\_86 for instance~\cite[p.~10]{Patterson2017}.

The Table~\ref{tbl:riscv_regs} shows most of the registers which the RISC-V architecture provides.
For this table, the official ABI names of the registers have been used in order to make this section easier to read.
The first column of the table contains a register's name while the second column describes its purpose.

The first row of the table contains the \qVerb{zero} register.
On RISC-V, this register is special.
Like its name suggests, it holds the value of a constant 0.
Unlike other registers, it is read-only, meaning that it can never be overwritten, therefore preventing accidental writes.
In the next row, the \qVerb{ra} register is shown.
It saves the \emph{return address} of a function or subroutine.
If a return-instructions is used, the value in \qVerb{ra} is read as it is used to jump to a specific instruction.
The purpose of this register is elaborated further in Subsection~\ref{sec:riscv_calling_conv} about RISC-V's calling convention.
The \qVerb{sp} and \qVerb{fp} registers are used for managing stack memory.
Their purpose is explained in Subsection~\ref{sec:riscv_stack} about stack memory.
In the fourth row, the \qVerb{t0} — \qVerb{t6} are displayed.
These registers are often used to store temporary values used in larger computations.
In row six, the registers \qVerb{a0} and \qVerb{a1} can be seen.
These both serve as call arguments and return values of functions.
The remaining a-registers \qVerb{a2} — \qVerb{a7} can only be used as function call arguments.
How functions are called using registers will be explained in Subsection~\ref{sec:riscv_calling_conv}.
The next row contains the \emph{saved} registers \qVerb{s1} — \qVerb{s11}.
These registers are typically preserved across function calls, meaning a called function must not overwrite them.
What the previously explained registers have in common is that they all hold integer values.
Depending on the exact RISC-V architecture, all registers, including floating-point registers, either hold 32 or 64 bits of information.
For floating-point number values, RISC-V provides other registers.
These registers are able to hold floating-point numbers according to the \emph{IEEE 754--2008} standard~\cite[Chapter~11]{Waterman2019}.
Just like their integer counterparts, the floating-point registers \qVerb{fa0} and \qVerb{fa1} are used as function call arguments and as return values.
However, the other fa-registers \qVerb{fa2} — \qVerb{fa7} can only be used as function arguments holding floating-point numbers.
Just like the \qVerb{sx} registers, the \qVerb{fs0} — \qVerb{fs11} registers are usually preserved across function calls.
Last, the \qVerb{ft0} — \qVerb{ft11} registers can be used as temporary registers for floating-point numbers.
It is apparent that the floating-point registers are provisioned very similarly to the integer registers.
Therefore, a programmer or compiler targeting the architecture can utilize roughly the same principles,
regardless of the data-type stored in each register~\cite[pp.~18f,p.~34]{Patterson2017},~\cite[p.~155]{Waterman2019}.

Now, it has become apparent that RISC-V includes many registers which are grouped into semantic categories.
Every category is meant to be used in the specified manner, however, these groups are mostly only a suggestion of how each register should be used.
Although this subsection provides a good overview over the registers of the architecture, the purpose of some special registers is still not known.
These special registers, like \qVerb{sp}, \qVerb{fp}, and \qVerb{ra}, are thoroughly explained in the next sections.

\subsection{Memory Access Through the Stack}\label{sec:riscv_stack}

\begin{wrapfigure}{L}{0.39\textwidth}
	\hspace{-3.25cm}
	\begin{tikzpicture}[scale=.9]
		\small
		% TODO: also use longer arrow in top `fp_main`?
		\stackTopFixed{...} \cellcom{\scriptsize 24(sp\textsubscript{main})} \cellptr{\scriptsize \tt fp\,$_\text{main}$}
		\startframe
		\cell{fp} \cellcom{\scriptsize 16(sp\textsubscript{main})}
		\cell{ra} \cellcom{\scriptsize 8(sp\textsubscript{main})}
		\cell{a: int} \cellcom{\scriptsize -24(fp\textsubscript{main})} \cellptrA{\scriptsize \texttt{sp\,$_\text{main}$}}
		\cell{b: char} \cellcom{\scriptsize -25(fp\textsubscript{main})} \cellptrA{\scriptsize \texttt{fp\,$_\text{foo}$}}
		\finishframe{\tt main}
		\startframe
		\cell{fp} \cellcom{\scriptsize 8(sp\textsubscript{foo})}
		\cell{ra} \cellcom{\scriptsize 0(sp\textsubscript{foo})} \cellptrA{\scriptsize \texttt{sp\,$_\text{foo}$}}
		\finishframe{\tt foo}
		% TODO: uncomment the line below?
		%\stackbottom
	\end{tikzpicture}
	\caption{Example Stack Layout in RISC-V}\label{fig:riscv_basic_stack}
\end{wrapfigure}

As mentioned in the dedicated subsection about the stack, it presents a way to save data outside of registers.
This subsection explains special conventions followed when using stack memory on RISC-V.
Just like previously explained, most stacks are accessed through the specialized pointers.
On RISC-V, there is a \emph{stack pointer} which is saved in the \qVerb{sp} register.
Furthermore, the \qVerb{fp} register contains the \emph{frame pointer}.

Like most memory stacks, the RISC-V stack grows downwards, meaning it progresses into lower memory regions.
In the current implementation of the rush RISC-V compiler, the stack pointer points to the last legal memory cell of the current stack frame.
Therefore, \qVerb{sp} points on the cell with the lowest address of the current stack frame.
On the other hand, the frame pointer \qVerb{fp} points to the cell above the end of the current stack frame.
Therefore, the frame pointer always points to a memory cell which is illegal to use by the current function.
Thus, a stack frame is defined by its upper and lower bounds, represented by \qVerb{fp} and \qVerb{sp}, respectively.

In order to understand how the above behavior is used in practice, Figure~\ref{fig:riscv_basic_stack} is to be considered.
Furthermore, the rush program in Listing~\ref{lst:rush_riscv_stack} should be considered.

\Lirsting[caption={A rush Program Containing Two Variables}, label={lst:rush_riscv_stack}, float=H]{listings/riscv_stack.rush}

This snipped shows a rush program which contains two functions.
In the \qVerb{main} function of this program, two variables are defined.
The \qVerb{a} variable holds the integer value 42 while the \qVerb{b} variable contains the char value \qVerb{z}.
In line 4, the \qVerb{foo} function is called.
Figure~\ref{fig:riscv_basic_stack} shows the state of the stack at the point when this function was called.
The braces on the left side of the stack group the stack into frames.
On the right side of each stack cell, its relative address can be observed.
As explained previously, each stack cell is accessible either by offsetting \qVerb{sp}
or \qVerb{fp}. The stack pointers of each stack frame can are displayed by the arrows on the right side of the stack.

The stack shown in this figure contains two frames, one for each function involved in the call.
Since the \qVerb{main} function is called first, it is displayed at the top of the figure.
Normally, the last pushed element of a stack is located at the top, however, just as described,
this stack progresses towards lower memory, meaning that it grows downwards.
Since the \qVerb{main} function calls the \qVerb{foo} function, the stack frame for the \qVerb{foo} function is located at the bottom of the stack.

It is apparent that every stack frame saves the \qVerb{fp} and \qVerb{ra} registers at its top position.
These two special registers are saved at the two top positions of each call before any of the code in the function's body is executed.
Why these registers are saved on the stack is explained in Subsection~\ref{sec:riscv_stack} about the calling convention.
Since every stack frame contains these two elements,
the minimum size $s$ of a RISC-V stack frame in bytes must be $s = \frac{2 \times \text{Size}\,_\text{int}}{8}$.
Since $s$ is dependent on the integer-size of the RISC-V architecture, the minimum required memory differs per RISC-V architecture.
For instance, if the 64-bit version of RISC-V was used, the minimum size would be 16 bytes ($s = \frac{2 \times 64}{8} = 16$).
However, if the 32-bit version of the architecture was used, $s$ would be only 8 bytes ($s = \frac{2 \times 32}{8} = 8$).

Additionally, one can observe that the \qVerb{main} function's
stack frame contains cells which save the two variables which are defined in the body of the function.
Since the code in the function's body (where the variables are defined) is executed after \qVerb{fp} and \qVerb{ra} have been saved on the stack,
the cells containing these variables appear lower in the stack.
Another interesting observation is that the more recently declared variables are also saved in lower cells of the stack frame.
Therefore, the order in which variables are saved in the stack follows the \emph{LIFO} principle which is common in stacks.

In this example, in the stack frame of the function \qVerb{main}, the registers \qVerb{fp} and \qVerb{ra} require 16 bytes of memory together.
Therefore, the variable \qVerb{a} can be saved at the next 8 bytes of memory, meaning -24(fp).
This way, the variable is saved at the memory region from -24(fp) until the start of -16(fp) or 16(sp) in this example.
Therefore, each stack cell requires exactly as much memory as shown in the figure.
Just like described earlier, different rush types require different quantities of memory.
A character for instance only uses 1 byte of memory.
Thus, the entire variable \qVerb{b} is saved at -25(fp), meaning one byte below the end of the variable \qVerb{a}.
This way, each variable only uses as much memory as it actually requires.

However, the question of how the compiler is able to keep track of saved variables remains.
For this, the compiler maps a variable's name to a memory location.
To be precise, the compiler contains a \emph{HashMap} which associates a variable's name with its \qVerb{fp} offset.
In case of the program in Listing~\ref{lst:rush_riscv_stack}, the variable \qVerb{a} is associated with a \qVerb{fp} offset of -24.
If the variable is referenced at a later point, the compiler performs a simple lookup of the variable's memory address.

\subsection{Calling Convention}\label{sec:riscv_calling_conv}

\begin{wrapfigure}{R}{0.42\textwidth}
	\centering
	\begin{tikzpicture}[node distance=5mm]
		\node(stack)[
			vstack=6,
			rectangle split part fill={none, none, gray!20, gray!20, none, none},
			rectangle split part align=left,
		]{
			\nodepart{one}{{\texttt{\tiny 24(sp\textsubscript{0})}} fp$_0$}
			\nodepart{two}{{\texttt{\tiny 16(sp\textsubscript{0})}} ra$_0$}
			\nodepart{three}{{\texttt{\tiny 08(sp\textsubscript{0})}} argument 2}
			\nodepart{four}{{\texttt{\tiny 0(sp\textsubscript{0})}} argument 1}
			\nodepart{five}{{\texttt{\tiny 8(sp\textsubscript{1})}} fp$_1$}
			\nodepart{six}{{\texttt{\tiny 0(sp\textsubscript{1})}} ra$_1$}
		};
		\draw [thick, dashed] ([xshift=-.5cm, yshift=-.33cm]stack.four west) --  node[anchor=west, xshift=2cm, align=center] {\scriptsize function\\ \scriptsize boundary} ([xshift=.5cm, yshift=-.33cm]stack.four east);

		\node(sp)[left of=stack, xshift=-2.2cm, yshift=-0.32cm, align=left] {\scriptsize SP$_0$ \\ \scriptsize FP$_1$};
		\draw[arrow, shorten >= 2pt](sp) -- (stack.four west);

		\node(fp)[left of=stack, xshift=-2.2cm, yshift=2.26cm] {\scriptsize FP$_0$};
		\draw[arrow, shorten >= 2pt](fp) -- ([yshift=.74cm]stack.one west);

		\node(sp)[left of=stack, xshift=-2.2cm, yshift=-1.6cm] {\scriptsize SP$_1$};
		\draw[arrow, shorten >= 2pt](sp) -- (stack.six west);
	\end{tikzpicture}
	\caption{Spilled Registers During a RISC-V Function Call}\label{fig:riscv_call_spill}
\end{wrapfigure}

Just like previously explained, most architectures provide a calling convention which dictates how low-level function calls should be managed.
For most architectures, the calling convention is part of the ISA's official specification.
In the case of RISC-V, the calling convention is specified in a separate document~\cite{RiscvABI2022}.

The first step of calling a function involves placing the arguments in a place where the function can access them.
For RISC-V, this involves placing the arguments into specialized registers.
Like described in the Table~\ref{tbl:riscv_regs}, only special classes of registers can be used as call arguments.
For integer arguments, the first arguments are placed in the registers \qVerb{a0}--\qVerb{a7}
For instance, the first two arguments of the rush function call
\qVerb{foo(40, 2, 3.14)} would be placed in the registers \qVerb{a0} and \qVerb{a1}.
However, the third argument is a floating-point number and can therefore not be placed inside an integer register.
Therefore, the first floating-point argument register \qVerb{fa0} contains the argument \qVerb{3.14}.
In this case, all arguments can be held in regisers and spilling would not be required.

In case the function accepted nine or more integer arguments,
all further integer arguments upward of the ninth position would have to be spilled on the stack.
Here, the successive registers \qVerb{a0}--\qVerb{a7} would contain the first eight integer arguments of the called function.
The argument at position 9 however is then spilled on the stack since there are no registers left which could contain the additional argument~\cite[p.~8]{RiscvABI2022}.

The Figure~\ref{fig:riscv_call_spill} displays a possible state of the call stack during a function call which uses ten integer arguments.
If ten integer arguments are used, two arguments would have to be spilled on the stack.
In the figure, the spilled registers are placed in the stack cells \enquote{argument 1} and \enquote{argument 2}.
Here, the cell \enquote{argument 1} would hold the ninth argument while \enquote{argument 2} holds the tenth argument.
Therefore, all spilled argument registers will be placed in the stack frame of the caller function.
Normally, variables saved on the stack are aligned to reflect their sizes.
In case of spilled argument registers however, every argument will occupy exactly 8 bytes on the stack, even if the data type itself requires less space.

Now that the first step of a procedure call is explained, the question of how the second step works in RISC-V remains.
In the second step, the underlying procedure call is made using a specialized instruction.
In RISC-V assembly, one typically uses the call \emph{pseudoinstruction}\footnote{A macro generating multiple instructions from one pseudoinstruction. Therefore, the actual count of ISA instructions remains low while convenience features can be used in assembly~\cite[p.~68]{Dandamudi2005}.}.
Due to a lack of functions in assembly, the call-instruction uses the name of its target label as one operand.
Therefore, labels can be called as if they were functions.
This instruction will jump to the first instruction of the specified target label while saving the address of the next instruction after the \qVerb{call} instruction in the register \qVerb{ra}~\cite[p.~22]{Patterson2017}.
As hinted previously, the \qVerb{ra} register saves the \emph{return address}.
Therefore, the return address is set every time a function call is performed.

During the third step of the function call, the called function acquires local storage resources.
To be precise, the function decrements the stack pointer by the amount required by the stack frame.
Therefore, the function allocates as much stack space as required for storing local variables and other data.
Additionally, the frame pointer and return address are saved on the stack so that nested function calls do not cause issues.
For instance, if the return address was not saved on the stack, a nested function call would overwrite its stored value.
In this case, the parent function could no longer return since the return address now holds an incorrect value.
In order to mitigate issues like this, the return address and frame pointer are saved on the stack.
Figure~\ref{fig:riscv_call_spill} shows that the two registers are saved at the two positions on the top of the new stack frame.
This part of the function is often called the \emph{prologue} as it is executed before any of the function's internal code.

After the code of the function has been executed, the so-called \emph{epilogue} is executed.
Since the frame pointer and return address have been saved on the stack during the prologue,
the epilogue restores these registers by loading their values from the stack.
Furthermore, the amount which was subtracted from the stack pointer in the prologue is now added to the pointer in order to restore it to its original state before the function call.
Here, incrementing the stack pointer represents deallocating the previously acquired stack space.
However, the memory in the stack frame is not actually deleted since only the stack pointer is modified.
Even though the used memory is not explicitly deleted, it is still freed since it will probably be overwritten by the next function call.
If the prologue would not save the return address on the stack, a nested function call would overwrite the return address of the parent function, therefore creating a bug~\cite[p.~33]{Patterson2017}.
By saving the return address on the stack, nested function calls do not cause difficulties.
It is apparent that this design contains a lot of similarities to the call-stack of the rush VM\@.
However, in the VM, the process of saving and restoring the return address was managed automatically by the VM,
whereas, here, the programmer has to manually pay attention to saving and restoring this important piece of data.
Therefore, implementing function calls is definitely more demanding in RISC-V assembly than in the rush VM\@.

In case a function returns a value, it must be communicated to the caller so that it can access it.
For integer-based types, the first return value of a function is placed in the register \qVerb{a0}
while floating-point numbers are placed in the register \qVerb{fa0}.
This way, the caller code can obtain a function's return value by accessing the \qVerb{a0} and \qVerb{fa0}
registers respectively. If a function does not return a value, these steps are just omitted.
It is to be mentioned that character and boolean values are also placed inside the \qVerb{a0} register since these types can be represented by integers.

Lastly, the epilogue contains a return-instruction which should jump to the place where the function was called.
This \emph{ret} instruction reads the value stored in \qVerb{ra} in order to jump to this address.

\subsection{The Core Library}

Like hinted in the section about the linker on page~\pageref{sec:linker},
a program might use functionality provided by external libraries.
In case of the rush RISC-V compiler, external functions are used for character-arithmetic,
the mathematical power operator, and the system \emph{exit} call.
Since these concepts must introduce additional logic, the compiler should not be emitted their instructions every time they are used.
In that case, the repeated emission of redundant instructions would result in enlarged and unnecessary complex output code.
In order to mitigate these issues, the compiler simply inserts call-instructions referencing external functions.
External functions can be called just like any other function, however, their definition is not found in the same assembly file.
As described previously, resolving these external calls is later handled by the linker.
For this compiler, we later refer to this target specific library code by the term \emph{corelib}.

For instance, a function for mathematical power operations is implemented in the corelib.
Therefore, the compiler can emit a procedure call to this method every time rush's \qVerb{**} operator is used in the source program.
For this project, the entire corelib is written in RISC-V assembly.
However, it is often rational to implement a corelib or standardlib using a high-level language like C.
Since the corelib's functions are specified in separate files, they are packaged into an \emph{archive file} which is later used by the linker.
The assembly code in Listing~\ref{lst:riscv_exit_corelib} shows the implementation of the \qVerb{exit} subroutine in the RISC-V corelib.
The task of this subroutine is to invoke a specific functionality the Linux kernel by performing a \emph{system call}.

\Lirsting[float=H, path prefix={deps/rush}, ranges={8-12}, caption={The Assembly Implementation of the \qVerb{exit} Subroutine}, label={lst:riscv_exit_corelib}]{deps/rush/crates/rush-compiler-risc-v/corelib/src/exit.s}

A \emph{system call} (often abbreviated to \emph{syscall}) is an invocation of a function of operating system's kernel.
In Linux, more than 90 percent of the available system calls are implemented on all architectures.
A common system call is \qVerb{exit}.
This function terminates the current process and performs various cleanup steps.
Its first parameter is the exit status (or code) which can be checked by the shell or other programs~\cite[p.~148]{Love2013}.
In RISC-V Linux, the integer representation of a call to \qVerb{exit} is 93~\cite{Torvalds1991}.

In line 8 of Listing~\ref{lst:riscv_exit_corelib}, the \qVerb{exit} label is declared as global using the \qVerb{.global} directive.
Next, the \qVerb{exit} label is declared in line 10.
In line 11, the \qVerb{li} instruction is used in order to place 93 in the value \qVerb{a7}.
On RISC-V Linux systems, the content of the \qVerb{a7} register specifies the type of syscall to be performed.
Here, 93 is placed inside this register since it represents the \qVerb{exit} syscall.
In line 12, the \qVerb{ecall} instruction is used in order to call the program's environment~\cite[p.~23]{Patterson2017}
Here, this call invokes the Linux kernel.
In this example, some RISC-V assembly code was shown.
The next subsection explains these concepts and idioms in more detail.

\subsection{RISC-V Assembly}

The Listing~\ref{lst:riscv_simple} shows a rush program containing two functions and a global variable.
In line 1 of the rush program, the mutable global variable \qVerb{m} is defined with the initial value 42.
In line 4 of the main-function, \qVerb{m} is incremented by 1.
Next, in line 5, the \qVerb{foo} function is called using \qVerb{m} as the only call argument.
In line 6, a return-statement is used to terminate the main-function explicitly.
The body of the \qVerb{foo} function only contains a call to the \qVerb{exit} function.
Therefore, the \qVerb{foo} function only exits using the specified parameter \qVerb{n} as the exit code.
In this case, the exit code of the displayed program will be 43.
The code in Listing~\ref{lst:riscv_simple_asm} on page~\pageref{lst:riscv_simple_asm} shows the output assembly generated from this program by the rush RISC-V compiler\footnote{Generated in Git commit \rushCommit, automatically built with this document}.
Because the assembler code of the \qVerb{foo} function would take up too much space in the assembler program, it is intentionally omitted from this listing.
Since the excluded function does not introduce any new concepts anyway, omitting it will not lead to a loss of explained concepts.

\Lirsting[float=H, caption={Example rush Program Containing Two Functions}, label={lst:riscv_simple}]{listings/riscv_simple.rush}

\begin{wrapfigure}{L}{0.5\textwidth}
	\centering
	\Lirsting[ranges={1-31, -4 53-56}, fancyvrb={frame=none}]{listings/generated/riscv_simple.s}
	\caption{Compiler Output from the Rush Program in Listing~\ref{lst:riscv_simple}}\label{lst:riscv_simple_asm}
\end{wrapfigure}

In line 1, the \qVerb{.global} assembler directive is used to declare the global symbol \qVerb{_start}~\cite[p.~36]{Patterson2017}.
On most architectures, the \qVerb{_start} label indicates a program's entry point, therefore marking the first instruction to be executed~\cite[p.~19]{Zhirkov2017-wk}.
In line 5, the \qVerb{_start} label is defined by placing a colon after its name.
In line 6, the \qVerb{call} instruction is used to call the \qVerb{main..main} function.
What strikes the eye here is that the already familiar \qVerb{main} function is prepended by the \qVerb{main..} prefix.
Since this rush compiler implements name mangling\footnote{Compilers often \emph{mangle} names in order to create a unique name for every function~\cite[pp.~119-120]{Levine2000}},
every function declared in a rush program will contain this prefix.
However, unlike high-level function calls in LLVM, this call instruction is used alongside the previously explained low-level calling conventions of RISC-V.

In the next line, the \qVerb{li} instruction is used to load the constant integer 0 into the register \qVerb{a0}~\cite[reference card]{Patterson2017}.
Like explained in the previous section about the RISC-V calling convention,
the register \qVerb{a0} is used for the first integer call argument.
In line 8, the \qVerb{exit} function is called, however, one cannot see the definition of this function in the current file.
This is because the exit function is provided by the rush RISC-V corelib which was explained previously.
Since 0 was previously placed inside the register for the first integer call argument, the \qVerb{exit} function is called using 0 as the argument.
Therefore, the instructions in the lines 7--8 are responsible for terminating the program using the exit code 0.
These two instructions are always inserted at the end of the \qVerb{_start} label in order to terminate the program appropriately in case the rush code does not call \qVerb{exit} on its own.
This is required in order to prevent a segmentation fault which occurs if the program is not terminated properly.

Due to the function call in line 6, we will now shift our focus on the \qVerb{main..main} label in line 10.
In line 11, the first line of the \qVerb{main} function, a comment indicates the beginning of the function's prologue.
Just like demanded by the RISC-V calling convention, the rush compiler emits code for a \emph{prologue} and an \emph{epilogue} for each function.

As described in the previous sections about calling conventions, one task of the prologue is allocating stack space.
In this prologue, the \qVerb{addi} instruction in line 12 subtracts 16 from the value stored in \qVerb{sp}.
Since subtraction is used, the stack pointer is decremented, leading to the stack progressing into lower memory.
Therefore, this instruction increases the size of the stack, thus allocating memory.
Here, an addition instruction is used even though subtraction is required.
In RISC-V, the \qVerb{addi} instruction requires one register and one immediate value as its operands.
Due to the third operand being an \emph{immediate} value, the trailing \qVerb{i} (\emph{immediate}) appears in the instruction's name.
Since this immediate value can be negative, an additional instruction for immediate subtraction is redundant~\cite[reference card]{Patterson2017}.
This example shows how the RISC-V ISA omits redundant instructions in places where it is feasible.
In this case, the stack pointer is decremented by 16 since two 8-byte values are stored on the stack in the lines 13 and 14.
Just like described in the previous subsection about the stack, these registers are always saved on the stack.

The comment in line 17 indicates the start of the function's body.
First, the previously explained \qVerb{li} instruction in line 18 places a constant 1 in register \qVerb{a0}.
Next, the \qVerb{ld} instruction in line 19 is used in order to load the value of the global variable \qVerb{m} into the register \qVerb{a0}~\cite[reference card]{Patterson2017}.
Global variables, like \qVerb{m} in this example are saved under the \qVerb{.rodata}. section or under the \qVerb{.data} section if they are mutable.
In this example, \qVerb{m} is not declared as mutable and therefore saved under the \qVerb{.rodata} section.
The start of the \qVerb{.rodata} section is represented by the \qVerb{.section} assembler directive found in line 53.
Here, a label called \qVerb{m} is defined.
In this label, the \qVerb{.dword} directive is used to define the global initializer value of the variable.
In RISC-V, this directive stores 64 bit of information in successive memory doublewords~\cite[p.~39]{Patterson2017}.
The initializer value of the global variable is 42 and is represented as \qVerb{0x2a} using hexadecimal in the assembly code.
Since these data labels require their contents to be specified in hexadecimal, the trailing comment shows the base 10, human-readable version of the number.
Because global variable are not saved on the stack, special instructions like \qVerb{ld} are required to interact with global variables stored in the program's data sections.

At this point, the register \qVerb{a0} would contain 1 and \qVerb{a1} would contain 42.
In line 20, the \qVerb{add} instruction is used in order to save the sum of \qVerb{a0} and \qVerb{a1} in the register \qVerb{a2}.
Now, the value saved in \qVerb{a2} would be 43.
Next, the \qVerb{sd} instruction in line 21 saves the value of the register \qVerb{a2} at the memory location of the global variable \qVerb{m}, meaning that \qVerb{m} is updated to reflect its new value 43.
It now becomes apparent that these instructions are responsible for the add-assign expression in line 4 of the rush program.
Another interesting observation is that the last operand of the \qVerb{sd} instruction specifies the temporary register \qVerb{t6}.
The instruction uses this register for saving temporary data during the process of saving data in \qVerb{m}~\cite[reference card]{Patterson2017}.

In line 22, the previously explained \qVerb{ld} instruction is used in order to load the value of the same variable into the register \qVerb{a0}.
Then, the \qVerb{call} instruction in line 23 is used in order to call the \qVerb{foo} function using the value of m as its argument.
However, one cannot easily observe how call arguments are passed here.
Like explained previously, the first integer argument of a function call must be placed in the register \qVerb{a0}.
Since \qVerb{m} was loaded into \qVerb{a0} previously, it will be used as the call argument for \qVerb{foo} automatically.
Therefore, the \qVerb{foo} function is called using 43 as the first argument.

Since the \qVerb{foo} instruction only calls the \qVerb{exit} function, its explanation will not be beneficial for introducing new concepts.
Therefore, we will omit the explanation of the assembler output of the \qVerb{foo} function.
The final instruction of the main-function's body is the \qVerb{j} instruction in line 24.
This instruction will cause the CPU to jump to the address of the specified label.
In this example, the CPU will jump to the first instruction of the \qVerb{epilogue_0} label~\cite[p.~17]{Patterson2017}.
Therefore, the rush compiler uses the \qVerb{call} instruction for jumps caused by function calls and the \qVerb{j} instruction for jumps between blocks of the current function.

Like explained previously, every function has a \emph{prologue} and an \emph{epilogue}.
Since one of the tasks handled by the epilogue is releasing resources allocated by the prologue, the function's stack pointer is incremented in line 30.
Finally, the \qVerb{ret} instruction in line 31 is used in order to jump back to the instruction whose address is specified in the \qVerb{ra} register~\cite[reference card]{Patterson2017}.

\subsection{Supporting Pointers}

In Subsection~\ref{sec:pointers}, we have explained how pointers can be used in rush.
Since every rush backend should support all features of the language, pointers also need to be implemented for the RISC-V architecture.
In order to get a rough understanding of how pointers work in this compiler, the code in Listing~\ref{lst:rush_simple_pointer} and~\ref{lst:rush_simple_pointer_asm} are to be considered.

\begin{minipage}{.34\textwidth}
	\center
	\Lirsting[float=H, fancyvrb={frame=none}, caption={Example rush Program Containing a Pointer}, label={lst:rush_simple_pointer}]{listings/rush_simple_pointer.rush}
\end{minipage}%
\hspace{3cm}
\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[float=H, fancyvrb={frame=none}, ranges={10-10,18-24}, caption={RISC-V Assembly Output Generated from Listing~\ref{lst:rush_simple_pointer}}, label={lst:rush_simple_pointer_asm}]{listings/generated/riscv_rush_simple_pointer.s}
\end{minipage}


The code in Listing~\ref{lst:rush_simple_pointer} shows a rush program in which a variable is referenced to create a pointer which is then dereferenced.
In line 2, the mutable variable \qVerb{a} is defined using an initial value of 42.
Next, in line 3, the variable is referenced in order to use the resulting address to define the variable \qVerb{to_a}.
In line 4, the \qVerb{to_a} pointer variable is dereferenced in order to use the value of \qVerb{a} as the exit code of the program.


Listing~\ref{lst:rush_simple_pointer_asm} includes the most significant part of the compiler output which represents this rush program\footnote{Generated in Git commit \rushCommit, automatically built with this document}.
In line 18 of this listing, the integer value 42 is placed in the register \qVerb{a0}.
Next, \qVerb{a0} is saved on the stack at \qVerb{-24(fp)} using the \qVerb{sd} instruction.
Like the comment suggests, the instruction in line 20 is used in order to reference a.
Here, the \qVerb{addi} instruction is used to subtract 24 from the value stored in the \qVerb{fp} register.
The result of this subtraction is saved in the register \qVerb{a0}.
Therefore, the register now contains the absolute memory address of the \qVerb{a} variable.
Since the syntax \qVerb{-24(fp)} means that the variable is saved at $fp - 24$, the subtraction uses the exact same information which is already known about the variable.
Here, instead of using the saved memory location of the variable like \qVerb{x(fp)}, the information is used in order to calculate the absolute address of the target variable.
This computation can only be performed at runtime since the value of \qVerb{fp} is not known at compile time.
In line 21, the \qVerb{a0} register which contains the memory address is also saved on the stack.
Therefore, the \qVerb{a} variable is saved at \qVerb{-24(fp)} while \qVerb{to_a} is saved at \qVerb{-32(fp)}.

In order to access the value of \qVerb{a}, \qVerb{to_a} is dereferenced in line 4 of the rush program.
For this, the memory address stored in the variable \qVerb{to_a} first needs to be loaded from the stack.
Here, the \qVerb{ld} instruction in line 22 of the assembly output is used.
The instruction will load the memory address stored at \qVerb{-32(fp)} (in \qVerb{to_a}) into the \qVerb{a0} register.
Next, another \qVerb{ld} instruction in line 23 is used in order to load the value of the variable saved at the previously fetched memory address.
What strikes the eye is that \qVerb{0(a0)} instead of \qVerb{x(fp)} is used for specifying the target memory address of the load instruction.
In this case, \qVerb{0(a0)} means that the instruction should load its value from the address saved in \qVerb{a0} with an offset of 0.
Since an offset of 0 is used, the practical description of the instruction is that it loads a value saved at the memory address specified in \qVerb{a0}.
Because \qVerb{a0} contains the memory address of the \qVerb{a} variable, the instruction loads 42 into the \qVerb{a0} register.

\subsection{The rush Compiler Targeting RISC-V Assembly}

Just like the other compilers presented in this paper, this one also traverses the annotated AST using the postorder technique.
Unlike the LLVM or WASM compiler, this compiler emits RISC-V assembly files which are later assembled by the assembler.

\subsubsection{Struct Fields}

Before any complex code samples can be considered, important struct fields of the compiler first need to be explained.
The rust code in Listing~\ref{lst:riscv_compiler_attr} shows important struct fields of the rush compiler targeting RISC-V.

\Lirsting[ranges={11-11,15-15,19-34}, caption={Fields of the RISC-V \qVerb{Compiler} Struct}, label={lst:riscv_compiler_attr}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

In line 15, the field \qVerb{blocks} is declared.
This field holds a vector containing values of the type \qVerb{Block}.
That type provides an abstraction representing a label with its basic block in the assembly output.
Therefore, this struct needs to contain a string field for its label and a vector for its instructions.
The Listing~\ref{lst:riscv_instruction_enum} shows parts of the Rust code which declares the \qVerb{Instruction} enum.

\Lirsting[ranges={62-62,74-76,114-114}, caption={The \qVerb{Instruction} Enum in the RISC-V Compiler}, label={lst:riscv_instruction_enum}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/instruction.rs}

Although the listing shows only a few of the implemented instructions, this enum contains all instruction variants which the compiler might need at a later point.
Depending on the type of instruction, the corresponding enum includes fields which define its operands.
For instance, the \qVerb{Li} variant in line 74 represents the \qVerb{li} instruction in assembly.
This instruction loads the immediate integer value specified in the second operand into the register specified in the first operand.
Due to this, the enum also contains a field for a value of the type \qVerb{IntRegister} and a field for a 64-bit signed integer.
The Rust code in Listing~\ref{lst:riscv_intregister_enum} shows parts of the declaration of the \qVerb{IntRegister} enum.
Like the name implies, this enum holds all possible registers which the architecture provides.

\Lirsting[ranges={107-107,137-139,145-145}, caption={The \qVerb{IntRegister} Enum in the RISC-V Compiler}, label={lst:riscv_intregister_enum}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/register.rs}

Even though just the integer registers are shown in this listing, a similar enum for floating-point registers also exists in this implementation.
Another important struct field is declared in line 19 of Listing~\ref{lst:riscv_compiler_attr}.
The \qVerb{curr_block} field saves the index of the basic block which is currently being inserted to.
Next, the \qVerb{data_section} and \qVerb{rodata_section} fields in line 21 and 22 are declared.
Just like the ELF sections, these vectors contain declarations of global variables in the program.
Here, each vector holds items of the type \qVerb{DataObj}.
Since this type specifies data which should be saved in these sections, it contains a string field for the label and an enum field for the actual data saved in the object.
For instance, if the compiler encounters a global variable declaration, a new data object is inserted into the correct section, depending on whether the global variable has been declared as mutable or not.

In line 25, the \qVerb{curr_fn} field is declared.
This field saves a value of the type \qVerb{Function}.
The \qVerb{Function} struct contains a counter of the stack allocations of the current function in bytes and the label of the epilogue block of the current function.
The former is incremented every time a variable declaration is compiled.
This is required in order to allocate the correct amount of stack memory during a function's prologue.

Just like in the other compilers, this one also features a \qVerb{loops} field which saves important labels of the current loop being compiled.
This field is declared in line 27 and holds a vector of \qVerb{Loop} structs.
Each \qVerb{Loop} struct saves the label of the loop's head and the label of the basic block which follows after the loop's body.

Furthermore, the \qVerb{scopes} field in line 29 is managed to associate a variable to some important metadata.
This metadata includes the variables type and its \emph{stack memory position}.
Just like explained in the previous sections, each cell of the stack memory is accessible by specifying a unique index.
The compiler saves this unique index in this HashMap so that it can refer back to the variable later.
Of course, this only works for variables which are saved on the stack.
However, these HashMaps are not used for saving global variables.
Instead, the \qVerb{globals} field in line 31 is used.
Just like the HashMaps in the \qVerb{scopes} field, this map also associates a variable's name to a value of the type \qVerb{Variable}.
This time however, each variable contains the data label under which the global variable was declared.
Last, the \qVerb{used_registers} field in line 33 is declared.
It plays a vital role in the compiler's register allocation algorithm.

By only considering the compiler's struct fields, it has become apparent that this implementation provides several abstractions over the bare strings in which assembly is normally formatted.
Due to this, implementation of the actual compiler is a lot more structured and reliable.
During development of the compiler, this approach has often proven itself to be optimal.

\subsubsection{Data Flow and Register Allocation}

An important characteristic of a compiler is how it represents runtime data at compile time.
In assembly, runtime data is represented by registers which will contain values at runtime.
Since this rush compiler emits RISC-V assembly, it also represents data by using registers internally.
In the previous paragraphs, we have learned how this implementation uses abstractions in order to represent assembly constructs, including registers.

For reference, the LLVM compiler represents runtime values by passing virtual registers internally.
Similarly, this compiler also passes abstractions representing registers in order to represent the data flow of the program being compiled.
Unlike in LLVM, there is only a finite amount of registers available.
Therefore, this compiler also manages register allocation so that programs can be represented using this limited number of registers.
In under to understand the implementation, the code in Listing~\ref{lst:rush_riscv_simple_sum} and Listing~\ref{lst:rush_riscv_simple_sum} is to be considered.
The former listing contains a rush program which adds two integer variables together in order to use the result as its exit code.
The latter shows parts of the assembly output representing the logic in the \qVerb{main} function.

\begin{minipage}{.34\textwidth}
	\center
	\Lirsting[caption={Rush Program Calculating the Sum of Integers}, label={lst:rush_riscv_simple_sum}, float=H]{listings/simple_add.rush}
\end{minipage}%
\hspace{3cm}
\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[ranges={18-25},caption={Assembly Output of Rush Program in Listing~\ref{lst:rush_riscv_simple_sum}}, label={lst:asm_riscv_simple_sum}, float=H]{listings/generated/rush_simple_add.s}
\end{minipage}

In the lines 2 and 3 of the rush program, the integer variables \qVerb{a} and \qVerb{b} are declared.
In line 4, the \qVerb{exit} function is invoked, using the sum of these variables as the call argument.

In the line 22 of the assembly output, the runtime value of the \qVerb{a} variable is loaded into the register \qVerb{a0}.
Next, the same operation is performed for the \qVerb{b} variable.
However, this time, the instruction writes its result in the \qVerb{a1} register instead of the \qVerb{a0} register.
This is because the previously loaded value in \qVerb{a0} would be overwritten if this was the case.
Since both the value of the variable \qVerb{a} and \qVerb{b} are required for the addition, overwriting this register would result in a wrong calculation.
This is an example of how register allocation is required in order to manage registers and to prevent such bugs.

Unlike the register allocation algorithm of a production ready compiler like LLVM, this one only aims to use registers without causing conflicts like the previously explained one.
Therefore, this algorithm does not emphasize performance and instead only performs mandatory task which are required for making a program work.
For instance, all variables are saved on the stack in order to keep all registers unused and free for use in temporary calculations and operations like this one.
Since this algorithm only performs rudimentary register allocation, its implementation is also significantly easier.

The core principle of the register allocator is that each method which can return a register decides which register it returns itself.
In order to choose an output register, each of those methods uses the helper method \qVerb{alloc_ireg}.
The rust code in Listing~\ref{lst:riscv_alloc_ireg} shows the \qVerb{alloc_ireg} method of the RISC-V rush compiler.

\Lirsting[ranges={175-186}, path prefix={deps/rush}, float=h, label={lst:riscv_alloc_ireg}, caption={\qVerb{alloc_ireg} Method of the RISC-V rush Compiler}]{deps/rush/crates/rush-compiler-risc-v/src/utils.rs}

This method returns the first available register from the register pool containing either integer registers\footnote{The \enquote{i} in \qVerb{alloc_ireg} hints that it allocates integer registers}.
Such a register pool contains all possible registers which can hold the data type of that class of registers.
This compiler contains two pools: one for integer registers and one for floating-point registers.
In line 175 of Listing~\ref{lst:riscv_alloc_ireg}, the signature of the method is shown.
Here, one can see that the method returns a value of type \qVerb{IntRegister}.
The for-loop in line 176 is used to itrate through the entire \qVerb{INT_REGISTERS} array.
This array is constant and therefore represents the pool containing integer registers.
In the lines 177--180, the if-expression checks if the current register (\qVerb{reg}) is not found in the \qVerb{used_registers} vector.
If this was the case, the current register would be unused and could therefore be returned.
Since the return-statement in line 182 returns the current register if it is unused, the loop only runs until a free register has been found.
Due to the passive nature of the register allocation algorithm used in this compiler, the unreachable-macro in line 185 should never be called since the compiler should not run out of registers.
However, one can see that this method does not mark the newly returned register as used.
This is because marking a register as used is only required in some sections of the compiler where overwriting a register would introduce a bug in the output program.
Therefore, if this method was to be called repeatedly without calls to other methods, it would always yield the same result register.

In order to mark a register as used, it is simply pushed into the \qVerb{used_registers} vector.
For this, a helper method called \qVerb{use_reg} which only performs this simple call is implemented.
Due to the simplicity of this method, a listing of its code is intentionally omitted.
If a register is no longer used and can be overwritten again, it is also simply removed from the \qVerb{used_registers} vector.
For this, another simple helper method called \qVerb{release_reg} is implemented.

\begin{figure}
	\centering
	\begin{tikzpicture}
		\node(stack)[stack=6, rectangle split part align=center,
			rectangle split part fill={gray!20, gray!20, none, none, none, none},
			text width=10ex, text centered, inner xsep=0]{
			\shortstack{used\\\\\texttt{a0}}
			\nodepart{two}{\shortstack{used\\\\\texttt{a1}}}
			\nodepart{three}{\shortstack{unused\\\\\texttt{a2}}}
			\nodepart{four}{\ldots}
			\nodepart{five}{\shortstack{unused\\\\\texttt{a7}}}
			\nodepart{six}{\ldots}
		};
		\node(ff)[below of=stack, yshift=-.5cm] {\scriptsize first free};
		\draw[arrow, shorten >= 4pt](ff) -- (stack.three south);
	\end{tikzpicture}
	\caption{Integer Register Pool of the RISC-V rush Compiler}\label{fig:riscv_iregister_pool}
\end{figure}

Figure~\ref{fig:riscv_iregister_pool} shows an abstract representation of the compiler's integer register pool.
Here, the pool contains all integer registers of the compiler.
In this figure, only the first section of the pool which contains the \qVerb{ax} registers can be seen.
The gray cells at the beginning indicate that these registers are currently in use by the compiler.
Of course, this information is not saved in the register pool since the \qVerb{used_registers} vector saves this data.
In the figure, the arrow points to the first free register, meaning the one which follows the last used register \qVerb{a1}.
Therefore, if the \qVerb{alloc_ireg} method was called when the state of the registers is equivalent to the one displayed in Figure~\ref{fig:riscv_iregister_pool}, it would return the register \qVerb{a2}.
By considering this example, it has become apparent that the method always returns the first free integer register.
In the compiler, an equivalent pool for float registers also exists.

Before register allocation can be explained using code samples, how registers are passed around in the compiler needs to be explained first.
Here, we should focus on the compilation of simple expressions.
For this, the rust code in Listing~\ref{lst:riscv_expression} is to be considered.

\Lirsting[float=h, ranges={596-602,662-663}, path prefix={deps/rush}, caption={Parts of the \qVerb{expression} Method in the RISC-V rush compiler}, label={lst:riscv_expression}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

The code in Listing~\ref{lst:riscv_expression} shows parts of the \qVerb{expression} method.
This method is responsible for compiling expressions in the RISC-V rush compiler.
As the method's signature suggests, it takes a node representing an analyzed expression.
This method returns an \qVerb{Option<Register>} which is \qVerb{None} if the infix-expression contained a call to the \qVerb{exit} function.
Otherwise, the method returns the register in which the result of its computation will be contained at runtime.
The code in the lines 598-602 is executed if a constant integer expression is compiled.
First, a target integer register is allocated by calling the previously shown \qVerb{alloc_ireg} method.
Now, the \qVerb{dest_reg} variable contains the register which will contain the result of the expression.
Next, an \qVerb{li} instruction is inserted.
At runtime, this instruction would load the constant integer contained in the variable \qVerb{value} into the register specified \qVerb{dest_reg}.
Finally, the register which now contains the loaded value is returned.
For more complex expressions, the corresponding methods are called, just like in the other compilers.
Now it has become apparent how basic expressions work and how registers are used to hold values.

However, we still do not know when the compiler marks certain registers as used.
In order to understand this problem, the compilation of the rush expression \LirstInline{rush}{n + m} is to be considered.
The rust code in Listing~\ref{lst:riscv_infix_expr} shows parts of the \qVerb{infix_expr} method of the rush compiler.

\Lirsting[float=h, ranges={761-761,849-864,868-868}, path prefix={deps/rush}, caption={Parts of the \qVerb{infix_expr} Method in the RISC-V rush compiler}, label={lst:riscv_infix_expr}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

Like the signature of the method suggests, it consumes an annotated tree-node representing an analyzed infix-expression.
In line 853, the left-hand side expression is compiled, and its result register is saved in the variable \qVerb{lhs_reg}.
Next, in line 854, the previously discussed \qVerb{use_reg} method is used in order to mark the previously allocated register as used.
The second argument to the method specifies the size of the data which the register holds, 64 bits for integers or 8 bits for characters for instance.
This information is also saved in the \qVerb{used_registers} vector and is used in case used registers need to be spilled.
In line 856, the right-hand side is expression is compiled, and its result register is saved in the variable \qVerb{rhs_reg}.
After this, the register returned by the compilation of the left-hand side is marked as unused again.
Finally, in line 861, the \qVerb{infix_helper} method is called in order to insert the instruction for the actual calculation.

However, the reason the left-hand side register is being marked as used is not immediately apparent.
As discussed previously, calling the methods responsible for allocating registers, like \qVerb{alloc_ireg},
repeatedly without marking registers as used results in the allocator method returning the same register.
In this scenario, this would create an issue since both the left-hand side and the right-hand side would result in the identical register, \qVerb{a0} for instance.
Now, the compilation of the right-hand side expression would overwrite the value stored in the register of the left-hand expression, thus creating invalid output code.
In order to mitigate this issue, the register of the left-hand side is marked as used as seen in Listing~\ref{lst:riscv_infix_expr}.
Therefore, the allocator call caused by the compilation of the right-hand side will respect that the register returned by the left-hand side is currently in use and will therefore return the next one.

Next, we will consider the implementation of the \qVerb{infix_helper} helper method.
This method exists since translation of infix operators is required during compilation of both normal infix-expressions and assign-expressions with additional operations, \qVerb{a += 1} for instance.
The rust code in Listing~\ref{lst:riscv_infix_helper} shows parts of this method.

\Lirsting[float=h, ranges={871-871,874-881,987-991,1000-1001}, path prefix={deps/rush}, caption={Parts of the \qVerb{infix_helper} Method in the RISC-V rush compiler}, label={lst:riscv_infix_helper}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

As the method's signature suggests, the left-hand and right-hand side's registers and a type are used its parameters.
Since this register abstraction does not contain type information, as registers are usually untyped, the type information conveys the type of either the left-hand or right-hand side expression.
In case of infix-expressions, which side the type specifies is irrelevant since the analyzer demands that both are identical.
Here, the type information is required order to insert the correct instruction.

In line 874 and 875, an integer and a floating-point output register is allocated.
These registers are saved in a variable for each type, \qVerb{dest_regi} for integers for instance.
Of course, only one of these registers is later used.
However, both are allocated in order to avoid code duplication.
In line 878-881, the code responsible for inserting an integer addition instruction can be seen.
For this, the \qVerb{self.insert} helper method is used.
This inserts a new instruction into the current basic block.
Due to its simplicity its explanation will be omitted.
Here, the \qVerb{Instruction::Add} enum variant is used.
Since the first operand specifies the output reqister, the previously \qVerb{dest_regi} variable is specified.
For the first and second operands, the registers provided as arguments to the \qVerb{infix_helper} method are used.
The \qVerb{Add} enum can only use integer registers, like \qVerb{a0} as its operands.
However, the parameters \qVerb{lhs} and \qVerb{rhs} can be registers of any type.
For this, the conversion method \qVerb{into} is used.
In line 987--990, the code for inserting the float subtraction instruction can be seen.
Since floating-point operations usually require different operators from the one used for integer operations,
it becomes apparent why type information is passed to this method.
Here, the \qVerb{fsub} instruction enum variant is used to represent the addition of floating-point numbers.
In this case, the variable \qVerb{dest_regf} is used as the first operand since it can hold floating-point numbers.

\subsubsection{Functions}

However, before the infix-expression in Listing~\ref{lst:rush_riscv_simple_sum} is compiled,
the compiler considers the functions of the program.
In this case, only the \qVerb{main} function is present.
The rust code in Listing~\ref{lst:riscv_declare_main_fn} shows the \qVerb{declare_main_fn} method of the rush RISC-V compiler.

\Lirsting[float=h, ranges={123-156}, path prefix={deps/rush}, caption={The \qVerb{declare_main_fn} Method in the RISC-V rush compiler}, label={lst:riscv_declare_main_fn}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

Like its signature suggests, the method takes a block, meaning a list of statements as its input.
In the lines 124--126, the \qVerb{_start} label is created and marked as exported so that the linker will later find it.
After this insertion, the \qVerb{curr_block} index is 0, meaning that the block in which is inserted to is the one of the \qVerb{_start} label.

In the lines 128--129, a new block with the \qVerb{main..main} label is created.
As explained previously, this block represents the start of the body of the \qVerb{main} function in rush.
Next, the line 132 inserts a \qVerb{call} instruction which is responsible for calling the \qVerb{main} function when the program is executed.
In the lines 134--135, instructions for calling the \qVerb{exit} function using 0 as the exit code are inserted.
These two instructions are necessary in order to prevent a segmentation fault at the end of the program.

In the lines 137--139, a new epilogue label is generated.
Then, the current function is updated so that it contains this newly created epilogue label.
However, this label is not directly added to the \qVerb{blocks}  vector since it should ideally appear after the body of the function.

Next, in the lines 142--145, the \qVerb{main} function's body is compiled.
For this, the current insertion position is first updated to the end of the previously created \qVerb{main..main} block by using the helper method \qVerb{insert_at} in line 142.
In line 143, a new variable scope is added for the function's body.
Then, the function's body is compiled by calling the \qVerb{function_body} method in line 144.
After the body's compilation, the previously added scope is removed again in line 145.

Now, the code responsible for inserting the prologue is executed.
The prologue is inserted after the function's body even though it introduces each function.
Since the required memory of the function is not known before the function's body is compiled,
no stack space can be allocated before the body of the functions was traversed.
In order to mitigate this issue, the code responsible for a function's prologue is generated after the entire function body has been traversed.

The call to the method \qVerb{prologue} in line 148 generates the instructions which represent the prologue.
Next, in line 149, the insertion position is moved back to the end of the \qVerb{main..main} label.
In line 150, the instructions generated from the function's body are concatenated to the end of prologue instructions.
This way, the variable \qVerb{prologue} now represents a vector containing the instructions of the main function's prologue followed by the ones of its body.
In line 151, the instructions of the current block, meaning the \qVerb{main..main} block, are overwritten with the contents of the variable.
In other words, the current block now contains the function's prologue and body.

In the lines 152--155, the code responsible for inserting the trailing epilogue code can be seen.
For this, in line 153, the previously created epilogue label is now appended to the \qVerb{blocks} vector.
In line 154, the \qVerb{epilogue} method of the compiler is callled.
The rust code in Listing~\ref{lst:riscv_epilogue} shows the \qVerb{epilogue} method of the rush RISC-V compiler.

\Lirsting[float=h, ranges={66-87}, path prefix={deps/rush}, caption={The \qVerb{epilogue} Method in the RISC-V rush compiler}, label={lst:riscv_epilogue}]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

As the context of the previous code snipped suggests, this method is called in order to generate the instructions for a function's epilogue.
First, in the lines 67--68, the insertion position of the compiler is updated to the end of the epilogue label.
This is done since the epilogue must exist in a separate label in order to be reused when \qVerb{return} statements are encontered.
The instruction insertion in line 70 is responsible for a \qVerb{ld} instruction.
As described previously, this particular instruction restores the previously saved \qVerb{fp} register.
Next, in line 75, another \qVerb{ld} instruction for restoring the \qVerb{ra} register is inserted.
In line 80, an \qVerb{addi} instruction is inserted in order to restore the previously allocated stack space.
Finally, a \qVerb{ret} instruction is inserted which is responsible for transferring control back to the caller.
Now it becomes apparent that the inserted instructions resemble the already known patters observed in previously shown listings.

As for the code in Listing~\ref{lst:riscv_declare_main_fn},
the presented method is very similar to the one which translates other rush functions.
However, the \qVerb{function_declaration} method which is responsible for other functions differs in two ways.
First, it contains code which handles function parameters.
Second, the special instructions for calling to the \qVerb{main} and \qVerb{exi} functions are not required for other functions.

\subsubsection{Let Statements}

In line 2 and 3 of the rush program in Listing~\ref{lst:rush_riscv_simple_sum}, let statements are used in order to save values on the stack.
For this, the rush RISC-V compiler implements a separate method named \qVerb{let_statement}.
The rust code in Listing~\ref{lst:riscv_let_stmt} shows the \qVerb{let_statement} method of the rush RISC-V compiler.

\Lirsting[float=h, ranges={554-561}, path prefix={deps/rush}, caption={The \qVerb{let_statement} Method in the RISC-V rush compiler}, label={lst:riscv_let_stmt}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

This method only calls the \qVerb{save_expr_on_stack} method in order to save the resulting memory address in the current scope.
The purpose of the \qVerb{save_expr_on_stack} is explained later.
That method returns an abstraction which represents a memory location on the stack.
In line 558 of Listing~\ref{lst:riscv_let_stmt}, this method is called and the resulting relative memory address is saved in the variable \qVerb{ptr}.
In the next line, this memory address is inserted into the current scope,
thus associating the name of the compiled variable in to its relative memory location.
This data is saved so that the variable can be accessed later.
Since the main work is accomplished by the \qVerb{save_expr_on_stack} method, it will now be considered in detail.
The rust code in Listing~\ref{lst:riscv_save_on_stack} displays parts of the \qVerb{save_expr_on_stack} which was called in line 558 of the previous listing.

\Lirsting[float=h, ranges={563-563,_567-573,586-593}, path prefix={deps/rush}, caption={The \qVerb{save_expr_on_stack} Method in the RISC-V rush compiler}, label={lst:riscv_save_on_stack}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

This method takes an expression in order to save it on the stack.
As its signature suggests, the method returns an \qVerb{Option<Pointer>}.
Just like other methods, this one will return \qVerb{None} if the passed expression yields no value.
Otherwise, the method returns the relative memory address which will contain the value of the saved expression at runtime.
In line 569, the passed expression is compiled, and the resulting register is saved in the variable \qVerb{reg}.
In line 571, the \qVerb{get_offset} method is used in order to calculate the fp-offset of variable.
Since types like char or bool require less memory, the data type of the expression is also passed to the helper method.
Now, the \qVerb{offset} variable contains the fp-offset at which the variable can be saved.
Since the \qVerb{get_offset} method is used every time values need to be saved on the stack,
it also increments the \qVerb{stack_allocs} variable, so that components like the prologue or epilogue are aware of this stack allocation.
The \qVerb{match} block in line 573 executes different code based on the register type which the expression yielded.
In the lines 586--589, the code which is executed if the expression yielded a float register can be seen.
Here, the \qVerb{fsd} instruction is used in order to save the yielded register at the memory position relative to \qVerb{fp} which is specified in the variable \qVerb{offset}.
The code for integer registers is omitted since it also differentiates between 8-bit and 64-bit data.
In line 592, the \qVerb{Pointer} abstraction representing the memory location of the expression is returned.
Here, it is apparent that this variant of a \qVerb{Pointer} only saves a register and an offset to this register.
In this case, \qVerb{fp} is specified as the register and the value of \qVerb{offset} is used as the offset.

\subsubsection{Function Calls and Returns}

In line 4 of the rush program in Listing~\ref{lst:rush_riscv_simple_sum}, the \qVerb{exit} function is called.
Even though the presented \qVerb{exit} function is special, the rush RISC-V compiler is able to translate all sorts of different call-expressions using one internal method.
The rust code in Listing~\ref{lst:riscv_call_expr} shows the first part of the \qVerb{call_expr} method in the RISC-V rush compiler.
This listing only shows the first part of the method since it is too large to be included in a single-page listing.

\Lirsting[float=h, ranges={92-120,127-128,235-235}, path prefix={deps/rush}, caption={The \qVerb{call_expr} Method in the RISC-V rush compiler}, label={lst:riscv_call_expr}]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

Since this method is responsible for translating function calls, its implementation has proven to be very complex and demanding.
As the method's signature suggests, it consumes an analyzed call-expression in order to return an optional register.
No register is returned if a function which returns the \qVerb{()} type or the \qVerb{!} type is called.
In line 4 of the code in Listing~\ref{lst:rush_riscv_simple_sum}, this method would return no register because the \qVerb{exit} function is called.

The parts of code in the shown listing are responsible for preparing the compiler for compilation of the function call.
In the lines 93--102, all registers which are used at the time of the function call are saved on the stack.
This is required since the register allocator of this compiler is so simple that it only considers a function at the time.
In production-ready compiler systems, a register allocation algorithm could also work in an interprocedural manner.
When considering this practical example, it becomes apparent that saving \textbf{all} used registers does not produce the most efficient output code.
However, the presented algorithm remains relatively simple.
Furthermore, throughout the extensive testing conducted on the rush backends, this approach has presented itself as reliable\footnote{For each new commit, \rushCountTests integration tests are conducted on every backend}.
In line 95, a new vector named \qVerb{regs_on_stack} which will later contain registers is created.
The for loop in the lines 96--99 is used to spill every used register to the stack.
For this, the helper method \qVerb{spill_reg} is used.
Due to its similarity to the previously explained \qVerb{save_expr_on_stack} method, this method will not be explained further.
After a register has been saved on the stack, it is added to the previously declared vector.
After the loop, in line 102, the \qVerb{used_registers} vector is moved into the local \qVerb{used_regs_prev} variable.
Therefore, after the assignment, the \qVerb{used_registers} vector will be empty due to its contents being moved into the \qVerb{used_regs_prev} variable.
Through this, the compilation of the argument expressions can use more registers since the spilled registers can be overwritten.

In the lines 104--128, the code determines how much additional memory is required in order to place arguments on the stack, which could not fit into registers.
For most calls, this required memory is usually 0.
However, a call with 9 integer arguments would need 8 additional bytes of memory because the ninth argument would have to be placed on the stack.
The final amount of additional memory is saved in the \qVerb{spill_param_size} variable.
Determination of the required size is performed by the for-loop in line 111.
This loop iterates over each argument expression of the call.
For each expression, the match-block in line 112 executes different code depending on the rush data type of the expression.
For instance, expressions which yield in \qVerb{()} or \qVerb{!} do not require registers and can thus be skipped using the \qVerb{continue} keyword in line 113.
Expressions yielding float variables however are considered in the line 114.
Here, the \qVerb{nth_param} method on the \qVerb{FloatRegister} enum is called.

The rust code in Listing~\ref{lst:riscv_nth_param} shows parts of this method.

\Lirsting[float=H, ranges={215-217,224-227}, path prefix={deps/rush}, caption={The \qVerb{nth_param} Method in the RISC-V rush compiler}, label={lst:riscv_nth_param}]{deps/rush/crates/rush-compiler-risc-v/src/register.rs}

This method associates an index of a parameter to a register which could represent this position.
For instance, the index 2 represents the third parameter, which is represented by the register \qVerb{fa2}.
For any other indices, the method return \qVerb{None}.
Therefore, the if-expression in line 115 of Listing~\ref{lst:riscv_call_expr} checks if there is no longer a register which could represent the current argument position.
This position is saved in the \qVerb{float_cnt} and \qVerb{int_cnt} variables which are incremented during some iterations of the for-loop.
Here, two counters are used in order to preserve independence between integer and float arguments.
If there is no register for representing the current \qVerb{float_cnt}, the variable's value is greater than 7 and thus exceeds the capacity provided by the eight float parameter registers.
If this is was case, the \qVerb{spill_param_size} variable is incremented by 8 bytes since in rush, a floating-point number requires 64 bits of information.
At the end of the float-specific block, the \qVerb{float_cnt} is incremented by one.
This way, the for loop is able to determine if there are any additional memory requirements of the current function.
In line 4 if the code in Listing~\ref{lst:rush_riscv_simple_sum}, the \qVerb{exit} function is called with one integer argument.
After the code displayed in Listing~\ref{riscv_call_expr} has executed,
the runtime value of the \qVerb{int_cnt} variable is 1 while the \qVerb{spill_param_size} variable holds 0.
If the exit function was to be called using two integer registers, the \qVerb{int_cnt} variable would hold the value 2.
Through this example, it becomes apparent what the task of the code displayed in Listing~\ref{lst:riscv_call_expr} are.

However, only the first part of the \qVerb{call_expr} method is shown in this listing.
The rust code in Listing~\ref{lst:riscv_call_expr_2} shows the second part of the method.

\Lirsting[float=H, ranges={130-173,198-199,235-235}, path prefix={deps/rush}, caption={The Second Part of the \qVerb{call_expr} Method in the RISC-V rush compiler}, label={lst:riscv_call_expr_2}]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

In the lines 130--131, the \qVerb{int_cnt} and \qVerb{float_cnt} variables are reset to 0.
In line 134, a new empty vector named \qVerb{params_regs} is created.
The lines 137--143 are responsible for inserting an \qVerb{addi} instruction in order to allocate stack space.
However, this instruction is only inserted if the size of the spilled parameters is non-zero,
meaning that parameters have been spilled.
If this was the case, inserting an instruction in order to allocate memory is required.

Next, the for-loop in line 148 iterates over the argument expressions.
Just like in the last listings, the match-block in line 149 executes different code based on the data type of the argument expression.
In case of unit or never types, the expression is compiled and the resulting value is ignored.
This is reasonable since these types of expressions yield no register.
For other data types, like floats, other code is executed.
Expressions which yield floats for instance are handled in line 153.
In the next line, the expression is compiled and the resulting register is saved in the variable \qVerb{res_reg}.
In line 155, different code depending on whether the current argument needs to be spilled is executed.
If the current expression does not need to be spilled, the code after the line 156 is executed.
Here, \qVerb{res_reg} is only marked as used and pushed in the \qVerb{param_regs} vector.
Interestingly, there is no code validating that the correct register for the argument position is returned.
This check is redundant since all registers have been marked as unused prior to this block.
Therefore, the resulting value of argument expressions will always be in the correct registers.
However, if there is no register for the current argument, the value has to be spilled onto the stack.
For this, a \qVerb{fsd} instruction (or \qVerb{sd} instruction for integers) is inserted in order to save the result of the current argument on the stack.
As described in a previous section about the RISC-V calling convention, spilled arguments are placed on the stack in a way so that the first spilled argument is at the lowest memory position.
For reference, this process is described in detail in Figure~\ref{fig:riscv_call_spill} in Subsection~\ref{sec:riscv_calling_conv} on page~\pageref{sec:riscv_calling_conv}.
In order to calculate this increasing offset easily, the \qVerb{spill_count} variable is declared in line 146.
Every time an argument is spilled, this counter increases.
In line 165, the code calculating the offset relative to \qVerb{sp} can be seen.
Here, the value of \qVerb{spill_count} is simply multiplied by 8 in order to obtain the correct offset.
Therefore, the memory offset $o$ is calculated like this: $o = \text{count}_\text{spilled} \times 8$.
In line 169, the \qVerb{spill_count} variable is incremented like described previously.
Although just the code for floats is shown here, the algorithm for integer-based types only deviates slightly from the one for floats.

Now it has become clear how the argument expressions are compiled.
Even until now, not the entire method has been shown.
The rust code in Listing~\ref{lst:riscv_call_expr_2} shows the last part of the method.

\Lirsting[float=H, ranges={201-235}, path prefix={deps/rush}, caption={The Third Part of the \qVerb{call_expr} Method in the RISC-V rush compiler}, label={lst:riscv_call_expr_3}]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

The code in the lines 201--209 is responsible for mangling the name of the called function so that it includes the \qVerb{main..} prefix.
However, if the \qVerb{exit} function is called, the name is not mangled.
In line 201, the \qVerb{call} instruction responsible for invoking the function call is inserted.
At this point, the arguments are in their correct places so that the called function will be able to access them.
Therefore, the instruction can be inserted without additional effort.

The code in the lines 212--219 is responsible for restoring stack space which was allocated in order to fit spilled arguments.
Of course, the responsible \qVerb{addi} instruction is only inserted if there are indeed spilled arguments.
In line 222, the previously emptied \qVerb{used_registers} vector is restored to its state before the call.
This is done in order to allow the register allocation for the call arguments to happen independently of the rest of the compiled code.
The code in the lines 224--231 is responsible for selecting an appropriate output register based on the function's return type.
For instance, functions which return \qVerb{float} values place their return value inside the register \qVerb{fa0}.
Therefore, the variable \qVerb{res_reg} represents the register containing the called function's return value.
For functions which return the \qVerb{()} or \qVerb{!} type, no register is selected and \qVerb{None} is returned.
The invocation of the helper method \qVerb{restore_regs_after_call} is used in order to insert instructions which restore the previously spilled registers after the call.
The \qVerb{used_registers} vector could only be completely emptied due to the prior save of all used registers, these restored registers need to be restored after the call has completed.
What strikes the eye here is that the method takes the \qVerb{res_reg} variable as its first argument.

For instance, a function might return a value of type \qVerb{int}, therefore making \qVerb{a0} the content of \qVerb{res_reg}.
If the register \qVerb{a0} was used before the function call, it would have to be restored by the helper method.
However, restoring the register would result in the function's return value to be overwritten, therefore creating a bug.
In order to mitigate this issue, the method will alter the result register by inserting a \qVerb{mv} instruction if necessary.
Since the method returns the final output register which contains the call's result, it is used as the last expression of the block, thus making it the return value of the \qVerb{call_expr} method.

Now it has become apparent how function calls are implemented in the rush RISC-V compiler.
However, the question of how a called function returns a value still remains.
In the previous sections, we have covered that every generated function contains an \qVerb{epilogue_x}.
Every time the \qVerb{return} keyword is used in rush, the compiler generates an instruction which jumps to the epilogue label of the function being compiled.
If the function should a value, meaning that the return-statement contains an expression,
it is first compiled in order to observe its output register.
If the output register is already the desired register, like \qVerb{a0} for integer values, the compiler can carry on.
However, if the output register of the compiled expression deviates from the register in which return values shall be passed,
the compiler inserts a \qVerb{mv} instructions prior to the instruction jumping to the epilogue label.
This way, values can be returned at any time while stopping execution of the function.
For implicit returns, meaning trailing expressions which are not terminated by a semicolon,
this procedure is identical.

\subsubsection{Loops}

Since most assembly dialects do not provide high-level control-flow scaffolds like loops,
a compiler targeting assembly has to generate code which behaves like a loop.
The code in Listing~\ref{lst:rush_while_loop} shows a rush program containing a while-loop.
On the right side, Listing~\ref{lst:asm_riscv_while_loop} shows parts of the assembler output generated from the rush program.

\begin{minipage}{.32\textwidth}
	\center
	\Lirsting[caption={A rush Program Containing a While-Loop}, label={lst:rush_while_loop}, float=H]{listings/while_loop.rush}
\end{minipage}%
\hspace{2.5cm}
\begin{minipage}{.47\textwidth}
	\center
	\Lirsting[ranges={21-36},caption={Assembly Output of Rush Program in Listing~\ref{lst:rush_while_loop}}, label={lst:asm_riscv_while_loop}, float=H]{listings/generated/rush_while_loop.s}
\end{minipage}

The rush program in Listing~\ref{lst:rush_while_loop} contains a while loop which will iterate ten times.
At the beginning of the program, the integer variable \qVerb{count} is declared.
Before each iteration, the while-loop checks that the condition in its head is true.
If the condition was true, the code inside the loop is executed.
Otherwise, the execution of the loop stops and the code after the loop is executed.
In the assembly output in Listing~\ref{lst:asm_riscv_while_loop}, the contents of the loop is represented by the instructions inside the \qVerb{while_head_0} label.
The instructions generated from code before the loop are not visible but appear before the code shown in the listing.
As the comment in line 22 suggests, the first instructions after the label declaration represent the loop control code.
These instructions are executed every time time loop begins a new iteration, therefore they check if the condition is true before any of the code inside the loop's body is executed.
If the condition is false, the execution of the loop should stop.

This is accomplished by the \qVerb{beqz} instruction in line 26.
This instruction is a pseudoinstruction which jumps to the target label if the value inside the first operand is zero~\cite[p.~105]{Waterman2019}.
Here, this would mean that the instruction would jump to the \qVerb{after_while_0} label if the condition of the loop evaluated to false.
Just like the name of the \qVerb{after_loop} label suggests, it contains code which follows the while-statement.
Therefore, in this example, it contains the instructions calling the \qVerb{exit} function with the code saved in the variable \qVerb{count}.
However, if the condition evaluated to \qVerb{true}, the \qVerb{beqz} instruction would execute without causing a jump.
In this case, the instructions following the comment in line 27 are executed.
As the comment suggests, these instructions represent the code inside the loop's body.
The instructions in the lines 28--31 represent the expression \qVerb{count += 1} in line 4 of the rush code.
In line 32, an unconditional \qVerb{j} instruction jumps back to the beginning of the \qVerb{while_head_0} label.
Since this jump happens unconditionally, this instructions introduces the iteration for which the loop is desired.
Therefore, at the end of a loop, an instruction jumps back to the start, where the condition is then evaluated again.
This way, the compiler is able to generate instructions for the \qVerb{loop}, \qVerb{while}, and \qVerb{for} statements.
However, \qVerb{loop} statements lack the control code which checks a condition as there is no condition in these loops.
Furthermore, \qVerb{for} loops contain code representing its update expression at the end of their body.
By using this approach, the compiler is also able to generate nested loops reliably.
Due to the simplicity of the presented approach, rust code from the compiler is omitted.
