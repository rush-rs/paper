In the previous chapter, the implementation of a programming language using an interpreter has been explained.
However, another method of implementing a programming language is to create a compiler.
This chapter presents three different compilers for high-level targets, and one transpiler.

\section{How a Compiler Translates the AST}
\begin{wrapfigure}{r}{0.6\textwidth}
	\centering
	\begin{tikzpicture}[level distance=1cm, sibling distance=2.2cm]
        \node {Expression \encircle{5}}
        child {node {Expression \encircle{3}}
                child {node {Expression \encircle{1}}
						child {node {\Verb|Int(1)|}}}
				child {node {\Verb|Plus|}}
                child {node {Expression \encircle{2}}
						child {node {\Verb|Int(2)|}}}}
		child {node {\Verb|Lt|}}
        child {node {Expression \encircle{4}}
				child {node {\Verb|Int(4)|}}};
	\end{tikzpicture}
	\caption{Abstract syntax tree for `\texttt{1 + 2 < 4}'.}\label{fig:cmp_simple_tree}
\end{wrapfigure}

Often, a compiler traverses an AST generated by the analyzer in order to translate it to some sort of output.
For each AST node, the compiler usually calls a separate function or method which is specialized in translating this specific node type, similar to the tree-walking interpreter.
These individual methods return some sort of value representing the translated node.
Otherwise, each individual method may also insert generated instructions into an internal field of the compiler.
Here, the newly generated instructions are inserted into the output sequence.
In this case, each method also returns metadata about the previously compiled node.
For instance, this data may include the register or memory location of a previously compiled expression, so that other AST nodes can refer to it later.
In transpilers, i.e., compilers translating one high-level language into another one, each node-specific method returns another tree node representing code of the output language.

Figure~\ref{fig:cmp_simple_tree} displays a simplified syntax tree of the rush expression `\texttt{1 + 2 < 4}'.
The encircled number after each expression represents the order in which most compilers would traverse this tree.
Compilation of the expression starts at the root node of the tree.
Here, most compilers will begin translation by first compiling the child nodes using \emph{post-order} traversal.
Post-order traversal is frequently used because the compilation of a node often depends on the output of its child nodes.
In this example, translation of the root comparison expression depends on the information returned by compiling its left- and right-hand sides.
Therefore, the compiler first considers the node `Expression~\encircle{3}' which represents the infix-expression \qVerb{1 + 2}.
However, due to post-order traversal, this node is not actually processed since the compiler skips straight to its child nodes.
Therefore, the left child `Expression~\encircle{1}' is traversed as the very first node.
Next, its sibling node `Expression~\encircle{2}' is traversed.
Since post-order traversal involves considering a root node after the traversal of its children, `Expression~\encircle{3}' is traversed after \encircle{1} and \encircle{2} have been considered.
Here, the compiler considers the operator of the expression in order to generate the appropriate output instruction.
Therefore, the instruction responsible for the addition is inserted after `Expression~\encircle{3}' has been traversed.
Since it and its children are now completed, and its output instruction has been inserted, the compiler now considers the right-hand side of the comparison.
Here, the node `Expression~\encircle{4}' only consists of the integer literal `4'.
Now, all child nodes of `Expression~\encircle{5}' have been traversed, thus the compiler now considers this node itself.
Here, the compiler also inserts the appropriate instruction, that is, a less-than comparison between integers.
Since the compiler must be aware of the operands of the instruction, each method involved in the tree traversal returns an entity describing the location of the runtime value of its previously compiled node.
For instance, if the target architecture uses registers, every method translating an expression must return the register or memory location containing the value of the expression at runtime.
By returning information like this, a node will have information about its children after they have been traversed.
It might rely on the values returned by its children, therefore it is traversed at last, thus creating the demand for post-order traversal.

\Lirsting[raw=true, caption={Simple pseudo-instructions for a fictional architecture.}, label={lst:cmp_simple_instructions}, wrap=l, wrap width={.32\textwidth}]{listings/simple_compiler_instructions.txt}

Listing~\ref{lst:cmp_simple_instructions} displays a sequence of instructions for a fictional architecture.
This sequence could have been generated from the previously discussed tree in Figure~\ref{fig:cmp_simple_tree}.
It is apparent that the order of instructions matches the order in which the tree was traversed.
The instructions in lines~1 and 2 represent the tree-nodes `Expression~\encircle{1}' and `Expression~\encircle{2}' respectively.
Here, the value `1' is assigned to a register named `\texttt{r0}' while the value `2' is assigned to the register `\texttt{r1}'.
The \qVerb{add} instruction in line~3 appears after the instructions in lines~1 and 2 since their tree nodes were traversed first.
Furthermore, the instruction uses the registers \qVerb{r0} and \qVerb{r1} as its operands and therefore depends on them containing a value.
Therefore, the \qVerb{add} instruction can use the registers returned by compiling its child nodes as its operands.
Next, the integer `4' is assigned to the register `\texttt{r3}'.
Lastly, the comparison instruction \qVerb{lt} uses the result of the addition and the register containing `4' as its operands.
Here, it is apparent that the instruction generated by the node which was traversed at last is also inserted at the end.

Therefore, using post-order traversal in order to generate output instructions targeting a register-based architecture is often required.
This example illustrates how a simple compiler might operate.
However, a similar algorithm is often found in even the most complex compilers.
