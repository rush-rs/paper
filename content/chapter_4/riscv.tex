\newpage

\section{RISC-V: Compiling to a Modern RISC Architecture}

%\enquote{RISC-V is a recent, clean-slate, minimalist, and open ISA informed by mistakes of past ISAs. The goal of the RISC-V architects is for it to be effective for all computing devices, from the smallest to the fastest. Following von Neumann’s 70-year-old advice, this ISA emphasizes simplicity to keep costs low while having plenty of registers and transparent instruction speed to help compilers and assembly language programmers map actually important problems to appropriate, quick code.}\cite[p.~11]{Patterson2017}
% \begin{itemize}
% 	\item Introduced in 2011 X
% 	\item UC Berkely research project X
% 	\item Since then: rising in popularity X
% 	\item ISA = \enquote{instruction set architecture} X
% 	\item Was developed for: NO
% 	      \begin{itemize}
% 		      \item All sizes of processors: from embedded to high-performance computer
% 		      \item compatibility to popular software stacks and programming languages
% 		      \item serves as extendable base for customized accelerators
% 		      \item Should be stable
% 	      \end{itemize}
% 	\item One of the few ISAs which were developed this decade instead of the 1970s / 1980s X
% 	\item Open ISA: unlike most previous ISAs, it is free from a bond to a single comporation X
% 	\item Base ISA: \qVerb{RV321}.
% 	      Frozen, will never change, gives assembly programmers and compiler writers a stable target.
% 	\item The base instruction set is extendable using extensions like (multiply: \qVerb{RV32M}) or (double-precision floats: \qVerb{RV32D}).
% 	\item \enquote{RISC-V is a recent, clean-slate, minimalist, and open ISA informed by mistakes of past ISAs. The goal of the RISC-V architects is for it to be effective for all computing devices, from the smallest to the fastest. Following von Neumann’s 70-year-old advice, this ISA emphasizes simplicity to keep costs low while having plenty of registers and transparent instruction speed to help compilers and assembly language programmers map actually important problems to appropriate, quick code.}\cite[p.~11]{Patterson2017}
% \end{itemize} \cite[Chapter~1]{Patterson2017}.
%
% \TODO{Also interesting: \cite[p.~10]{Patterson2017}, \cite[Chapter~2]{Patterson2017}.}
%
% \begin{itemize}
% 	\item Present Some example instructions (Refer to chapter 3 of the RISC-V READER)
% 	\item Register layout \& count
% 	      RISC-V has 32 registers, ARM-32 16, x86\_32 has 8\\
% 	      Assembly includes all extensions\\
% 	      Concepts of \emph{pseudoinstructions}~\cite[p.~10]{Patterson2017}\\
% 	      Has basic instructions for add, sub, and logical operations\\
% 	      \emph{Check for all relationships between two registers, some conditional expressions involve rela- tionships between many pairs of registers. The compiler or assembly language programmer could use slt and the logical instructions and, or, xor to resolve more elaborate conditional expressions. The two remaining integer computation instructions Figure 2.1 help with assembly and}
% 	      r0 → constant 0 register\\
% 	      ~\cite[p.~18]{Patterson2017}
% 	\item ASM directives: \cite[p.~39]{Patterson2017}
% 	\item ASM includes 60 pseudoinstructions: \cite[p.~42]{Patterson2017}
% 	\item Another 32 Float registers, float load / store instructions: \cite[pp.~48f.]{Patterson2017}
% 	\item Refer to stack figure: \cite[p.~40]{Patterson2017}
% 	\item Calling convention
% \end{itemize}

The \emph{RISC-V} \emph{ISA}\footnote{Short for: \enquote{instruction set architecture}} is a new and modern \emph{reduced instruction set} architecture focussing on simplicity and expandability.
The initial version was developed at \emph{UC Berkely} in the context of another related research project.
Since its introduction in 2011, the architecture has been rapidly growing in popularity.
Since the beginning, the project has been managed and led by the \emph{RISC-V foundation}, consisting of many individuals contributing to the project.
Today, corporate members of the RISC-V foundation include companies like \emph{Google}, \emph{Microsoft}, \emph{Samsung}, and \emph{IBM}.
Therefore, the general popularity and commercial attraction of the technology is apparent.
However, unlike most previous ISAs, the RISC-V architecture is a completely \emph{open-source} project and is therefore not controlled by a single large corporate entity.
This can be regarded as a large competitive advantage over other popular RISC architectures like \emph{ARM}.
In the past, many ISAs have failed due to them being too restrictive with their licensing, thus preventing widespread commercial adoption.
However, RISC-V is completely open and free to use, so that many companies like \emph{Google} can leverage the technology commercially whilst contributing to the project.
Unlike most of the previous ISAs, which were developed during the 1970s or 80s, RISC-V is one of the few which were developed this decade.
Therefore, it seems like RISC-V could be a significant architecture to be used in all sorts of devices in the near future~\cite[preface]{Patterson2017}.

\subsection{Register Layout}

\begin{wraptable}{r}{.4\textwidth}
	\centering
	\caption{Common Registers in RISC-V~\cite[p.~155]{Waterman2019}}\label{tbl:riscv_regs}
	\begin{tabularx}{\linewidth}{l|L}
		\rowcolor{gray!10} Register   & Purpose                         \\ \hline
		\texttt{zero}                 & Hardwired zero                  \\ \hline
		\texttt{ra}                   & Return address                  \\ \hline
		\texttt{sp}                   & Stack pointer                   \\ \hline
		\texttt{t0} —  \texttt{t6}    & Temporary                       \\ \hline
		\texttt{fp}                   & Frame Pointer                   \\ \hline
		\texttt{a0}, \texttt{a1}      & Function argument, return value \\ \hline
		\texttt{a2} — \texttt{a7}     & Function argument               \\ \hline
		\texttt{s1} — \texttt{s11}    & Saved register                  \\ \hline
		\texttt{fa0}, \texttt{fa1}    & FP args, return value           \\ \hline
		\texttt{fa2} — \texttt{fa7}   & FP args                         \\ \hline
		\texttt{fs0} — \texttt{fs11}  & FP saved registers              \\ \hline
		\texttt{ft0} —  \texttt{ft11} & FP temporaries                  \\
	\end{tabularx}
\end{wraptable}

Most RISC architectures typically have a large count of registers~\cite[Chapter~2]{Dandamudi2005}.
When compared to other popular architectures, the truth of this statement becomes clear.
For instance, the \emph{x86\_32} architecture has 8 registers.
The popular RISC architecture \emph{ARM-32} provides twice that amount, meaning 16 registers.
However, a RISC-V CPU includes 32 registers, which is drastically more than the previously mentioned architectures.
Moreover, these 32 registers only include registers holding integer values.
Just for floating-point numbers, the ISA even provides another 32 registers.
Like previously explained, using more registers usually leads to increased efficiency of the output program.
Therefore, a register allocation algorithm targeting the RISC-V architecture could be more aggressive compared to one targeting x\_86 for instance~\cite[p.~10]{Patterson2017}.

The Table~\ref{tbl:riscv_regs} shows most of the registers which the RISC-V architecture provides.
For this table, the official ABI names of the registers have been used in order to make this section easier to read.
The first column of the table contains a register's name whilst the second column describes its purpose.

The first row of the table contains the \qVerb{zero} register.
On RISC-V, this register is special.
Like its name suggests, it holds the value of a constant 0.
Unlike other registers, it is read-only, meaning that it can never be overwritten, therefore preventing accidental writes.
In the next row, the \qVerb{ra} register is shown.
It saves the \emph{return address} of a function or subroutine.
If a return-instructions is used, the value in \qVerb{ra} is read as it is used to jump to a specific instruction.
The purpose of this register is elaborated further in Subsection~\ref{sec:riscv_calling_conv} about RISC-V's calling convention.
The \qVerb{sp} and \qVerb{fp} registers are used for managing stack memory.
Their purpose is explained in Subsection~\ref{sec:riscv_stack} about stack memory.
In the fourth row, the \qVerb{t0} — \qVerb{t6} are displayed.
These registers are often used to store temporary values used in larger computations.
In row six, the registers \qVerb{a0} and \qVerb{a1} can be seen.
These both serve as call arguments and return values of functions.
The remaining a-registers \qVerb{a2} — \qVerb{a7} can only be used as function call arguments.
How functions are called using registers will be explained in Subsection~\ref{sec:riscv_calling_conv}.
The next row contains the \emph{saved} registers \qVerb{s1} — \qVerb{s11}.
These registers are typically preserved across function calls, meaning a called function must not overwrite them.
However, this concept will also be explained in more detail later. \TODO{Will it?}
What the previously explained registers have in common is that they all hold integer values.
Depending on the exact RISC-V architecture, all registers either hold 32 or 64 bits of information.
For floating-point number values, RISC-V provides other registers.
Just like their integer counterparts, the floating-point registers \qVerb{fa0} and \qVerb{fa1} are used as function call arguments and as return values.
However, the other fa-registers \qVerb{fa2} — \qVerb{fa7} can only be used as function arguments holding floating-point numbers.
Just like the \qVerb{sx} registers, the \qVerb{fs0} — \qVerb{fs11} registers are usually preserved across function calls.
Last, the \qVerb{ft0} — \qVerb{ft11} registers can be used as temporary registers for floating-point numbers.
It is apparent that the floating-point registers are provisioned very similarly to the integer registers.
Therefore, a programmer or compiler targeting the architecture can utilize roughly the same principles,
regardless of the data-type stored in each register~\cite[pp.~18f,p.~34]{Patterson2017},~\cite[p~.155]{Waterman2019}.

Now, it has become apparent that RISC-V includes many registers which are grouped into semantic categories.
Every category is meant to be used in the specified manner, however, these groups are mostly only a suggestion of how each register should be used.
Although this subsection provides a good overview over the registers of the architecture, the purpose of some special registers is still not known.
These special registers, like \qVerb{sp}, \qVerb{fp}, and \qVerb{ra}, are thoroughly explained in the next sections.

\subsection{Memory Access Through the Stack}\label{sec:riscv_stack}

% \begin{wrapfigure}{R}{0.42\textwidth}
% 	\centering
% 	\begin{tikzpicture}[node distance=5mm]
% 		\node(stack)[
% 			vstack=6,
% 			rectangle split part fill={none, none, gray!20, gray!20, none, none},
% 			rectangle split part align=left,
% 		]{
% 			\nodepart{one}{{\texttt{\tiny 24(sp)}} fp$_0$}
% 			\nodepart{two}{{\texttt{\tiny 16(sp)}} ra$_0$}
% 			\nodepart{three}{{\texttt{\tiny -24(fp)}} \scriptsize a: int}
% 			\nodepart{four}{{\texttt{\tiny -25(sp)}} b: char}
% 			\nodepart{five}{{\texttt{\tiny 8(sp)}} fp$_1$}
% 			\nodepart{six}{{\texttt{\tiny 0(sp)}} ra$_1$}
% 		};
% 		\draw [thick, dashed] ([xshift=-.5cm, yshift=-.33cm]stack.four west) --  node[anchor=west, xshift=2cm, align=center] {\scriptsize function\\ \scriptsize boundary} ([xshift=.5cm, yshift=-.33cm]stack.four east);
%
% 		\node(sp)[left of=stack, xshift=-2.2cm, yshift=-0.32cm, align=left] {\scriptsize SP$_0$ \\ \scriptsize FP$_1$};
% 		\draw[arrow, shorten >= 2pt](sp) -- (stack.four west);
%
% 		\node(fp)[left of=stack, xshift=-2.2cm, yshift=2.26cm] {\scriptsize FP$_0$};
% 		\draw[arrow, shorten >= 2pt](fp) -- ([yshift=.74cm]stack.one west);
%
% 		\node(sp)[left of=stack, xshift=-2.2cm, yshift=-1.6cm] {\scriptsize SP$_1$};
% 		\draw[arrow, shorten >= 2pt](sp) -- (stack.six west);
% 	\end{tikzpicture}
% 	\caption{Spilled Registers During a RISC-V Function Call \TODO{Every row should be equal in height}}\label{fig:riscv_call_spill}
% \end{wrapfigure}


% TODO: place this in a preamble
\newcommand{\cellptrA}[1]{
	\draw[<-,line width=0.7pt] (0.1,\value{cellnb}) +(2,\value{ptrnb}*0.1) -- +(3.4,\value{ptrnb}*0.75);
	\draw (3.5,\value{ptrnb}*0.8+\value{cellnb}) node[anchor=west] {#1};
	\addtocounter{ptrnb}{1}
}

%\tikzstyle{freecell}=[fill=blue!10,draw=blue!30!black]
%\tikzstyle{occupiedcell}=[fill=gray!10!orange!10,draw=blue!30!black]
%\tikzstyle{padding}=[fill=yellow!20,draw=blue!30!black]
%\tikzstyle{highlight}=[draw=orange!50!black,text=orange!50!black]

\begin{wrapfigure}{L}{0.39\textwidth}
	\hspace{-3.25cm}
	\begin{tikzpicture}[scale=.9]
		\small
		\stacktop
		\startframe
		\cellcom{\scriptsize 32(sp)} \cellptr{\scriptsize \texttt{fp\,$_\text{main}$}}
		\cell{fp} \cellcom{\scriptsize 24(sp)}
		\cell{ra} \cellcom{\scriptsize 16(sp)}
		\cell{a: int} \cellcom{\scriptsize -24(fp)} \cellptrA{\scriptsize \texttt{sp\,$_\text{main}$}}
		\cell{b: char} \cellcom{\scriptsize -25(fp)} \cellptrA{\scriptsize \texttt{fp\,$_\text{foo}$}}
		\finishframe{\tt main}
		\startframe
		\cell{fp} \cellcom{\scriptsize 8(sp)}
		\cell{ra} \cellcom{\scriptsize 0(sp)} \cellptrA{\scriptsize \texttt{sp\,$_\text{foo}$}}
		\finishframe{\tt foo}
		\stackbottom
	\end{tikzpicture}
	\caption{\TODO{Write a caption}}\label{fig:TODO}
\end{wrapfigure}

\lipsum[1]

\Lirsting[caption={A rush Program Containing Two Variables}, label={lst:rush_riscv_stack}, float=H]{listings/riscv_stack.rush}

\begin{itemize}
	\item In the current implementation, \qVerb{sp} includes legal memory locations
	\item \qVerb{fp} points to the first address after the last legal one
	\item The stack grows into lower memory regions
	\item Stack is slower than registers
	\item Show which instructions can be used for accessing the stack (briefly)
	\item Explain example rush program
	      \begin{itemize}
		      \item How \qVerb{fp}  and \qVerb{ra} are saved
		      \item Addressing either by \qVerb{sp} or \qVerb{fp}
		      \item Why are variables saved relative to \qVerb{fp} and the special registers relative to \qVerb{fp}
		      \item How can the compiler keep track of variables? (HashMap)
		      \item How can we observe alignment here?
	      \end{itemize}
\end{itemize}

\lipsum[2-4]

% \begin{figure}[h]
% 	\includegraphics[width=\textwidth]{./riscv_stack_draft.png}
% 	\caption{\textcolor{red}{DRAFT:} Stack Memory on the RISC-V architecture}\label{fig:riscv_stack}
% \end{figure}

\subsection{Calling Convention}\label{sec:riscv_calling_conv}

\begin{wrapfigure}{R}{0.42\textwidth}
	\centering
	\begin{tikzpicture}[node distance=5mm]
		\node(stack)[
			vstack=6,
			rectangle split part fill={none, none, gray!20, gray!20, none, none},
			rectangle split part align=left,
		]{
			\nodepart{one}{{\texttt{\tiny 24(sp)}} fp$_0$}
			\nodepart{two}{{\texttt{\tiny 16(sp)}} ra$_0$}
			\nodepart{three}{{\texttt{\tiny 08(sp)}} argument 2}
			\nodepart{four}{{\texttt{\tiny 00(sp)}} argument 1}
			\nodepart{five}{{\texttt{\tiny 8(sp)}} fp$_1$}
			\nodepart{six}{{\texttt{\tiny 0(sp)}} ra$_1$}
		};
		\draw [thick, dashed] ([xshift=-.5cm, yshift=-.33cm]stack.four west) --  node[anchor=west, xshift=2cm, align=center] {\scriptsize function\\ \scriptsize boundary} ([xshift=.5cm, yshift=-.33cm]stack.four east);

		\node(sp)[left of=stack, xshift=-2.2cm, yshift=-0.32cm, align=left] {\scriptsize SP$_0$ \\ \scriptsize FP$_1$};
		\draw[arrow, shorten >= 2pt](sp) -- (stack.four west);

		\node(fp)[left of=stack, xshift=-2.2cm, yshift=2.26cm] {\scriptsize FP$_0$};
		\draw[arrow, shorten >= 2pt](fp) -- ([yshift=.74cm]stack.one west);

		\node(sp)[left of=stack, xshift=-2.2cm, yshift=-1.6cm] {\scriptsize SP$_1$};
		\draw[arrow, shorten >= 2pt](sp) -- (stack.six west);
	\end{tikzpicture}
	\caption{Spilled Registers During a RISC-V Function Call \TODO{Every row should be equal in height}}\label{fig:riscv_call_spill}
\end{wrapfigure}

Just like previously explained, most architectures provide a calling convention which dictates how low-level function calls should be managed.
For most architectures, the calling convention is part of the ISA's official specification.
In the case of RISC-V, the calling convention is specified in a separate document~\cite{RiscvABI2022}.

The first step of calling a function involves placing the arguments in a place where the function can access them.
For RISC-V, this involves placing the arguments into specialized registers.
Like described in the Table~\ref{tbl:riscv_regs}, only special classes of registers can be used as call arguments.
For integer arguments, the first arguments are placed in the registers \qVerb{a0}--\qVerb{a7}
For instance, the first two arguments of the rush function call
% TODO: this is broken? \LirstInline{rush}{let mut}
\qVerb{foo(40, 2, 3.14)} would be placed in the registers \qVerb{a0} and \qVerb{a1}.
However, the third argument is a floating-point number and can therefore not be placed inside an integer register.
Therefore, the first floating-point argument register \qVerb{fa0} contains the argument \qVerb{3.14}.
In this case, all arguments can be held in regisers and spilling would not be required.

In case the function accepted nine or more integer arguments,
all further integer arguments upward of the ninth position would have to be spilled on the stack.
Here, the successive registers \qVerb{a0}--\qVerb{a7} would contain the first eight integer arguments of the called function.
The argument at position 9 however is then spilled on the stack since there are no registers left which could contain the additional argument~\cite[p~.8]{RiscvABI2022}.

The Figure~\ref{fig:riscv_call_spill} displays a possible state of the call stack during a function call which uses ten integer arguments.
If ten integer arguments are used, two arguments would have to be spilled on the stack.
In the figure, the spilled registers are placed in the stack cells \enquote{argument 1} and \enquote{argument 2}.
Here, the cell \enquote{argument 1} would hold the ninth argument whilst \enquote{argument 2} holds the tenth argument.
Therefore, all spilled argument registers will be placed in the stack frame of the caller function.
Normally, variables saved on the stack are aligned to reflect their sizes.
In case of spilled argument registers however, every argument will occupy exactly 8 bytes on the stack, even if the data type itself requires less space.

Now that the first step of a procedure call is explained, the question of how the second step works in RISC-V remains.
In the second step, the underlying procedure call is made using a specialized instruction.
In RISC-V assembly, one typically uses the call \emph{pseudoinstruction}\footnote{A macro generating multiple instructions from one pseudoinstruction. Therefore, the actual count of ISA instructions remains low whilst convenience features can be used in assembly~\cite[p.~68]{Dandamudi2005}.}.
Due to a lack of functions in assembly, the call-instruction uses the name of its target label as one operand.
Therefore, labels can be called as if they were functions.
This instruction will jump to the first instruction of the specified target label whilst saving the address of the next instruction after the \qVerb{call} instruction in the register \qVerb{ra}~\cite[p.~22]{Patterson2017}.
As hinted previously, the \qVerb{ra} register saves the \emph{return address}.
Therefore, the return address is set every time a function call is performed.
% TODO: Since this register holds the address of the next instruction after the function's call-instruction, similarities to the call-stack of the rush VM can be noticed?

During the third step of the function call, the called function acquires local storage resources.
To be precise, the function decrements the stack pointer by the amount required by the stack frame.
Therefore, the function allocates as much stack space as required for storing local variables and other data.
Additionally, the frame pointer and return address are saved on the stack so that nested function calls do not cause issues.
For instance, if the return address was not saved on the stack, a nested function call would overwrite its stored value.
In this case, the parent function could no longer return since the return address now holds an incorrect value.
In order to mitigate issues like this, the return address and frame pointer are saved on the stack.
Figure~\ref{fig:riscv_call_spill} shows that the two registers are saved at the two positions on the top of the new stack frame.
This part of the function is often called the \emph{prologue} as it is executed before any of the function's internal code.

After the code of the function has been executed, the so-called \emph{epilogue} is executed.
Since the frame pointer and return address have been saved on the stack during the prologue,
the epilogue restores these registers by loading their values from the stack.
Furthermore, the amount which was subtracted from the stack pointer in the prologue is now added to the pointer in order to restore it to its original state before the function call.
Here, incrementing the stack pointer represents deallocating the previously acquired stack space.
However, the memory in the stack frame is not actually deleted since only the stack pointer is modified.
Even though the used memory is not explicitly deleted, it is still freed since it will probably be overwritten by the next function call.
If the prologue would not save the return address on the stack, a nested function call would overwrite the return address of the parent function, therefore creating a bug~\cite[p.33]{Patterson2017}.
By saving the return address on the stack, nested function calls do not cause difficulties.
It is apparent that this design contains a lot of similarities to the call-stack of the rush VM\@.
However, in the VM, the process of saving and restoring the return address was managed automatically by the VM,
whereas, here, the programmer has to manually pay attention to saving and restoring this important piece of data.
Therefore, implementing function calls is definitely more demanding in RISC-V assembly than in the rush VM\@.

In case a function returns a value, it must be communicated to the caller so that it can access it.
For integer-based types, the first return value of a function is placed in the register \qVerb{a0}
whilst floating-point numbers are placed in the register \qVerb{fa0}.
This way, the caller code can obtain a function's return value by accessing the \qVerb{a0} and \qVerb{fa0}
registers respectively. If a function does not return a value, these steps are just omitted.
It is to be mentioned that character and boolean values are also placed inside the \qVerb{a0} register since these types can be represented by integers.

Lastly, the epilogue contains a return-instruction which should jump to the place where the function was called.
This \emph{ret} instruction reads the value stored in \qVerb{ra} in order to jump to this address.


% \begin{figure}[h]
% 	\includegraphics[width=.3\textwidth]{./riscv_call_stack_draft.png}
% 	\caption{\textcolor{red}{DRAFT:} Spilled Call Registers on the RISC-V Architecture}\label{fig:riscv_stack}
% \end{figure}

% \TODO{Continue here}
%
% \begin{itemize}
% 	\item Prologue
% 	      \begin{itemize}
% 		      \item Decrement stack pointer X
% 		      \item Adjust frame pointer    X
% 		      \item Save return address     X
% 	      \end{itemize}
% 	\item Epilogue
% 	      \begin{itemize}
% 		      \item Restore stack- and frame pointer X
% 		      \item Load previously saved return address X
% 		      \item Return to the caller instruction
% 	      \end{itemize}
% \end{itemize}
%

\subsection{The Core Library}

Like hinted in the section about the linker on page~\pageref{sec:linker},
a program might use functionality provided by external libraries.
In case of the rush RISC-V compiler, external functions are used for character-arithmetic,
the mathematical power operator, and \emph{kernel}\footnote{\TODO{Explaination + Citation}} system-calls,
like \emph{exit}\footnote{Terminates the execution of the program with an arbitrary exit code}.
Since these concepts must introduce additional logic, the compiler should not be emitted their instructions everytime they are used.
In that case, the repeated emission of redundant instructions would result in enlarged and unnecessary complex output code.
In order to mitigate these issues, the compiler simply inserts call-instructions referencing external functions.
External functions can be called just like any other function, however, their definition is not found in the same assembly file.
As described previously, resolving these external calls is later handled by the linker.
For this compiler, we later refer to this target specific library code by the term \emph{corelib}.

For instance, a function for mathematical power operations is implemented in the corelib.
Therefore, the compiler can emit a procedure call to this method every time rush's \qVerb{**} operator is used in the source program.
For this project, the entire corelib is written in RISC-V assembly.
However, it is often rational to implement a corelib or standardlib using a high-level language like C.
Since the corelib's functions are specified in separate files, they are packaged into an \emph{archive file}\footnote{\TODO{What are archives + Citation}} which is later used by the linker.

\subsection{RISC-V Assembly}

The Listing~\ref{lst:riscv_simple} shows a rush program containing two functions and a global variable.
In line 1 of the rush program, the mutable global variable \qVerb{m} is defined with the initial value 42.
In line 4 of the main-function, \qVerb{m} is incremented by 1.
Next, in line 5, the \qVerb{foo} function is called using \qVerb{m} as the only call argument.
\TODO{continue here}
In line 6, a return-statement is used to terminate the main-function explicitly.
The body of the \qVerb{foo} function only contains a call to the \qVerb{exit} function.
Therefore, the \qVerb{foo} function only exits using the specified parameter \qVerb{n} as the exit code.
In this case, the exit code of the displayed program will be 43.
The code in Listing~\ref{lst:riscv_simple_asm} on page~\pageref{lst:riscv_simple_asm} shows the output assembly generated from this program by the rush RISC-V compiler\footnote{Generated in Git commit \rushCommit, automatically built with this document}.
Because the assembler code of the \qVerb{foo} function would take up too much space in the assembler program, it is intentionally omitted from this listing.
Since the excluded function does not introduce any new concepts anyway, omitting it will not lead to a loss of explained concepts.

\Lirsting[float=H, caption={Example rush Program Containing Two Functions}, label={lst:riscv_simple}]{listings/riscv_simple.rush}

\begin{wrapfigure}{L}{0.5\textwidth}
	\centering
	\Lirsting[ranges={1-31, -4 53-56}, fancyvrb={frame=none}]{listings/generated/riscv_simple.s}
	\caption{Compiler Output from the Rush Program in Listing~\ref{lst:riscv_simple}}\label{lst:riscv_simple_asm}
\end{wrapfigure}

In line 1, the \qVerb{.global} assembler directive is used to declare the global symbol \qVerb{_start}~\cite[p~.36]{Patterson2017}.
On most architectures, the \qVerb{_start} label indicates a program's entry point, therefore marking the first instruction to be executed~\cite[p.~19]{Zhirkov2017-wk}.
In line 5, the \qVerb{_start} label is defined by placing a colon after its name.
In line 6, the \qVerb{call} instruction is used to call the \qVerb{main..main} function.
What strikes the eye here is that the already familiar \qVerb{main} function is prepended by the \qVerb{main..} prefix.
Since this rush compiler implements name mangling\footnote{Compilers often \emph{mangle} names in order to create a unique name for every function~\cite[pp.~119-120]{Levine2000}},
every function declared in a rush program will contain this prefix.
However, unlike high-level function calls in LLVM, this call instruction is used alongside the previously explained low-level calling conventions of RISC-V.

In the next line, the \qVerb{li} instruction is used to load the constant integer 0 into the register \qVerb{a0}~\cite[reference]{Patterson2017}.
Like explained in the previous section about the RISC-V calling convention,
the register \qVerb{a0} is used for the first integer call argument.
In line 8, the \qVerb{exit} function is called, however, one cannot see the definition of this function in the current file.
This is because the exit function is provided by the rush RISC-V corelib which was explained previously.
Since 0 was previously placed inside the register for the first integer call argument, the \qVerb{exit} function is called using 0 as the argument.
Therefore, the instructions in the lines 7--8 are responsible for terminating the program using the exit code 0.
These two instructions are always inserted at the end of the \qVerb{_start} label in order to terminate the program appropriately in case the rush code does not call \qVerb{exit} on its own.
This is required in order to prevent a segmentation fault which occurs if the program is not terminated properly.

Due to the function call in line 6, we will now shift our focus on the \qVerb{main..main} label in line 10.
In line 11, the first line of the \qVerb{main} function, a comment indicates the beginning of the function's prologue.
Just like demanded by the RISC-V calling convention, the rush compiler emits code for a \emph{prologue} and an \emph{epilogue} into each function.

As described in the previous sections about calling conventions, one task of the prologue is allocating stack space.
In this prologue, the \qVerb{addi} instruction in line 12 subtracts 16 from the value stored in the \qVerb{sp}.
Here, an addition instruction is used even though subtraction is required.
In RISC-V, the \qVerb{addi} instruction requires one register and one immediate value as its operands.
Due to the third operand being an \emph{immediate} value, the trailing \qVerb{i} (\emph{immediate}) appears in the instruction's name.
Since this immediate value can be negative, an additional instruction for immediate subtraction is redundant~\cite[reference]{Patterson2017}.
This example shows how the RISC-V ISA omits redundant instructions in places where it is feasible.
In this case, the stack pointer is decremented by 16 since two 8-byte values are stored on the stack in the lines 13 and 14.
Here, the values of the registers for the frame pointer and the return address are saved on the stack.

The comment in line 17 indicates the start of the function's body.
First, the previously explained \qVerb{li} instruction in line 18 places a constant 1 in register \qVerb{a0}.
Next, the \qVerb{ld} instruction in line 19 is used in order to load the value of the global variable \qVerb{m} into the register \qVerb{a0}~\cite[reference]{Patterson2017}.
Global variables, like \qVerb{m} in this example are saved under the \qVerb{.rodata}. section or under the \qVerb{.data} section if they are mutable.
In this example, \qVerb{m} is not declared as mutable and therefore saved under the \qVerb{.rodata} section.
The start of the \qVerb{.rodata} section is represented by the \qVerb{.section} assembler directive found in line 53.
Here, a label called \qVerb{m} is defined.
In this label, the \qVerb{.dword} directive is used to define the global initializer value of the variable.
In RISC-V, this directive stores 64 bit of information in successive memory doublewords~\cite[p.~39]{Patterson2017}.
The initializer value of the global variable is 42 and is represented as \qVerb{0x2a} using hexadecimal in the assembly code.
Since these data labels require their contents to be specified in hexadecimal, the trailing comment shows the base 10, human-readable version of the number.
Because global variable are not saved on the stack, special instructions like \qVerb{ld} are required to interact with global variables stored in the program's data sections.

At this point, the register \qVerb{a0} would contain 1 and \qVerb{a1} would contain 42.
In line 20, the \qVerb{add} instruction is used in order to save the sum of \qVerb{a0} and \qVerb{a1} in the register \qVerb{a2}.
Now, the value saved in \qVerb{a2} would be 43.
Next, the \qVerb{sd} instruction in line 21 saves the value of the register \qVerb{a2} at the memory location of the global variable \qVerb{m}, meaning that \qVerb{m} is updated to reflect its new value 43.
It now becomes apparent that these instructions are responsible for the add-assign expression in line 4 of the rush program.
Another interesting observation is that the last operand of the \qVerb{sd} instruction specifies the temporary register \qVerb{t6}.
The instruction uses this register for saving temporary data during the process of saving data in \qVerb{m}~\cite[reference]{Patterson2017}.

In line 22, the previously explained \qVerb{ld} instruction is used in order to load the value of the same variable into the register \qVerb{a0}.
Then, the \qVerb{call} instruction in line 23 is used in order to call the \qVerb{foo} function using the value of m as its argument.
However, one cannot easily observe how call arguments are passed here.
Like explained previously, the first integer argument of a function call must be placed in the register \qVerb{a0}.
Since \qVerb{m} was loaded into \qVerb{a0} previously, it will be used as the call argument for \qVerb{foo} automatically.
Therefore, the \qVerb{foo} function is called using 43 as the first argument.

Since the \qVerb{foo} instruction only calls the \qVerb{exit} function, its explanation will not be beneficial for introducing new concepts.
Therefore, we will omit the explanation of the assembler output of the \qVerb{foo} function.
The final instruction of the main-function's body is the \qVerb{j} instruction in line 24.
This instruction will cause the CPU to jump to the address of the specified label.
In this example, the CPU will jump to the first instruction of the \qVerb{epilogue_0} label~\cite[p.~17]{Patterson2017}.
Therefore, the rush compiler uses the \qVerb{call} instruction for jumps caused by function calls and the \qVerb{j} instruction for jumps between blocks of the current function.

Like explained previously, every function has a \emph{prologue} and an \emph{epilogue}.
Since one of the tasks handled by the epilogue is releasing resources allocated by the prologue, the function's stack pointer is incremented in line 30.
Finally, the \qVerb{ret} instruction in line 31 is used in order to jump back to the instruction whose address is specified in the \qVerb{ra} register~\cite[reference]{Patterson2017}.

\subsection{Supporting Pointers}

\begin{itemize}
	\item REF: Saving the absolute address of a variable into another variable
	\item DEREF: Loading the address stored in the pointer first, then load value at the specified address
\end{itemize}

\subsection{The rush Compiler Targeting RISC-V Assembly}

\begin{itemize}
	\item Traverses the tree
\end{itemize}
