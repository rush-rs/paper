% chktex-file -2
\newpage
\section{\riscv{}: Compiling to a Modern RISC Architecture}

The \emph{\riscv{}} \emph{ISA}\footnote{Short for: \enquote{instruction set architecture}, it specifies an abstract model of a CPU.} is a new and modern \emph{reduced instruction set} architecture focussing on simplicity and expandability.
The initial version was developed at \emph{UC Berkely} in the context of another related research project.
Since its introduction in 2011, the architecture has been rapidly growing in popularity while being managed and led by the \emph{\riscv{} foundation}.
Today, corporate members of the \riscv{} foundation include companies like \emph{Google}, \emph{Microsoft}, \emph{Samsung}, and \emph{IBM}.
Therefore, the general popularity and commercial attraction of the technology is apparent.
However, unlike most previous ISAs, the \riscv{} architecture is a completely \emph{open source} project and is therefore not controlled by a single large corporate entity.
This can be regarded as a large competitive advantage over other popular RISC architectures like \emph{ARM}.
In the past, many ISAs have failed due to them being too restrictive with their licensing, thus preventing widespread commercial adoption.
However, \riscv{} is completely open and free to use, so that many companies can leverage the technology commercially while contributing to the project.
Unlike most of the previous ISAs, which were developed during the 1970s and 80s, \riscv{} is one of the few which were developed in the last decade.
Therefore, it seems like \riscv{} could be a significant architecture to be used in all sorts of devices in the near future~\cite[preface]{Patterson2017}.

\subsection{Register Layout}

\begin{wraptable}{r}{.4\textwidth}
	\centering
	\caption[Common registers of the \riscv{} architecture.]{Common registers of the \riscv{} architecture~\cite[p.~155]{Waterman2019}.}\label{tbl:riscv_regs}
	\begin{tabularx}{\linewidth}{l|L}
		\rowcolor{gray!10} Register(s) & Purpose                           \\ \hline
		\texttt{zero}                  & hardwired zero                    \\ \hline
		\texttt{ra}                    & return address                    \\ \hline
		\texttt{sp}                    & stack pointer                     \\ \hline
		\texttt{t0}--\texttt{t6}       & temporary storage                 \\ \hline
		\texttt{fp}                    & frame Pointer                     \\ \hline
		\texttt{a0}, \texttt{a1}       & function arguments, return values \\ \hline
		\texttt{a2}--\texttt{a7}       & function arguments                \\ \hline
		\texttt{s1}--\texttt{s11}      & saved register                    \\ \hline
		\texttt{fa0}, \texttt{fa1}     & float arguments, return values    \\ \hline
		\texttt{fa2}--\texttt{fa7}     & float arguments                   \\ \hline
		\texttt{fs0}--\texttt{fs11}    & float saved registers             \\ \hline
		\texttt{ft0}--\texttt{ft11}    & float temporaries                 \\
	\end{tabularx}
\end{wraptable}

Compared to popular CISC architectures, RISC architectures typically have a large count of registers~\cite[Chapter~2]{Dandamudi2005}.
For instance, while the 32-bit variant of the x86 architecture has 8 registers,
the popular RISC architecture \emph{ARM-32} provides twice that amount, meaning 16 registers.
However, a \riscv{} CPU includes 32 registers, which is drastically more than the aforementioned architectures.
Moreover, these 32 registers only include the general purpose ones.
Just for floating-point numbers, the ISA provides another 32 registers.
Due to this difference, a register allocator targeting the \riscv{} architecture could be more aggressive compared to one targeting a CISC architecture~\cite[p.~10]{Patterson2017}.

The Table~\ref{tbl:riscv_regs} shows most of the registers provided by the \riscv{} architecture.
For this table, the official ABI names of the registers have been used.
The special \qVerb{zero} register always holds a constant `0'
Unlike other registers, it is read-only, meaning that it can never be overwritten.
The \qVerb{ra} register saves the \emph{return address} of a procedure.
If a return instruction is used, the value in \qVerb{ra} is used as the address to jump back to.
The \qVerb{sp} and \qVerb{fp} registers are used for managing stack memory.
The registers \qVerb{a0} and \qVerb{a1} both serve as call arguments and return values of functions.
The remaining `\Verb{a}$n$' registers (\qVerb{a2}--\qVerb{a7}) should be primarily used as function call arguments.
How functions are called using registers will be explained in Section~\ref{sec:riscv_calling_conv}.
The next row contains the \emph{saved} registers \qVerb{s1}-\qVerb{s11}.
These registers are meant to be preserved across function calls, meaning a called function must not overwrite them.
What the previously explained registers have in common is that they all hold integer values.
Depending on the used \riscv{} extensions, all registers, including floating-point registers, either hold 32 or 64 bits of information.
The float registers are able to hold floating-point numbers according to the \emph{IEEE 754--2008} standard~\cite[Chapter~11]{Waterman2019}.
Just like their integer counterparts, the floating-point registers \qVerb{fa0} and \qVerb{fa1} are used as function call arguments and as return values.
However, the other `\Verb{fa}$n$' registers (\qVerb{fa2}--\qVerb{fa7}) are meant to be used as float function arguments.
Just like the `\Verb{s}$n$' registers, the \qVerb{fs0}--\qVerb{fs11} registers are usually preserved across function calls.
Lastly, the \qVerb{ft0}--\qVerb{ft11} registers can be used as temporary registers for floating-point numbers.
It is apparent that the floating-point registers are provisioned very similarly to the integer registers.
Therefore, a compiler targeting the architecture can utilize roughly the same principles,
regardless of the data-type~\cite[pp.~18f,p.~34]{Patterson2017},~\cite[p.~155]{Waterman2019}.

Now, it has become apparent that \riscv{} includes many registers grouped into semantic categories.
Every category is meant to be used in the specified manner, however, these groups are mostly only a suggestion of how each register should be used.

\subsection{Memory Access Through the Stack}\label{sec:riscv_stack}
%
% \begin{wrapfigure}{L}{0.39\textwidth}
% 	\hspace{-3.25cm}
% 	\begin{tikzpicture}[scale=.9]
% 		\small
% 		% TODO: also use longer arrow in top `fp_main`?
% 		\stackTopFixed{...} \cellcom{\scriptsize 24(sp\textsubscript{main})} \cellptr{\scriptsize \tt fp\,$_\text{main}$}
% 		\startframe
% 		\cell{fp} \cellcom{\scriptsize 16(sp\textsubscript{main})}
% 		\cell{ra} \cellcom{\scriptsize 8(sp\textsubscript{main})}
% 		\cell{a: int} \cellcom{\scriptsize -24(fp\textsubscript{main})} \cellptrA{\scriptsize \texttt{sp\,$_\text{main}$}}
% 		\cell{b: char} \cellcom{\scriptsize -25(fp\textsubscript{main})} \cellptrA{\scriptsize \texttt{fp\,$_\text{foo}$}}
% 		\finishframe{\tt main}
% 		\startframe
% 		\cell{fp} \cellcom{\scriptsize 8(sp\textsubscript{foo})}
% 		\cell{ra} \cellcom{\scriptsize 0(sp\textsubscript{foo})} \cellptrA{\scriptsize \texttt{sp\,$_\text{foo}$}}
% 		\finishframe{\tt foo}
% 		% TODO: uncomment the line below?
% 		%\stackbottom
% 	\end{tikzpicture}
% 	\caption{Example stack layout in \riscv{}.}\label{fig:riscv_basic_stack}
% \end{wrapfigure}

\begin{wrapfigure}{O}{0.39\textwidth}
	\hspace{-1.75cm}
	\begin{tikzpicture}[xscale=0.9, yscale=0.7]
		\footnotesize

		% manually set counter to allow stack frame including the start dots
		\setcounter{cellnb}{0}
		\startframe
		\addtocounter{cellnb}{-1}

		% copied code from `\stacktop{}` to not reset counter to in turn allow `\startframe` above this
		\draw[padding] (0,\value{cellnb})
		+(-2,.5) -- +(-2,-.5) -- +(2,-.5) -- +(2,.5);
		\draw (0,\value{cellnb}) node{...};

		\cell{$n$\textsuperscript{th} stack argument} \cellcom{\texttt{$8n$(fp)}}
		\cell[padding]{...}
		% custom draw instead of `\cellcom` for yshift
		\draw (2.4,\value{cellnb}) node[anchor=west, yshift=3.5pt] {\vdots};
		\cell{\nth{1} stack argument} \cellcom{\texttt{0(fp)}}
		\finishframe{previous}

		\cell{previous \qVerb{fp} value} \cellcom{\texttt{-8(fp)}}
		\cell{return address} \cellcom{\texttt{-16(fp)}}

		\startframe
		\padding{3}{\makecell{unspecified\\variable size}} \cellcom{\texttt{0(sp)}}
		% custom draws instead of `\cellcom` for yshift and padding cell offset
		\draw (2.4,\value{cellnb}+1) node[anchor=west, yshift=3.5pt] {\vdots};
		\draw (2.4,\value{cellnb}+2) node[anchor=west] {\texttt{-24(fp)}};
		\stackbottom[padding]
		\finishframe{current}
	\end{tikzpicture}
	\caption[Stack layout of the \riscv{} architecture.]{Stack layout of the \riscv{} architecture\TODO{cite}.}\label{fig:riscv_stack}
\end{wrapfigure}


Figure~\ref{fig:riscv_stack} shows the stack layout used by \riscv{}.
Stack frames are enclosed by the \qVerb{fp} and \qVerb{sp} registers.
Here, \qVerb{sp} always points to the lowest address inside of the current stack frame while
\qVerb{fp} points to 16 bytes\footnote{Assuming the \TODO{RV64I} extension is used.} above the top of the current frame.
The available space for functions therefore ranges from \qVerb{-24(fp)} to \qVerb{0(sp)}.
It is used for storing variables, following the alignment rules that were explained in Section~\ref{sec:alignment}.
In the space between \qVerb{0(fp)} and \qVerb{-24(fp)}, the frame pointer of the previous stack frame and the return address are saved at the positions \qVerb{-8(fp)} and \qVerb{-16(fp)}, respectively.
If stack arguments were present, they would be placed upwards of \qVerb{fp}.
Each stack argument \emph{always} uses eight bytes of memory, regardless of the actual size of its content.
Thus, the $n$\textsuperscript{th} stack argument would be placed at the position $8n$\texttt{(fp)}.
To keep track of variable locations on the stack, the compiler maps a variable's name to a memory location.
To be precise, the compiler contains a \qVerb{HashMap} which associates a variable's name with its \qVerb{fp} offset.
When the variable is referenced at a later point, the compiler performs a simple lookup of the variable's memory address.

\subsection{Calling Convention}\label{sec:riscv_calling_conv}

Just like previously explained, most architectures provide a calling convention which dictates how low-level function calls should be managed.
For most architectures, the calling convention is part of the ISA's official specification.
In the case of \riscv{}, the calling convention consists of four main steps and is specified in a separate document~\cite{RiscvABI2022}.

The first step of calling a function involves placing the arguments in a place where the function can access them.
For \riscv{}, this involves placing the arguments into certain registers.
Like described in Table~\ref{tbl:riscv_regs}, only some registers are used for call arguments.
For integer arguments, the first eight arguments are placed in the registers \qVerb{a0}--\qVerb{a7}
For instance, the first two arguments of the rush function call
\qVerb{foo(40, 2, 3.14)} would be placed in the registers \qVerb{a0} and \qVerb{a1}, respectively.
However, the third argument is a floating-point number and can therefore not be placed inside an integer register.
Instead, the first floating-point argument register \qVerb{fa0} is used.
In this case, all arguments can be held in registers and spilling would not be required.

In case the function accepted nine or more integer arguments,
all further integer arguments starting with the ninth one would have to be spilled onto the stack.
Here, the successive registers \qVerb{a0}--\qVerb{a7} would contain the first eight integer arguments of the called function.
However, the argument at position nine is spilled onto the stack since there are no registers left which could contain the additional argument~\cite[p.~8]{RiscvABI2022}.

In the second step, the underlying procedure call is made using a specialized instruction.
In \riscv{} assembly, one typically uses the \qVerb{call} \emph{pseudoinstruction}\footnote{A macro generating one or more instructions from one pseudoinstruction. This way, the actual count of ISA instructions remains low while convenience features can be used in assembly~\cite[p.~68]{Dandamudi2005}.}.
The instruction uses the name of its target label as its operand, resulting in labels being callable, just like functions.
Internally, the instruction first saves the address of the following instruction in the \qVerb{ra} register, and then performs an unconditional jump~\cite[p.~22]{Patterson2017}.

The third step takes place in the function's prologue.
Here, the previous frame pointer and return address are saved on the stack,
and space for storing local variables is allocated by decrementing the stack pointer.
Following the prologue, the function's body is executed.
After it has also been evaluated, the epilogue restores the changes made by the prologue.
The previous values for both the frame pointer and the return address registers are taken from the stack,
and the stack pointer is incremented back to its original value.
The \qVerb{ret} instruction, which jumps to the address stored in \qVerb{ra}, is finally used to return control back to the caller.

In case a function returns a value, it must be mad accessible to the caller.
For integer types, the first return value of a function is placed in the register \qVerb{a0}
while floating-point numbers are placed in the register \qVerb{fa0}.
This way, the caller code can obtain a function's return value by accessing the \qVerb{a0} and \qVerb{fa0}
registers respectively. If a function does not return a value, these steps are just omitted.
It is to be mentioned that char and bool values are also placed inside the \qVerb{a0} register since these types are internally represented by integers.

\subsection{The Core Library}

As outlined in the section about the linker on page~\pageref{sec:linker},
a program might use functionality provided by external libraries.
In case of the rush \riscv{} compiler, external functions are used for character-arithmetic,
the mathematical power operator, and the system \emph{exit} call.
Character-arithmetic requires external functionality since the bounds of the ASCII range should be regarded while performing operations.
For instance, in rush, calculating \qVerb{'a'+'a'} results in `66' because `194' ($97 + 97$) is larger than the maximum allowed value `127'.
If the result is outside the valid range $\left[0; 127\right]$, only the least significant seven bits are considered.
This way, the ASCII range is always valid.

Since these concepts must introduce additional logic, the compiler should not be emitted their instructions every time they are used.
In that case, the repeated emission of redundant instructions would result in enlarged and unnecessary complex output code.
In order to mitigate these issues, the compiler simply inserts call-instructions referencing the appropriate external function.
External functions are called just like any other function; however, their definition is not found in the same assembly file.
As described previously, resolving these external calls is later handled by the linker.
This target-specific libary code is later refered to by the term \emph{corelib}.

For instance, a function for mathematical power operations is implemented in the corelib.
Therefore, the compiler can emit a procedure call to this method every time rush's \qVerb{**} operator is used in the source program.
For this project, the entire corelib is written in \riscv{} assembly.
However, it is also reasonable to implement a corelib using a high-level language like C.
Since the corelib's functions are specified in separate files, they are packaged into an \emph{archive file} which is later used by the linker.
The assembly code in Listing~\ref{lst:riscv_exit_corelib} shows the implementation of the \qVerb{exit} subroutine in the \riscv{} corelib.
The task of this subroutine is to invoke a specific functionality of the Linux kernel by performing a \emph{system call}.

\Lirsting[float=H, ranges={8-12}, caption={The assembly implementation of the \qVerb{exit} subroutine.}, label={lst:riscv_exit_corelib}]{deps/rush/crates/rush-compiler-risc-v/corelib/src/exit.s}

A \emph{system call} (often abbreviated to \emph{syscall}) is an invocation of a function of operating system's kernel.
In Linux, more than 90 percent of the available system calls are implemented on all architectures~\cite[p.~3]{Love2013}.
One common system call is \qVerb{exit}.
It terminates the current process and performs various cleanup steps.
Its only parameter is the \emph{exit code} which can be checked by the shell or other programs~\cite[p.~148]{Love2013}.
In \riscv{} Linux, the syscall id of \qVerb{exit} is `93`~\cite{Torvalds1991}.
In line~8 of Listing~\ref{lst:riscv_exit_corelib}, the \qVerb{exit} label is declared as global using the \qVerb{.global} directive.
Next, the \qVerb{exit} label is declared in line~10.
In line~11, the \qVerb{li} instruction is used in order to load `93` into the register \qVerb{a7}.
On \riscv{} Linux systems, the content of the \qVerb{a7} register specifies the type of syscall to be performed.
In line~12, the \qVerb{ecall} instruction is then used to perform the underlying syscall~\cite[p.~23]{Patterson2017}

\subsection{\riscv{} Assembly}

\Lirsting[wrap=o, fancyvrb={numbers=\OuterEdge}, wrap width=0.35\textwidth, caption={Example rush program containing two functions.}, label={lst:riscv_simple2}]{listings/riscv_simple.rush}

The Listing~\ref{lst:riscv_simple2} shows a rush program containing two functions and a global variable.
In line~1 of the rush program, the mutable global variable \qVerb{m} is defined with an initial value of `42'.
In line~4, in the \qVerb{main} function, \qVerb{m} is incremented by `1'.
Next, in line~5, the \qVerb{foo} function is called using \qVerb{m} as the only call argument.
In line~6, a \qVerb{return} statement is used to terminate the \qVerb{main} function explicitly.
The body of the \qVerb{foo} function only contains a call to the \qVerb{exit} function and therefore causes the program to exit with the code stored in \qVerb{n}.
When executed, the exit code of the displayed program will be `43'.
The code in Listing~\ref{lst:riscv_simple_asm} shows the output assembly generated from this program by the rush \riscv{} compiler\footnote{Generated using rush (Git commit \rushCommit{}).}.
The assembler code of the \qVerb{foo} function is intentionally omitted.

In line~1, the \qVerb{.global} assembler directive is used to declare the global symbol \qVerb{_start}~\cite[p.~36]{Patterson2017}.
On most architectures, the \qVerb{_start} label indicates a program's entry point, marking the first instruction to be executed~\cite[p.~19]{Zhirkov2017-wk}.
In line~6, the \qVerb{call} instruction is used to call the \qVerb{main..main} function.
Here, the already familiar \qVerb{main} function is prepended by the prefix \qVerb{main..}.
Since this rush compiler implements name mangling\footnote{Compilers often \emph{mangle} names in order to guarantee a unique name for every function~\cite[pp.~119-120]{Levine2000}.},
every function defined in a rush program will contain this prefix.

\Lirsting[wrap=o, fancyvrb={numbers=\OuterEdge}, wrap width=0.4\textwidth, caption={Compiler output from the rush program in Listing~\ref{lst:riscv_simple2}.}, label={lst:riscv_simple_asm}, ranges={1-31, -4 53-56}]{listings/generated/riscv_simple.s}

In line~7, the \qVerb{li} (\enquote{\textbf{l}oad \textbf{i}mmediate}) instruction is used to load the constant integer `0' into the register \qVerb{a0}~\cite[Reference Card]{Patterson2017}.
As explained in the previous section, the register \qVerb{a0} is used for the first integer call argument.
In line~8, the \qVerb{exit} function from rush's corelib is called, using `0' stored in \qVerb{a0} as the exit code.
Therefore, the two instructions in the lines~7--8 are responsible for terminating the program with the exit code `0'.
They are always inserted at the end of the \qVerb{_start} label in order to terminate the program appropriately in case the rush code does not call \qVerb{exit} on its own\footnote{In order to prevent runtime errors, programs should always be exited properly.}.

Due to the function call in line~6, the \qVerb{main..main} label in line~10 should now be considered.
In line~11, the first line of the \qVerb{main} function, a comment indicates the beginning of the function's prologue.
The \qVerb{addi} (\enquote{\textbf{a}dd \textbf{i}mmediate}) instruction in line~12 adds `$-16$' to the value stored in \qVerb{sp}, thus allocating memory.
Here, an addition instruction is used even though subtraction is required.
In \riscv{}, the \qVerb{addi} instruction's operands are one destination register, one source register and one immediate value.
Since this immediate value can be negative, an additional instruction for immediate subtraction would be redundant~\cite[Reference Card]{Patterson2017}.
In this case, 16 bytes are allocated since two 8-byte values are stored on the stack in the lines 13--14.

The comment in line~17 indicates the start of the function's body.
First, the previously explained \qVerb{li} (\enquote{\textbf{l}oad \textbf{i}mmediate}) instruction in line~18 places a constant `1' in the register \qVerb{a0}.
Next, the \qVerb{ld} (\enquote{\textbf{l}oad \textbf{d}oubleword}\footnote{Here, \enquote{doubleword} indicates that 64 bits of data shall be loaded.}) instruction in line 19 is used in order to load the value of the global variable \qVerb{m} into the register \qVerb{a1}~\cite[Reference Card]{Patterson2017}.
Global variables, like \qVerb{m}, are saved under the \qVerb{.rodata} or the \qVerb{.data} section, depending on their mutability.
Since \qVerb{m} is declared as mutable, the compiler saves it under the \qVerb{.rodata} section.
The start of the \qVerb{.rodata} section is marked by the \qVerb{.section} assembler directive found in line 53.
Here, a label called \qVerb{m} is defined.
In this label, the \qVerb{.dword} (\enquote{\textbf{d}ouble \textbf{word}}) directive is used to define the global initializer value of the variable.
This directive stores 64 bits of data~\cite[p.~39]{Patterson2017}.
The initializer value of the global variable is `42' and is represented as \qVerb{0x2a} using hexadecimal in the assembly code.
In line~56, the trailing comment shows the decimal representation of the number.

At this point, the register \qVerb{a0} contains `1', while \qVerb{a1} contains `42'.
In line~20, the \qVerb{add} instruction is used to save the sum of \qVerb{a0} and \qVerb{a1} in the register \qVerb{a2}.
Next, in line~21, the \qVerb{sd} (\enquote{\textbf{s}tore \textbf{d}oubleword}) instruction saves the value of the register \qVerb{a2} at the memory location of the global variable \qVerb{m},
meaning that \qVerb{m} is updated to reflect its new value `43'.
It now becomes apparent that these instructions are responsible for the add-assign expression in line 4 of the rush program.
Another interesting observation is that the last operand of the \qVerb{sd} instruction specifies the temporary register \qVerb{t6}.
The instruction uses this register for saving temporary data during the process of saving data in \qVerb{m}~\cite[Reference Card]{Patterson2017}.

The final instruction of the \qVerb{main} function's body is the \qVerb{j} (\enquote{\textbf{j}ump}) instruction in line~24.
This instruction will cause the CPU to jump to the address of the specified label,
here \qVerb{epilogue_0} would be targeted~\cite[p.~17]{Patterson2017}.
The rush compiler emits the \qVerb{call} and \qVerb{ret} instructions for jumps between functions,
while the \qVerb{j} instruction is used for jumps between blocks of the current function.
In the lines 27--31, inside the epilogue, the aforementioned task of restoring register values and returning are performed.

\subsection{Supporting Pointers}

\begin{minipage}{.34\textwidth}
	\center
	\Lirsting[float=H, fancyvrb={frame=none}, caption={Example rush program containing a pointer.}, label={lst:rush_simple_pointer}]{listings/rush_simple_pointer.rush}
\end{minipage}%
\hspace{3cm}
\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[float=H, fancyvrb={frame=none}, ranges={10-10,18-24}, caption={\riscv{} assembly output generated from Listing~\ref{lst:rush_simple_pointer}.}, label={lst:rush_simple_pointer_asm}]{listings/generated/riscv_rush_simple_pointer.s}
	\vspace{.1cm}
\end{minipage}

Listing~\ref{lst:rush_simple_pointer} shows a rush program in which a variable is referenced to create a pointer which is then dereferenced.
In line 3, the previously created variable \qVerb{a} is referenced in order to create the variable \qVerb{to_a} which saves a pointer to \qVerb{a}.
Listing~\ref{lst:rush_simple_pointer_asm} includes the relevant part of the compiler output which represents this rush program\footnote{Generated using rush (Git commit \rushCommit{}).}.
In line~18, the integer value `42' is placed in the register \qVerb{a0}.
Next, \qVerb{a0} is saved on the stack at \qVerb{-24(fp)} using the \qVerb{sd} instruction.
As the comment suggests, the instruction in line~20 is used in order to reference \qVerb{a}.
It does so by subtracting `24' from the value stored in the \qVerb{fp} register.
This results in the absolute address of \qVerb{a} at runtime because the syntax \qVerb{-24(fp)} describes the address stored in \qVerb{fp} offset by `-24'
The calculation has to be performed at runtime since the value of \qVerb{fp} cannot be determined at compile time.
In line~21, the \qVerb{a0} register, which contains this memory address, is also saved on the stack.
Therefore, the \qVerb{a} variable is saved at \qVerb{-24(fp)} and \qVerb{to_a} is saved at \qVerb{-32(fp)}.

In order to access the value of \qVerb{a}, \qVerb{to_a} is dereferenced in line~4 of the rush program.
For this, the memory address stored in the variable \qVerb{to_a} first needs to be loaded from the stack,
which is accomplished by the \qVerb{ld} instruction in line~22.
Next, in line~23, another \qVerb{ld} instruction is used in order to load the value of the variable at the address stored in \qVerb{a0}.
Here, \qVerb{0(a0)} is used instead of `$n$\Verb{(fp)}' since the address stored in \qVerb{a0} offset by `0' shall be used.
Because \qVerb{a0} contains the memory address of the \qVerb{a} variable, the instruction loads `42' into the \qVerb{a0} register.

\subsection{Implementation}

Just like the other compilers presented in this paper, this one also traverses the annotated AST using post-order.
Unlike the LLVM or WASM compilers, this one emits \riscv{} assembly files which can then be assembled by an assembler supporting \riscv{}.

\subsubsection{Struct Fields}

Before any complex code samples can be considered, important struct fields of the compiler need to be explained.
The Rust code in Listing~\ref{lst:riscv_compiler_attr} shows the \qVerb{Compiler} struct definition containing those fields.

\Lirsting[ranges={11-11,15-15,19-34}, caption={Fields of the \riscv{} \qVerb{Compiler} struct.}, label={lst:riscv_compiler_attr}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

The \qVerb{blocks} field in line~15 holds a vector containing values of the type \qVerb{Block}.
That type provides an abstraction for representing a label followed by instructions.
The Listing~\ref{lst:riscv_instruction_enum} shows parts of the Rust code which declares the \qVerb{Instruction} enumeration.

\Lirsting[ranges={57-57,69-71,110-110}, caption={The \qVerb{Instruction} enum in the \riscv{} compiler.}, label={lst:riscv_instruction_enum}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/instruction.rs}

Although the listing only shows a few of the implemented instructions,
this enumeration contains all instructions which the compiler might need at a later point.
Depending on the type of instruction, the corresponding variant includes fields which define its operands.
For instance, the \qVerb{Li} variant in line~70 represents the \qVerb{li} instruction in assembly.
Since this instruction loads the integer value specified by the second operand into the register specified by the first operand,
it contains a field for a value of the type \qVerb{IntRegister} and a field for a 64-bit signed integer.
Listing~\ref{lst:riscv_intregister_enum} shows parts of the \qVerb{IntRegister} enumeration.
It specifies all registers which \riscv{} provides, assuming that the required extensions are considered.
An equivalent enumeration called \qVerb{FloatRegister} is defined for the float registers of this \riscv{} configuration.

\Lirsting[ranges={98-98,130-132,136-136}, caption={The \qVerb{IntRegister} enumeration in the \riscv{} compiler.}, label={lst:riscv_intregister_enum}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/register.rs}

The \qVerb{curr_block} field, defined in line~19 of Listing~\ref{lst:riscv_compiler_attr},
saves the index of the block which is currently being inserted to.
Next, the \qVerb{data_section} and \qVerb{rodata_section} fields are declared in the lines~21--22.
They represent the ELF sections \qVerb{.data} and \qVerb{.rodata}, respectively.
Here, each vector might contain global variables, which are represented by the type \qVerb{DataObj}.
Each \qVerb{DataObj} consists of a label, saved as a string, and the initial data.
The data itself is represented by another enumeration holding either a 64-bit float, a 64-bit integer, or an 8-bit integer.

In line~25, the \qVerb{curr_fn} field is declared.
It saves a value of the type \qVerb{Function}, which contains a counter for the bytes of stack space allocated by the current function.
Furthermore, it contains the label of the current function's epilogue block.
The former is incremented every time a variable declaration is encountered.
This is required in order to allocate the correct amount of stack memory during a function's prologue.

Just like the other compilers, this one also features a \qVerb{loops} field which saves important labels of the current loop being compiled.
It stores a vector of \qVerb{Loop} structs in order to support nested loops.
Each \qVerb{Loop} struct saves the label of the loop's head and the label of the block which follows after the loop's body.

The \qVerb{scopes} field stores a list of nested scopes, the last element being the current one.
Each scope is represented by a \qVerb{HashMap} associating variable names with important metadata.
This metadata includes the variable's type and its memory offset from \qVerb{fp}.
\TODO{is this already improved?}
However, these \qVerb{HashMaps} are not used for saving global variables.
Instead, the \qVerb{globals} field in line~31 is used.
Just like the HashMaps in the \qVerb{scopes} field, this map also associates a variable's name to a value of the type \qVerb{Variable}.
This time however, each variable contains the data label under which the global variable was declared.
Lastly, the \qVerb{used_registers} field is declared in line~33.
It plays a vital role in the compiler's register allocation algorithm.

\subsubsection{Data Flow and Register Allocation}

The LLVM compiler represents runtime values by passing virtual registers, represented by Inkwell's \qVerb{BasicValueEnum}, internally.
Similarly, this compiler also passes registers in order to represent the data flow of the program.
Unlike in LLVM, there is only a finite amount of registers available.
Therefore, this compiler also manages register allocation so that programs can be represented using this limited number of registers.
In order to understand the implementation, Listing~\ref{lst:rush_riscv_simple_sum} and Listing~\ref{lst:rush_riscv_simple_sum} are to be considered.
The former contains a rush program which adds two integer variables together and uses the result as its exit code
The latter shows a part of the assembly output representing the logic in the \qVerb{main} function.

\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[caption={A rush program calculating the sum of two integers.}, label={lst:rush_riscv_simple_sum}, float=H]{listings/simple_add.rush}
\end{minipage}%
\hfill%
\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[ranges={18-25},caption={Assembly output of the rush program in Listing~\ref{lst:rush_riscv_simple_sum}.}, label={lst:asm_riscv_simple_sum}, float=H]{listings/generated/rush_simple_add.s}
	\vspace{.1cm}
\end{minipage}

In the lines~2--3 of the rush program, the integer variables \qVerb{a} and \qVerb{b} are declared.
In line~4, the \qVerb{exit} function is invoked, using the sum of these variables as the call argument.
In line~22 of the assembly output, the runtime value of the variable \qVerb{a} is loaded into the register \qVerb{a0}.
Next, the same operation is performed for \qVerb{b} .
However, this time, the instruction writes its result into the \qVerb{a1} register instead of the \qVerb{a0} register.
This is because the previously loaded value in \qVerb{a0} should not be overwritten.
Unlike the register allocation algorithm of a production-ready compiler, like LLVM,
this one only aims to use registers without causing conflicts.
All variables are saved on the stack in order to keep as most registers as possible free for temporary use in calculations and operations like this one.
Since this algorithm only performs rudimentary register allocation, its implementation is also significantly simpler.

The core principle of the register allocator is that each time a register is required,
a responsible helper method returns the next free one to be used.
The helper method for managing int registers is called \qVerb{get_int_reg}.
The Rust code in Listing~\ref{lst:riscv_get_int_reg} shows this method.%
%
\Lirsting[ranges={175-186}, float=h, label={lst:riscv_get_int_reg}, caption={The \qVerb{get_int_reg} method of the \riscv{} rush compiler.}]{deps/rush/crates/rush-compiler-risc-v/src/utils.rs}%
%
It returns the first available register from the register pool that containing either int or float registers.
Each register pool contains all possible registers for either integer or floating-point numbers.
In line~175, in the method's signature one can see that the it returns a value of type \qVerb{IntRegister}.
The for-loop in line~176 is used to iterate over the entire \qVerb{INT_REGISTERS} array.
This array represents the pool containing integer registers.
For each register in that pool, the if-expression in the lines~177--180 checks whether the current register \qVerb{reg} is contained in the \qVerb{used_registers} vector.
If this is not the case, the current register is still unused and can therefore be returned for usage.
Since the \qVerb{return} statement causes the function to return immediate,
the loop only iterates until a free register has been found.

Due to the fact that the register allocator only uses as few registers as required,
the compiler should not run out of registers,
therefore making the \qVerb{panic!} macro call in line~185 unreachable.
However, one can see that this method does not mark the returned register as used.
This is because doing so is only required in some places, where overwriting a register would introduce a bug in the output program.
Therefore, if this method was called repeatedly, it would always yield the same register.
In order to mark a register as used, it is appended to the \qVerb{used_registers} vector.
For this, a helper method called \qVerb{use_reg}, which only performs this one operation, is implemented.
When a register is no longer used, and can be overwritten again, it must be removed from the \qVerb{used_registers} vector.
For this, another simple helper method, called \qVerb{release_reg}, is implemented.

\begin{figure}
	\centering
	\begin{tikzpicture}
		\node(stack)[stack=6, rectangle split part align=center,
			rectangle split part fill={gray!20, gray!20, none, none, none, none},
			text width=10ex, text centered, inner xsep=0]{
			\shortstack{used\\\\\texttt{a0}}
			\nodepart{two}{\shortstack{used\\\\\texttt{a1}}}
			\nodepart{three}{\shortstack{unused\\\\\texttt{a2}}}
			\nodepart{four}{\ldots}
			\nodepart{five}{\shortstack{unused\\\\\texttt{a7}}}
			\nodepart{six}{\ldots}
		};
		\node(ff)[below of=stack, yshift=-.5cm] {\scriptsize first free cell};
		\draw[arrow, shorten >= 4pt](ff) -- (stack.three south);
	\end{tikzpicture}
	\caption{Simplified integer register pool of the \riscv{} rush compiler.}\label{fig:riscv_iregister_pool}
\end{figure}

Figure~\ref{fig:riscv_iregister_pool} shows an abstract representation of the compiler's integer register pool.
Only the first section of the pool, which contains the \qVerb{an} registers, can be seen.
The gray cells specify registers that are currently in use by the compiler.
The arrow points to \qVerb{a2}, which is the first free register, meaning the one which follows \qVerb{a1}, the last used register.
Therefore, if the \qVerb{get_int_reg} method was called when the state of the registers is equivalent to the one displayed in Figure~\ref{fig:riscv_iregister_pool}, it would return the register \qVerb{a2}.

\Lirsting[float=h, ranges={596-602,662-663}, caption={Parts of the \qVerb{expression} method in the \riscv{} rush compiler.}, label={lst:riscv_expression}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

In order to understand how expressions are compiled, Listing~\ref{lst:riscv_expression}, which shows parts of the \qVerb{expression} method, is to be considered.
This method is responsible for compiling expressions.
As the method's signature suggests, it takes an analyzed expression and returns an \qVerb{Option<Register>},
which is \qVerb{None} if the expression results in the \qVerb{!} or \qVerb{()} types.
Otherwise, the method returns the register in which the result of its computation will be contained at runtime.
The code in the lines~598--602 is executed if the expression is an integer literal.
First, a target register is retrieved by calling the previously shown \qVerb{get_int_reg} method.
Now, the \qVerb{dest_reg} variable holds the register which will contain the result of the expression.
Next, an \qVerb{li} instruction is inserted which loads the integer contained in the variable \qVerb{value} into the register specified by \qVerb{dest_reg}.
Finally, this register is then returned.
For more complex expressions, the specified methods are called, just like in the other compilers.

However, the question of \emph{when} the compiler marks certain registers as used still remains.
For this, the compilation of the rush expression \qVerb{n+m} is to be considered.
The Rust code in Listing~\ref{lst:riscv_infix_expr} shows a part of the \qVerb{infix_expr} method of the rush compiler.%
%
\Lirsting[float=h, ranges={755-755,791-791,841-858}, caption={Parts of the \qVerb{infix_expr} method in the \riscv{} rush compiler.}, label={lst:riscv_infix_expr}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}
%
It consumes an annotated tree-node representing an analyzed infix-expression.
In line~853, the left-hand side expression is compiled, and its result register is saved in the variable \qVerb{lhs_reg}.
Next, in line~854, the previously discussed \qVerb{use_reg} method is used in order to mark the register specified by \qVerb{lhs_reg} as used.
The second argument to the method specifies the size of the data which the register holds, 64 bits for \qVerb{int}, 8 bits for \qVerb{char} and \qVerb{bool}.
This information is also saved in the \qVerb{used_registers} vector and is accessed in case used registers need to be spilled.

In line~856, the right-hand side expression is compiled and its result register is saved in the variable \qVerb{rhs_reg}.
After this, \qVerb{lhs_reg} is marked as unused again.
Finally, in line~861, the \qVerb{infix_helper} method is called in order to insert the instructions for the actual calculation.
As discussed previously, calling the \qVerb{get_int_reg} or \qVerb{get_float_reg} methods
repeatedly, without marking registers as used, results in same registers every time.
In this scenario, this would create an issue since both the left-hand side and the right-hand side expressions would use the identical register.
In order to mitigate this issue, the register of the left-hand side is marked as used before compilation of the right-hand side.
Now, the right-hand side will respect that the register returned by the left-hand side is currently in use and will instead use the next free one.

Next, the implementation of the \qVerb{infix_helper} helper method shall be considered.
This method exists because translation of the underlying mathematical or logical operation
is required during compilation of both infix-expressions and certain assign-expressions, \qVerb{a+=1} for instance.
Listing~\ref{lst:riscv_infix_helper} shows parts of this method.%
%
\Lirsting[
	float=h,
	ranges={861-861,864-871,977-980,990-991},
	caption={Parts of the \qVerb{infix_helper} method of the \riscv{} rush compiler.},
	label={lst:riscv_infix_helper}
]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}
%
It takes the registers of the left- and right-hand side, the operator, and a type.
As the registers do not specify one concrete type, it has to be provided additionally.
The analyzer guarantees equal types on both sides, hence only one type parameter is needed.
In the lines~874--875, an integer and a floating-point destination register are created, even though only one of them is used later .
However, both are defined beforehand in order to avoid code duplication.
In the lines~878--881, the code responsible for inserting an integer addition instruction can be seen.
For this, the \qVerb{insert} method is used.
It inserts a new instruction into the current block.
Here, the \qVerb{add} instruction is used with the integer destination register specified in \qVerb{dest_regi} and the left- and right-hand side registers as operands.
Since the \qVerb{add} instruction demands it, the operand registers are converted to integer registers via the \qVerb{into} method.
In the lines~987--990, the code for inserting a float subtraction instruction can be seen.
Since floating-point operations require different instructions from the ones used for integers, the additional type information is passed to this method.
Here, the \qVerb{fsub} instruction is used for subtraction.
In this case, the variable \qVerb{dest_regf} is used as the first operand because the resulting value is a float,
and these \qVerb{into} calls convert the registers into float ones.

\subsubsection{Functions}

However, before the infix-expression in Listing~\ref{lst:rush_riscv_simple_sum} on page~\ref{lst:rush_riscv_simple_sum} is compiled, the compiler iteretes over the functions of the program.
In this case, only the \qVerb{main} function is present.
Listing~\ref{lst:riscv_define_main_fn} shows the \qVerb{define_main_fn} method of the rush \riscv{} compiler.%
%
\Lirsting[
	float=h,
	ranges={123-156},
	caption={The \qVerb{define_main_fn} method of the \riscv{} rush compiler.},
	label={lst:riscv_define_main_fn}
]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}
%
This method is only responsible for compilation of the \qVerb{main} function.
All other rush functions are compiled by the method \qVerb{function_definition}.
However, these two methods only mainly differ in two ways:
Firstly, the latter contains code which handles function parameters.
Secondly, the special instructions for calling to the \qVerb{main} and \qVerb{exit} functions are not required.

The method takes a block, that is, a list of statements as its input.
In the lines~124--126, the \qVerb{_start} label is created and exported so that the linker will later be able to refer to it.
Next, in the lines~128--129, a new block with the \qVerb{main..main} label is created.
As explained previously, this block represents the start of the body of the \qVerb{main} function.
Next, the line~132 inserts a \qVerb{call} instruction, which is responsible for calling the \qVerb{main} function at the start of program execution, after the \qVerb{_start} label.
In the lines~134--135, instructions for calling the \qVerb{exit} function using `0' as the exit code are inserted.
Next, in the lines~137--139, a new epilogue label is generated.
Then, the \qVerb{curr_fn} field is updated so that it contains this newly created epilogue label.
However, this label is not directly added to the \qVerb{blocks}  vector since it should appear after function body.

Next, the \qVerb{main} function's body is compiled.
For this, the current insertion position is first updated to the end of the previously created \qVerb{main..main} block by calling the method \qVerb{insert_at}.
Following that, a new variable scope is added for the function body.
Then, the function body's content is compiled by calling the \qVerb{function_body} method.
After the body's compilation, the previously added scope is removed again.

In line~148, the \qVerb{prologue} method returns the instructions for the prologue.
It is only inserted \emph{after} the function body was compiled, even though it will execute \emph{before} the function during runtime.
This is because the prologue needs to allocate a certain amount of stack space, which the compiler can only determine after the code for the body has been generated.
Next, in line~149, the insertion position is moved back to the end of the \qVerb{main..main} label.
The lines~150--151 are then responsible for prepending the generated prologue instructions to the instructions representing the function body.
This is achieved by first appending the contents of the current block to the end of the prologue instructions.
Then, the current block's instructions are overwritten with the result.
In the lines 153--154, the code responsible for inserting the trailing epilogue code can be seen.
For this, the previously created epilogue label is now appended to the \qVerb{blocks} vector, and the \qVerb{epilogue} method of the compiler is called.

\Lirsting[
	float=h,
	ranges={66-87},
	caption={The \qVerb{epilogue} method of the \riscv{} rush compiler.},
	label={lst:riscv_epilogue}
]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

Listing~\ref{lst:riscv_epilogue} shows the \qVerb{epilogue} method of the rush \riscv{} compiler.
This method generates the instructions for a function's epilogue.
First, in the lines~67--68, the insertion position of the compiler is set to the epilogue block.
The epilogue must exist in a separate label in order to be used when \qVerb{return} statements are encontered.
The instruction insertion in line~70 is responsible for an \qVerb{ld} instruction.
Here, the \qVerb{ld} instruction is used to restore the previously saved \qVerb{fp} register.
In line~75, another \qVerb{ld} instruction for restoring the \qVerb{ra} register is inserted.
In line~80, an \qVerb{addi} instruction is inserted in order to free the memory used for the function's stack frame.
Finally, a \qVerb{ret} instruction is inserted which is responsible for transferring control back to the caller.

\subsubsection{Let Statements}

In the lines~2--3 of the rush program in Listing~\ref{lst:rush_riscv_simple_sum} on page~\pageref{lst:rush_riscv_simple_sum}, let statements are used in order to save values on the stack.
The method responsible for compiling these statements is called \qVerb{let_statement}.
It saves the initializing expression on the stack and saves the resulting pointer in the current scope.
The main work is accomplished by the \qVerb{save_expr_on_stack} method.
The Rust code in Listing~\ref{lst:riscv_save_on_stack} displays parts of this method.%
%
\Lirsting[
	float=h,
	ranges={557-557,_561-567,580-587},
	caption={The \qVerb{save_expr_on_stack} method in the \riscv{} rush compiler.},
	label={lst:riscv_save_on_stack}
]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}
%
This method takes an expression in order to compile it and save the resulting value on the stack.
The method returns an \qVerb{Option<Pointer>}, where \qVerb{None} again represents the \qVerb{!} and \qVerb{()} types.
A \qVerb{Pointer} stores a relative memory address and an arbitrary base register, \qVerb{fp} in this case.

In line~569, the expression is compiled, and the resulting register is saved in the variable \qVerb{reg}.
In line~571, the \qVerb{get_offset} method is used in order to calculate the frame pointer offset of a variable.
Since types like \qVerb{char} or \qVerb{bool} require less memory compared to \qVerb{int}, the size of the expressions's data type must also be available to this method.
Now, the \qVerb{offset} variable contains the frame pointer offset at which the variable should be saved.
Since the \qVerb{get_offset} method is used every time values need to be saved on the stack,
it also increments the \qVerb{stack_allocs} variable, so that the prologue and epilogue are aware of this stack allocation.

The \qVerb{match} block in line~573 executes different code based on the register type which the expression yielded.
In the lines~586--589, the code responsible for float registers can be seen.
Here, the \qVerb{fsd} (\enquote{\textbf{f}loat \textbf{s}tore \textbf{d}ouble}) instruction is used in order to save the resulting register at the memory position relative to \qVerb{fp} which is specified in the variable \qVerb{offset}.
The code for integer registers is similar, but was omitted since it also differentiates between 8-bit and 64-bit data.
In line~592, the \qVerb{Pointer} abstraction representing the memory location of the expression is returned.
Here, it is apparent that this variant of a \qVerb{Pointer} only saves a register and an offset to this register.
In this case, \qVerb{fp} is specified as the register and the value of \qVerb{offset} is used as the offset.

\subsubsection{Function Calls and Returns}

For compiling call-expressions, also the ones of builtin functions, the compiler uses the \qVerb{call_expr} method.
The Rust code in Listing~\ref{lst:riscv_call_expr} shows the first part of this method.%
%
\Lirsting[
	float=h,
	ranges={92-113,189-189},
	fancyvrb={lastline=23},
	caption={The \qVerb{call_expr} method in the \riscv{} rush compiler.},
	label={lst:riscv_call_expr}
]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}
%
Due to the aforementioned low-level calling conventions,
its implementation has proven to be very complex and demanding.
The part of code shown here is only preparing the compilation of the function call.
The method consumes an analyzed call-expression and optionally returns a register representing the call return value.
For instance, if the \qVerb{exit} function was called, this method would return no register as the \qVerb{exit} function results in the \qVerb{!} type.

In the lines~93--99, all registers which are used at the time of the function call are spilled and then marked as unused.
This is required since the register allocator of this compiler is so simple that it only considers one function at the time.
In production-ready compiler systems, a register allocation algorithm could also work interprocedurally.
It becomes apparent that saving \emph{all} used registers does not produce very efficient output code.
However, throughout the extensive testing conducted on the rush backends, this approach has presented itself as simple and reliable\footnote{For each new commit, \rushCountTests integration tests are conducted on every backend}.
In the lines~93--99, the register spilling is performed by iterating over the currently used registers and calling the \qVerb{spill_reg} method for each register.
That method is structured very similarly to the aforementioned \qVerb{save_expr_on_stack} method.
After the register spilling, the contents of the \qVerb{used_registers} vector are moved into the local \qVerb{used_regs_prev} variable.
Therefore, after the assignment, the \qVerb{used_registers} vector will be empty.

\Lirsting[
	float=H,
	ranges={92-92, 115-133:59, _133:84-139, 160-161, 189-189},
	caption={The \qVerb{call_expr} method of the \riscv{} rush compiler.},
	label={lst:riscv_call_expr_2},
	fancyvrb={firstline=2, lastline=30},
	continued=true,
]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

In line~136, the \qVerb{spill_param_size} variable is incremented.
It specifies the additional storage required for placing arguments on the stack.
For instance, a call with nine integer arguments would need eight additional bytes of memory since the \nth{9} argument would have to be placed on the stack.
The optional placement of arguments on the stack is performed by the loop in line~115.
It iterates over each argument expression of the call, and for each expression, the match-block in line~116 executes different code depending on the expression's result data type.
For instance, expressions which yield in \qVerb{()} or \qVerb{!} do not require registers and can thus be compiled without further consideration.
However, for float values, the code in the lines~121--136 is executed.
Firstly, the argument's expression is compiled and the resulting register is saved in the variable \qVerb{res_reg}.
Next, the \qVerb{nth_param} method is called on the \qVerb{FloatRegister} enumeration.
This method associates an index of a parameter to a register.
For instance, the index 2 represents the third parameter, which is represented by the register \qVerb{fa2}.
For unsupported indices, the method returns \qVerb{None}.
Therefore, the if-expression in line~123 of Listing~\ref{lst:riscv_call_expr} checks whether there still is a register which could represent the current argument position.
This position is saved in the \qVerb{float_cnt} and \qVerb{int_cnt} variables which are incremented whenever an argument of the respective type is encountered, in line~138 for instance.
If there is no register left, the \qVerb{spill_param_size} variable is incremented by 8 bytes as floats require eight bytes of information.
Otherwise, in case a register is available, the code in the lines~124--125 is executed.
Here, \qVerb{res_reg} is only marked as used and pushed in the \qVerb{param_regs} vector.
There is no code validating that the correct register for the argument position is returned.
This check is redundant since all registers have been marked as unused prior to this block.
Therefore, the resulting value of argument expressions will always be in the correct registers.
However, if there is no register for the current argument, the value has to be spilled onto the stack.
For this, a \qVerb{fsd} instruction (or \qVerb{sd} instruction for integers) is inserted in order to save the result of the current argument on the stack.
As described in a previous section about the \riscv{} calling convention, spilled arguments are placed on the stack in a way so that the first spilled argument is at the lowest memory position.
For reference, this process is described in detail in Figure~\ref{fig:riscv_call_spill} in Section~\ref{sec:riscv_calling_conv} on page~\pageref{sec:riscv_calling_conv}.
In order to calculate this increasing offset easily, the \qVerb{spill_cnt} variable was declared in line~113 of Listing~\ref{lst:riscv_call_expr}
Every time an argument is spilled, this counter increases.
In line~131 of Listing~\ref{fig:riscv_call_expr_2}, the code calculating the offset relative to \qVerb{sp} can be seen.
Here, the value of \qVerb{spill_cnt} is simply multiplied by 8 in order to obtain the correct offset.
Therefore, the memory offset $o$ is calculated like this: $o = \text{count}_\text{spilled} \times 8$.
In line 169, the \qVerb{spill_cnt} variable is incremented like described previously.
Although just the code for floats is shown here, the algorithm for integer-based types only deviates slightly from the one for floats.

The Rust code in Listing~\ref{lst:riscv_call_expr_2} shows the last part of the method.%
%
\Lirsting[
	continued=true,
	float=H,
	ranges={92-92, 163-189},
	fancyvrb={firstline=2},
	caption={The \qVerb{call_expr} method of the \riscv{} rush compiler.},
	label={lst:riscv_call_expr_2}
]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}
%
The code in the lines~165--173 is responsible for mangling the name of the called function so that it includes the \qVerb{main..} prefix.
However, if the \qVerb{exit} function is called, the name is not mangled.
In line~174, the \qVerb{call} instruction responsible for performing the actual call is inserted.
At this point, the arguments are in their correct places so that the called function will be able to access them.
In line~177, the previously emptied \qVerb{used_registers} vector is restored to its state before the call.
This is done in order to allow the register allocation for the call arguments to happen independently of the rest of the compiled code.
The code in the lines~179--185 is responsible for selecting an appropriate output register based on the function's return type, storing it in \qVerb{res_reg}.
For instance, functions which return \qVerb{float} values place their return value inside the register \qVerb{fa0}, and for functions which return the \qVerb{()} or \qVerb{!} types, no register is selected and \qVerb{None} is returned.
In line~188, the method \qVerb{restore_regs_after_call} later reloads the old register values from the stack.
However, that method also requires the return register of the called function as its first argument.
The reasons why \qVerb{restore_regs_after_call} has to access the return register is that this register might habe been in use before the call.
However, restoring the register would result in the function's return value to be overwritten, therefore creating a bug.
In order to mitigate this issue, the method will alter the result register by inserting a \qVerb{mv} instruction if necessary.
Since the method returns the final output register which contains the call's result, it is used as the last expression of the block,
thus making it the return value of the \qVerb{call_expr} method.

The last thing to mention is how a called function returns a value.
Whenever an explicit or implicit return in a function is encountered,
the compiler checks whether the expression already saved its result in the appropriate return register.
In case it did not, a \qVerb{mv} (\enquote(\textbf{m}o\textbf{v}e)) instruction is used to move it there.
Afterwards, a jump to the function's epilogue is issued, causing the function to return.

\subsubsection{Loops}

Since assembly dialects does not provide high-level control-flow constructs like loops,
a compiler targeting assembly has to generate code which reproduces the behaviour.
Listing~\ref{lst:rush_while_loop} shows a rush program containing a while-loop.
Next to it, Listing~\ref{lst:asm_riscv_while_loop} shows the part of the compiler output that represents the loop and the \qVerb{exit} call.

\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[caption={A rush program containing a while-loop.}, label={lst:rush_while_loop}, float=H]{listings/while_loop.rush}
\end{minipage}%
\hfill
\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[ranges={21-36},caption={Compiler output of the rush program in Listing~\ref{lst:rush_while_loop}.}, label={lst:asm_riscv_while_loop}, float=H]{listings/generated/rush_while_loop.s}
	\vspace{.1cm}
\end{minipage}

The rush program contains a while-loop which iterates ten times.
At the beginning of the program, the integer variable \qVerb{count} is declared.
Before each iteration, the while-loop checks whether \qVerb{count} is less than `10'.
If it is, count is incremented by \qVerb{1}, and the loop begins its next iteration.
Otherwise, the execution of the loop stops and the code after the loop is executed.
In the assembly code, the content of the loop is represented by the instructions below the \qVerb{while_head_0} label.
As the comment in line 22 suggests, the first four instructions represent the loop control code.
These instructions are executed every time time loop begins a new iteration, therefore they check if the condition is true before any of the code inside the loop's body is executed.
If it results in `false', the execution of the loop should stop.
This is accomplished by the \qVerb{beqz} (\enquote{\textbf{b}ranch (if) \textbf{eq}ual (to) \textbf{z}ero}) instruction in line 26.
It is a pseudoinstruction which jumps to the specified label if the value inside the first operand is zero~\cite[p.~105]{Waterman2019}.
Here, this means that the instruction would jump to the \qVerb{after_while_0} label if the condition of the loop evaluated to `false'.

This label contains code which follows the while-statement, here only the call to the \qVerb{exit} function.
Otherwise, if the condition evaluated to `true', the \qVerb{beqz} instruction would not perform a jump and the CPU would just continue to the following instruction.
The instructions following that conditional jump represent the loop body, i.e., the statement \qVerb{count +=1}
In line~32, and unconditional jump, which jumps back to the beginning of the \qVerb{while_head_0} label, follows.
Therefore, the loop begins its next iteration.
Using this appropriate, the compiler is able to generate instructions for the \qVerb{loop}, \qVerb{while}, and \qVerb{for} statements.
