% chktex-file -2
\newpage
\section{x86\_64: Compiling to a CISC Architecture}

In addition to \emph{reduced instruction set computers} (\emph{RISC}), there are also \emph{complex instruction set computers}, short \emph{CISC}.
The main differences lie in the instruction count and complexity.
For the purposes of this paper, the still widely used CISC architecture \emph{x86\_64}\footnote{Later shortened to \emph{x64}.} is used as an example, just like \riscv{} was used to represent RISC architectures in the previous section.
While \riscv{} with all extensions used by rush\footnote{The used extensions are RV32I, RV64I, RV32M, RV64M, RV32D, and RV64D.} provides about 100 different instructions~\cite[Chapter~24]{Waterman2019}, x64 is estimated to have about 3600 instructions~\cite{Rodgers2017}.
This is due to the fact that at the time when most CISC architectures were developed, many developers still programmed in assembly languages by hand, without the help of compilers.
Additional instructions for higher level concepts were therefore very helpful~\cite[p.~9]{Dandamudi2005Risc}.

One example for such an instruction is the x64 \qVerb{leave} instruction.
It is used to release the current stack frame at the end of a procedure.
Listing~\ref{lst:riscv_epilogue} on page~\pageref{lst:riscv_epilogue} shows how multiple \riscv{} instructions are used to accomplish the same manually.
First, the frame pointer register is copied into the stack pointer register, freeing the stack space allocated at the start of the procedure.
Then, the old frame pointer that was saved on the stack is loaded from the stack back into the frame pointer register.
Restoring the return address and returning to the caller is both done by the \qVerb{ret} instruction in x64.

Another similar example is the \qVerb{call} instruction.
Although it is also usable in \riscv{} assembly, it is a pseudoinstruction provided by the assembler and resolves to multiple other \riscv{} instructions during the assembly process.
In x64 however, \qVerb{call} is a conventional instruction.

For x64 specifically, there are also some instructions that only operate on certain specific registers.
For instance, the \qVerb{idiv}\label{x64_idiv} instruction divides a signed 128-bit integer stored in the two 64-bit registers \qreg{rdx} and \qreg{rax} by the given operand, storing the result in the \qreg{rax} register and the remainder in the \qreg{rdx} register. This makes usage of such instructions significantly more demanding, as values in these registers must be spilled to the stack in case they must be preserved.

The substantial growth of the x64 instruction set and its commitment to backwards compatibility have also led to a number of instructions that have long become obsolete.
For example, \qVerb{aaa} (ASCII Adjust after Addition) is used in the context of adding two \emph{Binary Coded Decimal} (\emph{BCD}) values, but that technology is rarely used nowadays~\cite[p.~4]{Patterson2017}.
\TODO{maybe explain what BCD is?}

\subsection{x64 Assembly}

\Lirsting[wrap=o, fancyvrb={numbers=\OuterEdge}, wrap width=0.4\textwidth, label={lst:x64_example}, caption={Example rush program.}]{listings/x64_simple.rush}

There are multiple different dialects of x64 assembly and multiple assemblers each supporting a different set of dialects.
The rush x64 compiler emits assembly code using Intel syntax that can be assembled by the \emph{GNU Assembler} (GAS).

Listing~\ref{lst:x64_example} contains another simple rush program.
It defines a global variable called \qVerb{a} and assigns it the integer 2, increments it by one, defines a local boolean called \qVerb{b}, using \qVerb{true} as its initial value, and exits with the sum of \qVerb{a} and \qVerb{b}.
The corresponding assembly code generated by the x64 rush compiler is shown in Listing~\ref{lst:x64_asm_example}.
It begins with the \qVerb{.intel_syntax} directive, indicating that the following assembly code uses the Intel syntax.
Then, similar to the \riscv{} assembly code shown in the previous section, the \qVerb{_start} symbol is marked as global, as it again represents the entry point.
The sections are also the same, as these are defined by the ELF format which is independent of ISAs.

\Lirsting[wrap=o, fancyvrb={numbers=\OuterEdge}, wrap width=0.6\textwidth, label={lst:x64_asm_example}, caption={Compiler output from the rush program in Listing~\ref{lst:x64_example}.}]{listings/x64_simple.s}

The main differences between x64 assembly and the previously shown \riscv{} assembly, and also the other x64 assembly dialects, are the instruction mnemonics and the register names.
When using the Intel syntax for x64, register names are always prepended by a percentage sign.
Another difference is the syntax used for pointers.
While \riscv{} assembly uses \qVerb{-1(fp)} to specify the value in the \qVerb{fp} register as a memory address with an offset of `-1', Intel x64 uses \qVerbCmd{byte ptr [\%rbp-1]}, as seen in line~16.
It is obvious that the latter provides an additional constraint, the size of the value pointed to, here \qVerb{byte}.
\riscv{} assembly instead encodes this information in the instruction mnemonic.
To store a byte, one would use \qVerb{sb} (\textbf{s}tore \textbf{b}yte), whereas for storing a 64-bit integer, \qVerb{sd} (\textbf{s}tore \textbf{d}word) is used instead.

The naming of sizes other than `byte' was not explained yet, and this, too, differs between \riscv{} and x64.
Architectures usually define the size of one so-called \emph{word}.
In \riscv{}, a word is defined as 32 bits, so 4 bytes, in x64 it is defined as 16 bits, so 2 bytes.
All other sizes, except for the byte, are then named based on the word size.
Therefore, \riscv{} assigns 16-bit, 32-bit, and 64-bit the names \emph{half word}, \emph{word}, and \emph{double word} respectively~\cite[p.~6]{Waterman2019}.
For x64, they are instead called \emph{word}, \emph{double word}, and \emph{quadruple word}~\cite[p.~3]{Kusswurm2018-nd}.
These names are often shortened to only include the first letter of the factor.
For instance, a double word is called \emph{dword}.
In some instances, like in line~28, alternative short forms are used.
Here, the directive \qVerb{.quad} denotes a quadruple word.

Another important difference between x64 and \riscv{} is the typical operand structure of instructions.
\riscv{} requires three operands for \qVerb{add}, \qVerb{sub}, and many other instructions, these being the destination, the first source, and the second source.
The norm in x64 is using just two operands where the first doubles as both the first source and the destination~\cite[pp.~14--20]{Dandamudi2005Risc}.

\begin{table}[h]
	\centering
	\caption[x64 Integer Registers]{Integer registers on the x64 architecture~\cite[pp.~20,26]{Lu2022}.}\label{tbl:x64_registers}
	\rowcolors{2}{gray!15}{}
	\begin{tabular}{c|ccc|c|l}
		\rowcolor{gray!25} 64-bit & 32-bit     & 16-bit     & 8-bit      & Caller-Saved & Purpose                                    \\
		\hline
		\reg{rbp}                 & \reg{ebp}  & \reg{bp}   & \reg{bpl}  &              & base pointer / frame pointer               \\
		\reg{rsp}                 & \reg{esp}  & \reg{sp}   & \reg{spl}  &              & stack pointer                              \\
		\reg{rax}                 & \reg{eax}  & \reg{ax}   & \reg{al}   & \checkmark{} & \nth{1} return register                    \\
		\reg{rbx}                 & \reg{ebx}  & \reg{bx}   & \reg{bl}   &              &                                            \\
		\reg{rcx}                 & \reg{ecx}  & \reg{cx}   & \reg{cl}   & \checkmark{} & \nth{4} argument register                  \\
		\reg{rdx}                 & \reg{edx}  & \reg{dx}   & \reg{dl}   & \checkmark{} & \gape{\makecell[l]{\nth{2} return register \\\nth{3} argument register}} \\
		\reg{rsi}                 & \reg{esi}  & \reg{si}   & \reg{sil}  & \checkmark{} & \nth{2} argument register                  \\
		\reg{rdi}                 & \reg{edi}  & \reg{di}   & \reg{dil}  & \checkmark{} & \nth{1} argument register                  \\
		\reg{r8}                  & \reg{r8d}  & \reg{r8w}  & \reg{r8b}  & \checkmark{} & \nth{5} argument register                  \\
		\reg{r9}                  & \reg{r9d}  & \reg{r9w}  & \reg{r9b}  & \checkmark{} & \nth{6} argument register                  \\
		\reg{r10}                 & \reg{r10d} & \reg{r10w} & \reg{r10b} & \checkmark{} &                                            \\
		\reg{r11}                 & \reg{r11d} & \reg{r11w} & \reg{r11b} & \checkmark{} &                                            \\
		\reg{r12}                 & \reg{r12d} & \reg{r12w} & \reg{r12b} &              &                                            \\
		\reg{r13}                 & \reg{r13d} & \reg{r13w} & \reg{r13b} &              &                                            \\
		\reg{r14}                 & \reg{r14d} & \reg{r14w} & \reg{r14b} &              &                                            \\
		\reg{r15}                 & \reg{r15d} & \reg{r15w} & \reg{r15b} &              &                                            \\
	\end{tabular}
\end{table}

\subsection{Registers}

The base x64 ISA provides 16 general-purpose registers capable of holding 64-bit integers.
These are shown in Table~\ref{tbl:x64_registers}.
Additionally, three more sets of 16 registers are defined, each half the size as the previous one.
However, instead of these being additional storage, they simply provide an alias to the lower half of the respective larger register.
For instance, when writing the byte $(2a)_{16}$ into \qreg{al}, the least significant byte of \qreg{ax}, \qreg{eax}, and \qreg{rax} changes to $(2a)_{16}$, too.
The upper bytes are untouched, however.
That means, if for example \qreg{ax} contains the value $(a455)_{16}$ before writing, it will contain $(a42a)_{16}$ afterwards, not $(002a)_{16}$.

These registers for smaller sizes are not present for legacy reasons though.
Considering line~18 from Listing~\ref{lst:x64_asm_example}, the move of the value behind the \qVerb{byte ptr} requires the destination register to one byte in size, too.
For this reason, the compiler uses the \qreg{sil} register here, instead of its 64-bit equivalent \qreg{rsi}.
Line~19 then performs the cast from the boolean, saved as a byte, to a 64-bit integer.
It does this by taking the 64-bit variant of the register, in this case \qreg{rsi}, and assuring all bits, except for the least significant eight, are zeros.
The latter is done using the \emph{bitwise AND} operation with the number $2^8-1=255$, which in binary is represented by eight ones.

Another special register is \qreg{rip}.
It stores the instruction pointer, that is, the address to the current instruction being executed.
The register is usually not modified directly, as branching can be achieved with instructions like \qVerb{call}, \qVerb{ret}, or \qVerb{jmp}.
Nevertheless, it is sometimes accessed manually, as seen in lines 15 and 17.
These read and write to the global \qVerb{a} variable, defined at the \qVerb{main..a} symbol.
Accesses like this simply require the offset by the instruction pointer in x64 Assembly.

In addition to these general purpose registers, x64 also defines 16 registers for floating-point number calculations, each 128 bits in size and labelled \qreg{xmm0} through \qreg{xmm15}.
For the purposes of rush, only the lower 64 bits are ever used, since this is enough for double precision floating-point numbers.
The additional 64 bits are provided for \emph{single instruction multiple data} (\emph{SIMD}) instructions.
They can be used by more optimized compilers to operate on multiple values at a time.
Any single one of these registers would then for instance hold two 64-bit values or four 32-bit values.

\TODO{explain pointers? (should be the same as \riscv{})}

\subsection{Stack Layout and Calling Convention}

\begin{wrapfigure}{O}{0.55\textwidth}
	\hspace{-1.75cm}
	\begin{tikzpicture}[xscale=0.9, yscale=0.7]
		\footnotesize

		% manually set counter to allow stack frame including the start dots
		\setcounter{cellnb}{0}
		\startframe
		\addtocounter{cellnb}{-1}

		% copied code from `\stacktop{}` to not reset counter to in turn allow `\startframe` above this
		\draw[padding] (0,\value{cellnb})
		+(-2,.5) -- +(-2,-.5) -- +(2,-.5) -- +(2,.5);
		\draw (0,\value{cellnb}) node{...};

		\cell{$n$\textsuperscript{th} stack argument} \cellcom{\VerbCmd{\%rbp+}$(16+8n)$}
		\cell[padding]{...}
		% custom draw instead of `\cellcom` for yshift
		\draw (2.4,\value{cellnb}) node[anchor=west, yshift=3.5pt] {\vdots};
		\cell{\nth{1} stack argument} \cellcom{\VerbCmd{\%rbp+16}}
		\finishframe{previous}

		\cell{return address} \cellcom{\VerbCmd{\%rbp+8}}
		\cell{previous \qreg{rbp} value} \cellcom{\VerbCmd{\%rbp}}

		\startframe
		\padding{3}{\makecell{unspecified\\variable size}} \cellcom{\VerbCmd{\%rsp}}
		% custom draws instead of `\cellcom` for yshift and padding cell offset
		\draw (2.4,\value{cellnb}+1) node[anchor=west, yshift=3.5pt] {\vdots};
		\draw (2.4,\value{cellnb}+2) node[anchor=west] {\VerbCmd{\%rbp-8}};
		\finishframe{current}
		\stackbottom[padding]
	\end{tikzpicture}
	\caption[Stack Layout of x64]{Stack layout of the x64 architecture~\cite[p.~21]{Lu2022}.}\label{fig:x64_stack}
\end{wrapfigure}

Alongside the instructions and registers defined by x64 itself, the \emph{System~V} ABI defines how programs should structure the stack during execution.
Figure~\ref{fig:x64_stack} shows this layout.
The overall outline is similar to that of \riscv{}, but some details differ.
For one, the order of the saved return address and the saved \qreg{rbp} register is inverted.
Secondly, the address \qreg{rbp} points to is different by 16 bytes.
Therefore, in x64 the first stack argument is accessed by offsetting \qreg{rbp} by 16, whereas in \riscv{} the \qVerb{fp} register already points to the first stack argument without any offset.
In both calling conventions every stack argument uses eight bytes of space, but x64 has no special return address register, and instead only stores the return address on the stack and retrieves it from there when needed.
At the moment of calling a function, the stack frame's size must be aligned to a multiple of 16 bytes.
The unspecified space between \qVerbCmd{\%rbp-8} and \qreg{rsp} can be freely used by the current function to save local variables.
Its internal layout may differ between programming languages~\cite[p.~21]{Lu2022}.

\subsection{Implementation: The rush compiler targeting x\_64}

\Lirsting[ranges={14-14, 20-21, 46-47, 104-104}, wrap=o, fancyvrb={numbers=\OuterEdge}, caption={The \qVerb{Instruction} definition in the rush x64 compiler.}, label={lst:x64_instruction}]{deps/rush/crates/rush-compiler-x86-64/src/instruction.rs}

Even though many implementation details could be the same as for the \riscv{} compiler, there are some differences because we each created one separately and did not have any reference implementation.
One such difference is that the x64 compiler's \qVerb{Instruction} definition which is shown in Listing~\ref{lst:x64_instruction} not only includes actual instructions, but also directives and symbols.
This way, an entire assembly file can be represented as one \qVerb{Vec<Instruction>} with every \qVerb{Instruction} representing one line of the assembly code.
A matching \qVerb{Display} implementation then simply emits the respective assembly representation.

Line~20 shows the definition of the \qVerb{.section} directive, simply holding an instance of another enumeration containing the valid sections.
Line~21 defines an assembly symbol, holding its name and a boolean whether a blank line should be added above.
\TODO{did I say what symbols / labels are?}
The name is saved as an \qVerb{Rc<str>} instead of a \qVerb{String} here to prevent some unnecessary cloning in some places.

The normal instructions, e.g., \qVerb{add} and \qVerb{sub}, also cannot simply take registers as operands, as x64 also allows memory pointers and immediate values in many places.
Instead, another enumeration, called \qVerb{IntValue}, is introduced to allow these three variants.
Listing~\ref{lst:x64_intvalue} shows its definition.

\subsubsection{Struct Fields}

\Lirsting[ranges={33-37}, wrap=o, wrap width={0.45\textwidth}, fancyvrb={numbers=\OuterEdge}, caption={The \qVerb{IntValue} definition in the rush x64 compiler.}, label={lst:x64_intvalue}]{deps/rush/crates/rush-compiler-x86-64/src/value.rs}

The compiler struct itself shown in Listing~\ref{lst:x64_compiler} is also a bit different.
Both compilers have a \qVerb{used_registers} field, but this compiler does not need to store the size for each register, because the registers themselves already have a defined size.
Both compilers have a \qVerb{scopes} field for storing variable locations, but the \riscv{} compiler has the \qVerb{Option<_>} inside the \qVerb{Variable} struct.
Both compilers store the global variables, but this compiler has separate fields for every size for easier alignment in the static memory which is not required for \riscv{}.
\TODO{is this true?}
The same applies for constants in the \qVerb{.rodata} section.
Both compilers have one field for accumulating the final assembly code, but this compiler saves a list of \qVerb{Instruction}s instead of \qVerb{Block}s.

\Lirsting[ranges={15-19, 25-31, 43-48, 55-60, 69-71}, float=htb, caption={The x64 \qVerb{Compiler} struct definition.}, label={lst:x64_compiler}]{deps/rush/crates/rush-compiler-x86-64/src/compiler.rs}

Additional fields of this compiler are \qVerb{function_body}, \qVerb{stack_pointer}, and \qVerb{frame_size}.
The \qVerb{function_body} field stores the instructions for the currently compiled function.
During compilation of statements and expressions, emitted instructions are always appended to this list.
The method for compiling a function body then produces the prologue and afterwards appends the list contents onto \qVerb{text_section}.
This is required, because some values like the \qVerb{frame_size} that are needed in the prologue cannot be known beforehand, but must appear before the function body in the assembly code.

\subsubsection{Memory Management}

The \qVerb{stack_pointer} field is used to keep track of the current stack frame.
Every time a variable definition is encountered or a register is spilled, stack space for it is saved by increasing this stack pointer.
This process is done by the \qVerb{push_to_stack} method visible in Listing~\ref{lst:x64_push_to_stack}.
It takes a value, its size, and an optional comment as arguments.
At first, the stack pointer is aligned to a multiple of the values' size by the \qVerb{align} function.
Then, the number of bytes required for the value is added to it, and the frame size is increased in case it is not big enough yet.
Now, the pointer to this value is constructed, using \qreg{rbp} as the base and the negated stack pointer as an offset.
Finally, a \qVerb{mov} instruction for inserting the value at the location of the pointer is added to the assembly code, and the pointer is returned for further use.

\Lirsting[ranges={254-271, 277-277, _280-283}, float=htb, caption={Stack space reservation for values.}, label={lst:x64_push_to_stack}]{deps/rush/crates/rush-compiler-x86-64/src/compiler.rs}

\subsubsection{Register Allocation}

\Lirsting[ranges={257-265, 270-272:26, _272:59-274}, wrap=0, wrap width=0.5\textwidth, fancyvrb={numbers=\OuterEdge}, caption={Register allocation in the rush x64 compiler.}, label={lst:x64_intregister_next}]{deps/rush/crates/rush-compiler-x86-64/src/register.rs}

The register allocation algorithm of the x64 compiler differs quite a lot, too.
Instead of marking individual registers as used or unused and then searching through a specified order for the first free one, this compiler uses an almost stack-like behavior.
Again, one specific order of registers is defined, starting with the return register \qreg{rax}, followed by the argument registers in their correct order, and ending with the remaining general purpose registers.
Whenever a free register is required, the \qVerb{next} method from Listing~\ref{lst:x64_intregister_next} on the last used register is called, returning the next register in line, which is then added to the \qVerb{used_registers} field.
For freeing a register, the compiler just pops the last register off this list.
This only works, because the rest of the compiler guarantees used registers to be freed in exactly the reverse order they were reserved in.
With this guarantee it is apparent that at any point in time during compilation, the registers in the \qVerb{used_registers} field are in the exact order specified by Listing~\ref{lst:x64_intregister_next} without gaps.
The same is done separately for the float registers.

\subsubsection{Functions}

\Lirsting[wrap=o, wrap width=0.3\textwidth, fancyvrb={numbers=\OuterEdge}, caption={Another example rush program with two functions.}, label={lst:x64_functions_rush}]{listings/x64_functions.rush}

To explain the process of compiling functions and function calls there is another example program to be considered in Listing~\ref{lst:x64_functions_rush} along with the produced assembly code in Listing~\ref{lst:x64_functions_asm}.
Though not explicitly labelled, the x64 compiler also uses the concept of a function prologue, body, and epilogue.
Since the \qVerb{main} function in this example does not require any stack space for variables or register spilling, the prologue is automatically left out, and the epilogue does not contain a \qVerb{leave} instruction for freeing the memory.
The \qVerb{foo} function however does declare a local variable and thus requires the stack space to be allocated in the prologue.
Lines~20--22 are responsible for this.
As previously shown in Figure~\ref{fig:x64_stack}, the stack should first contain the return address and then the previous base pointer, the former of which is already handled by the \qVerb{call} instruction.
Therefore, the function's prologue begins with pushing \qreg{rbp} onto the stack.
Afterwards, the base pointer's value is set to the current stack pointer.
The stack pointer itself is then decremented by the number of bytes needed for the function which is saved in \qVerb{frame_size}, rounded up to a multiple of 16.

\Lirsting[ranges={11-31}, wrap=o, wrap width=0.7\textwidth, fancyvrb={numbers=\OuterEdge}, caption={Trimmed compiler output for the rush program in Listing~\ref{lst:x64_functions_rush}.}, label={lst:x64_functions_asm}]{listings/x64_functions.s}

The epilogue ranges from line~29 to line~31.
It defines a symbol where \qVerb{return} statements can jump to, releases the stack frame using the \qVerb{leave} instruction, and returns control to the caller with \qVerb{ret}.
Usage of the return symbol can be seen in line~26, which does an unconditional jump to there, rendering all intermediate instructions as unreachable.
This is the expected behavior, because the jump instruction was emitted for the \qVerb{return} statement in line~6 of the rush program, which should skip to the end of the function.
The return value was moved into the \qreg{rax} register, or its correspondingly sized variant, in advance.

\TODO{\qVerb{function_body} definition?}

\subsubsection{Function Calls}

% \Lirsting[ranges={37-44}, wrap=o, wrap width=0.61\textwidth, fancyvrb={numbers=\OuterEdge}, caption={Definition of the parameter registers and their order. \TODO{this listing could be removed}}, label={lst:x64_int_param_regs}]{deps/rush/crates/rush-compiler-x86-64/src/register.rs}

To support function calls, two main aspects must be considered: passing arguments from the caller, and retrieving arguments in the callee.

Generally, for passing arguments the compiler simply iterates over the argument expressions, compiles each one in turn, and moves their result into the appropriate register, or onto the stack if no registers are left.
As the passing of the first six integer arguments is done through the same registers, a function call always requires access to these exact registers, or at least a subset of them.
That means, if some of the registers happen to be in use already, their content has to be spilled to the stack and replaced with the argument value.
An example for when this might happen is a function call as a non-first argument to another function call, like in `\LirstInline{rush}{foo(42, bar('x'))}'.
When the inner function call, here \qVerb{bar}, wants to move its first argument \qVerb{'x'} into \qreg{rdi}, it notices this register is already used for the first argument of the outer function call, \qVerb{42}.

Each function that takes parameters should move all passed arguments from their registers onto the stack in order to make the registers available for the rest of the function body.
In Listing~\ref{lst:x64_functions_asm} this happens in line~23 for the one parameter called \qVerb{n}.
More optimized compilers can of course try to keep the arguments in the registers for as long as they are not specifically needed elsewhere, but as the rush compilers only serve educational purposes this is not done.

\subsubsection{\TODO{Write something one Corelib?}}

\subsubsection{Control Flow}

\Lirsting[ranges={5-13}, wrap=o, wrap width=0.55\textwidth, fancyvrb={numbers=\OuterEdge}, caption={A rush example function containing if-expressions and a loop.}, label={lst:x64_control_flow_rush}]{listings/x64_control_flow.rush}

Just as with \riscv{}, control flow constructs like loops and if-branches must be represented using simple jumps in assembly.
There are both conditional and unconditional jumps, the latter of which was already slightly touched upon when explaining \qVerb{return} statements in a previous section.
An unconditional jump, done in x64 with the \qVerb{jmp} instruction, only takes a symbol to jump to and does so, as the name implies, without checking for any condition.
Conditional jumps are rather a set of different instructions, each testing a different condition.
The way x64 handles conditions again differs from \riscv{}.
It provides a set of flags indicating various relations between two values, which are set by dedicated compare instructions like \qVerb{cmp} for integers, \qVerb{test} for booleans, and \qVerb{ucomisd} for floats.
A conditional jump instruction like \qVerb{je} (\textbf{j}ump if \textbf{e}qual) then only has to query the flag that indicates equality, and optionally performs a jump based on its value.

\Lirsting[ranges={17-56}, float=htb, caption={Trimmed compiler output for the rush function in Listing~\ref{lst:x64_control_flow_rush}.}, label={lst:x64_control_flow_asm}]{listings/x64_control_flow.s}

Listing~\ref{lst:x64_control_flow_rush} shows one last example rush function with the produced assembly code in Listing~\ref{lst:x64_control_flow_asm}, this time containing if-expressions and a loop with one \qVerb{break} and one \qVerb{continue} statement.
The purpose of this function is nonexistent, and the semantic analyzer rightfully complains about unreachable statements and unused variables, but it still serves to show translation of these constructs to assembly.

\begin{wrapfigure}{o}{0.5\textwidth}
	\begin{tikzpicture}[every node/.style={minimum size=1.5ex}]
		\node(s)[vstack=8, rectangle split part align=left]{%
			\strut \emph{condition}
			\nodepart{two}  \strut jump to \qVerb{.block_x} if condition is false
			\nodepart{three}\strut \emph{if-block}
			\nodepart{four} \strut jump to \qVerb{.block_y}
			\nodepart{five} \strut \Verb{.block_x:}
			\nodepart{six}  \strut \emph{else-block}
			\nodepart{seven}\strut \Verb{.block_y:}
			\nodepart{eight}\strut \dots
		};
		\draw[arrow] (s.two east) to [out=-30,in=30] (s.five east);
		\draw[arrow] (s.four east) to [out=-30,in=30] (s.seven east);
	\end{tikzpicture}
	\caption{Structure of if-expressions in assembly.}\label{fig:asm_if}
\end{wrapfigure}

Compiled if-expressions always follow the same outline as it is shown in Figure~\ref{fig:asm_if}.
First, the condition is compiled and an initial jump instruction that jumps to the else-block in case the condition evaluates to `false' is emitted.
Following that are the instructions for the if-block, concluded by an unconditional jump to behind the else-block.
Now, the first symbol is inserted, here \qVerb{.block_x}, followed by the else-block.
The whole thing ends with the second symbol, here \qVerb{.block_y}.
Any following code goes after that.
It is apparent that this structure encodes the expected if-else branching behavior.
The code from the if-block is only ever reached, if the condition is true, and it then skips over the else-block to the following instructions.
If the condition is false, the if-block is immediately skipped and only the else-block is executed which then also continues with the following instructions, causing the two branches to merge.

Starting with the if-expression in line~6 of Listing~\ref{lst:x64_control_flow_rush}, the condition here is merely a boolean variable.
In order to execute a jump based on the value of this variable, the \qVerb{test} instruction is used in line~22 of Listing~\ref{lst:x64_control_flow_asm} with both the variable pointer and a constant `1' as operands.
This results in the equality flag being set to `1' if a bitwise AND operation of these operands results in `0', that is, if the boolean variable is `false'.
The following \qVerb{je} instruction in line~23 therefore skips to the else-block in case the boolean value was `false'.

The compiler could now simply compile all condition expressions as usual, always resulting in one \qVerb{IntValue} holding a boolean and use the same simple boolean check every time.
However, since x64 provides additional jump instructions for basic conditions like \qVerb{==}, \qVerb{!=}, \qVerb{>=}, or \qVerb{<}, the compiler will try to use one of these when the source rush expression is simple enough.
This can be seen in lines~30--33 of the assembly code, which represent the condition of the if-expression in line~7 of the rush code.
The compiler detects the condition to be a simple equality check between two floats, and therefore issues a \qVerb{ucomisd} instruction in line~31 to compare the floats, and a \qVerb{jne} instruction in line~33 to jump if the floats are not equal.
The cause for the \qVerb{jp}\label{x64_ucomisd} instruction in between is explained later.

\TODO{show rust snippets}

The representation of the loop is much simpler.
It must only define two symbols, one before and one after the loop contents, and unconditionally jump back to the former at the end of every iteration.
This second point is the reason for why the comments in Listing~\ref{lst:x64_control_flow_asm} show two \qVerb{continue} statements, even though the rush function only had one.
An unconditional jump back to the loop's start is exactly the behavior of \qVerb{continue} statements.
And \qVerb{break} statements are not much different either, they just jump to behind the loop instead.
For conditional loops, that is, while-loops and for-loops, there is an additional head effectively performing `\LirstInline{rush}{if !condition { break; }}' at the start of each iteration.
For-loops also initialize a variable before the first iteration and call the update expression at the end of each one.

\subsubsection{Integer Division and Float Comparisons}

This subsection's title might seem a little specific compared to the others, but it has the simple reason that this subsection highlights two unexpectedly complex hurdles which we encountered during the creation of this compiler.
They were both already hinted at before.
Firstly, there is integer division with the \qVerb{idiv} instruction, which was shortly explained in the introduction to x64 on page~\pageref{x64_idiv}.
It is used when compiling rush infix expressions between two integers with either the \qVerb{/} or the \qVerbCmd{\%} operator.

\Lirsting[ranges={56-56, 65-78, _90-104, 110-115}, float=htb, caption={Compilation of integer division in x64.}, label={lst:x64_infix_idiv}]{deps/rush/crates/rush-compiler-x86-64/src/infix.rs}

Listing~\ref{lst:x64_infix_idiv} shows this compilation process.
As \qVerb{idiv} always operates on the \qreg{rax} and \qreg{rdx} registers, it must first be assured that they are free for use.
The left-hand side of the division, the numerator, is then moved into \qreg{rax} and sign-extended\footnote{\TODO{what is sign-extension}} to 128 bits via the \qVerb{cqo} instruction.
Now, the right-hand side, the denominator, is made sure to either be a register or a memory pointer, which is then used in the call to \qVerb{idiv} in line~93.
The division result, either \qreg{rax} or \qreg{rdx} depending on the operator, is then moved into the register that previously contained the numerator, as this is guaranteed to be available now.
To finish up, possibly spilled registers are reloaded, and the register is returned as the expression's result.
The resulting assembly of this can be seen in lines~43--45 in Listing~\ref{lst:x64_control_flow_asm}.

The second unexpected hurdle were floating-point number comparisons.
Floating-point numbers as defined by the IEEE standard have the special property of not forming a total order \TODO{cite}.
That means, not any two arbitrary values are comparable.
For instance, the float standard defines a `NaN'\footnote{Short for ``not a number''.} value, which cannot be compared to itself.
In rush an expression comparing two incomparable float values should result in `false'.
This is the reason for the additional \qVerb{jp} instruction in line~32 of Listing~\ref{lst:x64_control_flow_asm} that was previously hinted at on page~\pageref{x64_ucomisd}.
When comparing two floats with the \qVerb{ucomisd} instruction and there is no clear order defined, the \emph{parity} flag is set to `1'.
The \qVerb{jp} instruction then jumps straight to the else-block if this flag is set, hereby interpreting an expression like \qVerb{NaN == NaN} as false.

\Lirsting[ranges={927-927, 944-959}, float=htb, caption={Compilation of float comparisons in x64.}, label={lst:x64_infix_ucomisd}]{deps/rush/crates/rush-compiler-x86-64/src/compiler.rs}

How this is achieved in the compiler is visible in Listing~\ref{lst:x64_infix_ucomisd}.
The shown code snippet is inside the \qVerb{condition} method which is used during compilation of if-expressions and conditional loops.
After pushing the \qVerb{ucomisd} instruction, two additional checks are performed.
Firstly, if the condition is \qVerb{==}, then add a conditional jump to the else-block for when the result is unordered.
Secondly, if the condition is \qVerb{!=}, then add a conditional jump to the else-block for when the result is \emph{not} unordered.
An expression like \qVerb{NaN != NaN} is therefore considered to be true.
