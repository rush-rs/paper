\newpage
\section{x86\_64: A Compiler for a CISC Architecture}


\begin{itemize}
	\item Present Some example instructions
	\item Register layout \& count
	\item Calling convention
	\item INFORMATION: x86: An intel blog stated ca. 3600 Instructions in 2015 \cite{Rodgers2017}
    \item RISC-V Reader: \emph{ASCII adjust after addition} $\rightarrow$ \emph{aaa} $\rightarrow$ obsolete, collectively occupy 1.6\% of opcode space\cite[p.~4]{Patterson2017}
	\item
	      \enquote{Modular vs. Incremental ISAs Intel was betting its future on a high-end microprocessor, but that was still years away.
		      To counter Zilog, Intel developed a stop-gap processor and called it the 8086. It was intended to be short-lived and not have any successors,
		      but that’s not how things turned out. The high-end processor ended up being late to market, and when it did come out, it was too slow.
		      So the 8086 architecture lived on—it evolved into a 32-bit processor and eventually into a 64-bit one.
		      The names kept changing (80186, 80286, i386, i486, Pentium), but the underlying instruction set remained intact. —Stephen P. Morse, architect of the 8086}\cite{Morse2017}.
              $\Rightarrow$ only meant as a temporary architecture
\end{itemize}

\subsection{Register Layout}

For registers: \cite[p.~7]{Kusswurm2018-nd}

\subsection{Memory Access Through the Stack}

\subsection{Calling Convention}

\subsection{X86\_64 Assembly}
