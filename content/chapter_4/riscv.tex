% chktex-file -2
\newpage
\section{\riscv{}: Compiling to a Modern RISC Architecture}

The \emph{\riscv{}} \emph{ISA}\footnote{Short for: \enquote{instruction set architecture}, it specifies an abstract model of a CPU.} is a new and modern \emph{reduced instruction set} architecture focussing on simplicity and expandability.
The initial version was developed at \emph{UC Berkely} in the context of another related research project.
Since its introduction in 2011, the architecture has been rapidly growing in popularity while being managed and led by the \emph{\riscv{} foundation}.
Today, corporate members of the \riscv{} foundation include companies like \emph{Google}, \emph{Microsoft}, \emph{Samsung}, and \emph{IBM}.
Therefore, the general popularity and commercial attraction of the technology is apparent.
However, unlike most previous ISAs, the \riscv{} architecture is a completely \emph{open source} project and is therefore not controlled by a single large corporate entity.
This can be regarded as a large competitive advantage over other popular RISC architectures like \emph{ARM}.
In the past, many ISAs have failed due to them being too restrictive with their licensing, thus preventing widespread commercial adoption.
However, \riscv{} is completely open and free to use, so that many companies can leverage the technology commercially while contributing to the project.
Unlike most of the previous ISAs, which were developed during the 1970s and 80s, \riscv{} is one of the few which were developed in the last decade.
Therefore, it seems like \riscv{} could be a significant architecture to be used in all sorts of devices in the near future~\cite[preface]{Patterson2017}.

\subsection{Register Layout}

\begin{wraptable}{r}{.4\textwidth}
	\centering
	\caption[Common registers of the \riscv{} architecture.]{Common registers of the \riscv{} architecture~\cite[p.~155]{Waterman2019}.}\label{tbl:riscv_regs}
	\begin{tabularx}{\linewidth}{l|L}
		\rowcolor{gray!10} Register(s) & Purpose                           \\ \hline
		\texttt{zero}                  & hardwired zero                    \\ \hline
		\texttt{ra}                    & return address                    \\ \hline
		\texttt{sp}                    & stack pointer                     \\ \hline
		\texttt{t0}--\texttt{t6}       & temporary storage                 \\ \hline
		\texttt{fp}                    & frame Pointer                     \\ \hline
		\texttt{a0}, \texttt{a1}       & function arguments, return values \\ \hline
		\texttt{a2}--\texttt{a7}       & function arguments                \\ \hline
		\texttt{s1}--\texttt{s11}      & saved register                    \\ \hline
		\texttt{fa0}, \texttt{fa1}     & float arguments, return values    \\ \hline
		\texttt{fa2}--\texttt{fa7}     & float arguments                   \\ \hline
		\texttt{fs0}--\texttt{fs11}    & float saved registers             \\ \hline
		\texttt{ft0}--\texttt{ft11}    & float temporaries                 \\
	\end{tabularx}
\end{wraptable}

Compared to popular CISC architectures, RISC architectures typically have a large count of registers~\cite[Chapter~2]{Dandamudi2005}.
For instance, while the 32-bit variant of the x86 architecture has 8 registers,
the popular RISC architecture \emph{ARM-32} provides twice that amount, meaning 16 registers.
However, a \riscv{} CPU includes 32 registers, which is drastically more than the aforementioned architectures.
Moreover, these 32 registers only include the general purpose ones.
Just for floating-point numbers, the ISA provides another 32 registers.
Due to this difference, a register allocator targeting the \riscv{} architecture could be more aggressive compared to one targeting a CISC architecture~\cite[p.~10]{Patterson2017}.

The Table~\ref{tbl:riscv_regs} shows most of the registers provided by the \riscv{} architecture.
For this table, the official ABI names of the registers have been used.
The special \qVerb{zero} register always holds a constant `0'
Unlike other registers, it is read-only, meaning that it can never be overwritten.
The \qVerb{ra} register saves the \emph{return address} of a procedure.
If a return instruction is used, the value in \qVerb{ra} is used as the address to jump back to.
The \qVerb{sp} and \qVerb{fp} registers are used for managing stack memory.
The registers \qVerb{a0} and \qVerb{a1} both serve as call arguments and return values of functions.
The remaining `\Verb{a}$n$' registers (\qVerb{a2}--\qVerb{a7}) should be primarily used as function call arguments.
How functions are called using registers will be explained in Section~\ref{sec:riscv_calling_conv}.
The next row contains the \emph{saved} registers \qVerb{s1}-\qVerb{s11}.
These registers are meant to be preserved across function calls, meaning a called function must not overwrite them.
What the previously explained registers have in common is that they all hold integer values.
Depending on the used \riscv{} extensions, all registers, including floating-point registers, either hold 32 or 64 bits of information.
The float registers are able to hold floating-point numbers according to the \emph{IEEE 754--2008} standard~\cite[Chapter~11]{Waterman2019}.
Just like their integer counterparts, the floating-point registers \qVerb{fa0} and \qVerb{fa1} are used as function call arguments and as return values.
However, the other `\Verb{fa}$n$' registers (\qVerb{fa2}--\qVerb{fa7}) are meant to be used as float function arguments.
Just like the `\Verb{s}$n$' registers, the \qVerb{fs0}--\qVerb{fs11} registers are usually preserved across function calls.
Lastly, the \qVerb{ft0}--\qVerb{ft11} registers can be used as temporary registers for floating-point numbers.
It is apparent that the floating-point registers are provisioned very similarly to the integer registers.
Therefore, a compiler targeting the architecture can utilize roughly the same principles,
regardless of the data-type~\cite[pp.~18f,p.~34]{Patterson2017},~\cite[p.~155]{Waterman2019}.

Now, it has become apparent that \riscv{} includes many registers grouped into semantic categories.
Every category is meant to be used in the specified manner, however, these groups are mostly only a suggestion of how each register should be used.

\subsection{Memory Access Through the Stack}\label{sec:riscv_stack}
%
% \begin{wrapfigure}{L}{0.39\textwidth}
% 	\hspace{-3.25cm}
% 	\begin{tikzpicture}[scale=.9]
% 		\small
% 		% TODO: also use longer arrow in top `fp_main`?
% 		\stackTopFixed{...} \cellcom{\scriptsize 24(sp\textsubscript{main})} \cellptr{\scriptsize \tt fp\,$_\text{main}$}
% 		\startframe
% 		\cell{fp} \cellcom{\scriptsize 16(sp\textsubscript{main})}
% 		\cell{ra} \cellcom{\scriptsize 8(sp\textsubscript{main})}
% 		\cell{a: int} \cellcom{\scriptsize -24(fp\textsubscript{main})} \cellptrA{\scriptsize \texttt{sp\,$_\text{main}$}}
% 		\cell{b: char} \cellcom{\scriptsize -25(fp\textsubscript{main})} \cellptrA{\scriptsize \texttt{fp\,$_\text{foo}$}}
% 		\finishframe{\tt main}
% 		\startframe
% 		\cell{fp} \cellcom{\scriptsize 8(sp\textsubscript{foo})}
% 		\cell{ra} \cellcom{\scriptsize 0(sp\textsubscript{foo})} \cellptrA{\scriptsize \texttt{sp\,$_\text{foo}$}}
% 		\finishframe{\tt foo}
% 		% TODO: uncomment the line below?
% 		%\stackbottom
% 	\end{tikzpicture}
% 	\caption{Example stack layout in \riscv{}.}\label{fig:riscv_basic_stack}
% \end{wrapfigure}

\begin{wrapfigure}{O}{0.39\textwidth}
	\hspace{-1.75cm}
	\begin{tikzpicture}[xscale=0.9, yscale=0.7]
		\footnotesize

		% manually set counter to allow stack frame including the start dots
		\setcounter{cellnb}{0}
		\startframe
		\addtocounter{cellnb}{-1}

		% copied code from `\stacktop{}` to not reset counter to in turn allow `\startframe` above this
		\draw[padding] (0,\value{cellnb})
		+(-2,.5) -- +(-2,-.5) -- +(2,-.5) -- +(2,.5);
		\draw (0,\value{cellnb}) node{...};

		\cell{$n$\textsuperscript{th} stack argument} \cellcom{\texttt{$8n$(fp)}}
		\cell[padding]{...}
		% custom draw instead of `\cellcom` for yshift
		\draw (2.4,\value{cellnb}) node[anchor=west, yshift=3.5pt] {\vdots};
		\cell{\nth{1} stack argument} \cellcom{\texttt{0(fp)}}
		\finishframe{previous}

		\cell{previous \qVerb{fp} value} \cellcom{\texttt{-8(fp)}}
		\cell{return address} \cellcom{\texttt{-16(fp)}}

		\startframe
		\padding{3}{\makecell{unspecified\\variable size}} \cellcom{\texttt{0(sp)}}
		% custom draws instead of `\cellcom` for yshift and padding cell offset
		\draw (2.4,\value{cellnb}+1) node[anchor=west, yshift=3.5pt] {\vdots};
		\draw (2.4,\value{cellnb}+2) node[anchor=west] {\texttt{-24(fp)}};
		\stackbottom[padding]
		\finishframe{current}
	\end{tikzpicture}
	\caption[Stack layout of the \riscv{} architecture.]{Stack layout of the \riscv{} architecture\TODO{cite}.}\label{fig:riscv_stack}
\end{wrapfigure}


Figure~\ref{fig:riscv_stack} shows the stack layout used by \riscv{}.
Stack frames are enclosed by the \qVerb{fp} and \qVerb{sp} registers.
Here, \qVerb{sp} always points to the lowest address inside of the current stack frame while
\qVerb{fp} points to 16 bytes\footnote{Assuming the \TODO{RV64I} extension is used.} above the top of the current frame.
The available space for functions therefore ranges from \qVerb{-24(fp)} to \qVerb{0(sp)}.
It is used for storing variables, following the alignment rules that were explained in Section~\ref{sec:alignment}.
In the space between \qVerb{0(fp)} and \qVerb{-24(fp)}, the frame pointer of the previous stack frame and the return address are saved at the positions \qVerb{-8(fp)} and \qVerb{-16(fp)}, respectively.
If stack arguments were present, they would be placed upwards of \qVerb{fp}.
Each stack argument \emph{always} uses eight bytes of memory, regardless of the actual size of its content.
Thus, the $n$\textsuperscript{th} stack argument would be placed at the position $8n$\texttt{(fp)}.
To keep track of variable locations on the stack, the compiler maps a variable's name to a memory location.
To be precise, the compiler contains a \qVerb{HashMap} which associates a variable's name with its \qVerb{fp} offset.
When the variable is referenced at a later point, the compiler performs a simple lookup of the variable's memory address.

\subsection{Calling Convention}\label{sec:riscv_calling_conv}

Just like previously explained, most architectures provide a calling convention which dictates how low-level function calls should be managed.
For most architectures, the calling convention is part of the ISA's official specification.
In the case of \riscv{}, the calling convention consists of four main steps and is specified in a separate document~\cite{RiscvABI2022}.

The first step of calling a function involves placing the arguments in a place where the function can access them.
For \riscv{}, this involves placing the arguments into certain registers.
Like described in Table~\ref{tbl:riscv_regs}, only some registers are used for call arguments.
For integer arguments, the first eight arguments are placed in the registers \qVerb{a0}--\qVerb{a7}
For instance, the first two arguments of the rush function call
\qVerb{foo(40, 2, 3.14)} would be placed in the registers \qVerb{a0} and \qVerb{a1}, respectively.
However, the third argument is a floating-point number and can therefore not be placed inside an integer register.
Instead, the first floating-point argument register \qVerb{fa0} is used.
In this case, all arguments can be held in registers and spilling would not be required.

In case the function accepted nine or more integer arguments,
all further integer arguments starting with the ninth one would have to be spilled onto the stack.
Here, the successive registers \qVerb{a0}--\qVerb{a7} would contain the first eight integer arguments of the called function.
However, the argument at position nine is spilled onto the stack since there are no registers left which could contain the additional argument~\cite[p.~8]{RiscvABI2022}.

In the second step, the underlying procedure call is made using a specialized instruction.
In \riscv{} assembly, one typically uses the \qVerb{call} \emph{pseudoinstruction}\footnote{A macro generating one or more instructions from one pseudoinstruction. This way, the actual count of ISA instructions remains low while convenience features can be used in assembly~\cite[p.~68]{Dandamudi2005}.}.
The instruction uses the name of its target label as its operand, resulting in labels being callable, just like functions.
Internally, the instruction first saves the address of the following instruction in the \qVerb{ra} register, and then performs an unconditional jump~\cite[p.~22]{Patterson2017}.

The third step takes place in the function's prologue.
Here, the previous frame pointer and return address are saved on the stack,
and space for storing local variables is allocated by decrementing the stack pointer.
Following the prologue, the function's body is executed.
After it has also been evaluated, the epilogue restores the changes made by the prologue.
The previous values for both the frame pointer and the return address registers are taken from the stack,
and the stack pointer is incremented back to its original value.
The \qVerb{ret} instruction, which jumps to the address stored in \qVerb{ra}, is finally used to return control back to the caller.

In case a function returns a value, it must be mad accessible to the caller.
For integer types, the first return value of a function is placed in the register \qVerb{a0}
while floating-point numbers are placed in the register \qVerb{fa0}.
This way, the caller code can obtain a function's return value by accessing the \qVerb{a0} and \qVerb{fa0}
registers respectively. If a function does not return a value, these steps are just omitted.
It is to be mentioned that char and bool values are also placed inside the \qVerb{a0} register since these types are internally represented by integers.

\subsection{The Core Library}

As outlined in the section about the linker on page~\pageref{sec:linker},
a program might use functionality provided by external libraries.
In case of the rush \riscv{} compiler, external functions are used for character-arithmetic,
the mathematical power operator, and the system \emph{exit} call.
Character-arithmetic requires external functionality since the bounds of the ASCII range should be regarded while performing operations.
For instance, in rush, calculating \qVerb{'a'+'a'} results in `66' because `194' ($97 + 97$) is larger than the maximum allowed value `127'.
If the result is outside the valid range $\left[0; 127\right]$, only the least significant seven bits are considered.
This way, the ASCII range is always valid.

Since these concepts must introduce additional logic, the compiler should not be emitted their instructions every time they are used.
In that case, the repeated emission of redundant instructions would result in enlarged and unnecessary complex output code.
In order to mitigate these issues, the compiler simply inserts call-instructions referencing the appropriate external function.
External functions are called just like any other function; however, their definition is not found in the same assembly file.
As described previously, resolving these external calls is later handled by the linker.
This target-specific libary code is later refered to by the term \emph{corelib}.

For instance, a function for mathematical power operations is implemented in the corelib.
Therefore, the compiler can emit a procedure call to this method every time rush's \qVerb{**} operator is used in the source program.
For this project, the entire corelib is written in \riscv{} assembly.
However, it is also reasonable to implement a corelib using a high-level language like C.
Since the corelib's functions are specified in separate files, they are packaged into an \emph{archive file} which is later used by the linker.
The assembly code in Listing~\ref{lst:riscv_exit_corelib} shows the implementation of the \qVerb{exit} subroutine in the \riscv{} corelib.
The task of this subroutine is to invoke a specific functionality of the Linux kernel by performing a \emph{system call}.

\Lirsting[float=H, ranges={8-12}, caption={The assembly implementation of the \qVerb{exit} subroutine.}, label={lst:riscv_exit_corelib}]{deps/rush/crates/rush-compiler-risc-v/corelib/src/exit.s}

A \emph{system call} (often abbreviated to \emph{syscall}) is an invocation of a function of operating system's kernel.
In Linux, more than 90 percent of the available system calls are implemented on all architectures~\cite[p.~3]{Love2013}.
One common system call is \qVerb{exit}.
It terminates the current process and performs various cleanup steps.
Its only parameter is the \emph{exit code} which can be checked by the shell or other programs~\cite[p.~148]{Love2013}.
In \riscv{} Linux, the syscall id of \qVerb{exit} is `93`~\cite{Torvalds1991}.
In line~8 of Listing~\ref{lst:riscv_exit_corelib}, the \qVerb{exit} label is declared as global using the \qVerb{.global} directive.
Next, the \qVerb{exit} label is declared in line~10.
In line~11, the \qVerb{li} instruction is used in order to load `93` into the register \qVerb{a7}.
On \riscv{} Linux systems, the content of the \qVerb{a7} register specifies the type of syscall to be performed.
In line~12, the \qVerb{ecall} instruction is then used to perform the underlying syscall~\cite[p.~23]{Patterson2017}

\subsection{\riscv{} Assembly}

\Lirsting[wrap=o, fancyvrb={numbers=\OuterEdge}, wrap width=0.35\textwidth, caption={Example rush program containing two functions.}, label={lst:riscv_simple2}]{listings/riscv_simple.rush}

The Listing~\ref{lst:riscv_simple2} shows a rush program containing two functions and a global variable.
In line~1 of the rush program, the mutable global variable \qVerb{m} is defined with an initial value of `42'.
In line~4, in the \qVerb{main} function, \qVerb{m} is incremented by `1'.
Next, in line~5, the \qVerb{foo} function is called using \qVerb{m} as the only call argument.
In line~6, a \qVerb{return} statement is used to terminate the \qVerb{main} function explicitly.
The body of the \qVerb{foo} function only contains a call to the \qVerb{exit} function and therefore causes the program to exit with the code stored in \qVerb{n}.
When executed, the exit code of the displayed program will be `43'.
The code in Listing~\ref{lst:riscv_simple_asm} shows the output assembly generated from this program by the rush \riscv{} compiler\footnote{Generated using rush (Git commit \rushCommit{}).}.
The assembler code of the \qVerb{foo} function is intentionally omitted.

In line~1, the \qVerb{.global} assembler directive is used to declare the global symbol \qVerb{_start}~\cite[p.~36]{Patterson2017}.
On most architectures, the \qVerb{_start} label indicates a program's entry point, marking the first instruction to be executed~\cite[p.~19]{Zhirkov2017-wk}.
In line~6, the \qVerb{call} instruction is used to call the \qVerb{main..main} function.
Here, the already familiar \qVerb{main} function is prepended by the prefix \qVerb{main..}.
Since this rush compiler implements name mangling\footnote{Compilers often \emph{mangle} names in order to guarantee a unique name for every function~\cite[pp.~119-120]{Levine2000}.},
every function declared in a rush program will contain this prefix.

\Lirsting[wrap=o, fancyvrb={numbers=\OuterEdge}, wrap width=0.4\textwidth, caption={Compiler output from the rush program in Listing~\ref{lst:riscv_simple2}.}, ranges={1-31, -4 53-56}]{listings/generated/riscv_simple.s}

In line~7, the \qVerb{li} (\enquote{\textbf{l}oad \textbf{i}mmediate}) instruction is used to load the constant integer `0' into the register \qVerb{a0}~\cite[Reference Card]{Patterson2017}.
As explained in the previous section, the register \qVerb{a0} is used for the first integer call argument.
In line~8, the \qVerb{exit} function from rush's corelib is called, using `0' stored in \qVerb{a0} as the exit code.
Therefore, the two instructions in the lines~7--8 are responsible for terminating the program with the exit code `0'.
They are always inserted at the end of the \qVerb{_start} label in order to terminate the program appropriately in case the rush code does not call \qVerb{exit} on its own\footnote{In order to prevent runtime errors, programs should always be exited properly.}.

Due to the function call in line~6, the \qVerb{main..main} label in line~10 should now be considered.
In line~11, the first line of the \qVerb{main} function, a comment indicates the beginning of the function's prologue.
The \qVerb{addi} (\enquote{\textbf{a}dd \textbf{i}mmediate}) instruction in line~12 adds `$-16$' to the value stored in \qVerb{sp}, thus allocating memory.
Therefore, this instruction increases the size of the stack, thus allocating memory.
Here, an addition instruction is used even though subtraction is required.
In \riscv{}, the \qVerb{addi} instruction requires one destination, one source register and one immediate value as its operands.
Since this immediate value can be negative, an additional instruction for immediate subtraction would be redundant~\cite[Reference Card]{Patterson2017}.
In this case, 16 bytes are allocated since two 8-byte values are stored on the stack in the lines 13--14.

The comment in line~17 indicates the start of the function's body.
First, the previously explained \qVerb{li} instruction in line~18 places a constant `1' in register \qVerb{a0}.
Next, the \qVerb{ld} instruction in line 19 is used in order to load the value of the global variable \qVerb{m} into the register \qVerb{a1}~\cite[Reference Card]{Patterson2017}.
Global variables, like \qVerb{m} in this example, are saved under the \qVerb{.rodata} or the \qVerb{.data} section, depending on their mutability.
Since \qVerb{m} is declared as mutable, the compiler saves it under the \qVerb{.rodata} section.
The start of the \qVerb{.rodata} section is represented by the \qVerb{.section} assembler directive found in line 53.
Here, a label called \qVerb{m} is defined.
In this label, the \qVerb{.dword} directive is used to define the global initializer value of the variable.
In \riscv{}, this directive stores 64 bit of information in successive memory doublewords~\cite[p.~39]{Patterson2017}.
The initializer value of the global variable is 42 and is represented as \qVerb{0x2a} using hexadecimal in the assembly code.
Since these data labels require their contents to be specified in hexadecimal, the trailing comment shows the base 10, human-readable version of the number.
Because global variable are not saved on the stack, special instructions like \qVerb{ld} are required to interact with global variables stored in the program's data sections.

At this point, the register \qVerb{a0} would contain 1 and \qVerb{a1} would contain 42.
In line 20, the \qVerb{add} instruction is used in order to save the sum of \qVerb{a0} and \qVerb{a1} in the register \qVerb{a2}.
Now, the value saved in \qVerb{a2} would be 43.
Next, the \qVerb{sd} instruction in line 21 saves the value of the register \qVerb{a2} at the memory location of the global variable \qVerb{m}, meaning that \qVerb{m} is updated to reflect its new value 43.
It now becomes apparent that these instructions are responsible for the add-assign expression in line 4 of the rush program.
Another interesting observation is that the last operand of the \qVerb{sd} instruction specifies the temporary register \qVerb{t6}.
The instruction uses this register for saving temporary data during the process of saving data in \qVerb{m}~\cite[Reference Card]{Patterson2017}.

In line 22, the previously explained \qVerb{ld} instruction is used in order to load the value of the same variable into the register \qVerb{a0}.
Then, the \qVerb{call} instruction in line 23 is used in order to call the \qVerb{foo} function using the value of m as its argument.
However, one cannot easily observe how call arguments are passed here.
Like explained previously, the first integer argument of a function call must be placed in the register \qVerb{a0}.
Since \qVerb{m} was loaded into \qVerb{a0} previously, it will be used as the call argument for \qVerb{foo} automatically.
Therefore, the \qVerb{foo} function is called using 43 as the first argument.

Since the \qVerb{foo} instruction only calls the \qVerb{exit} function, its explanation will not be beneficial for introducing new concepts.
Therefore, we will omit the explanation of the assembler output of the \qVerb{foo} function.
The final instruction of the \qVerb{main} function's body is the \qVerb{j} instruction in line 24.
This instruction will cause the CPU to jump to the address of the specified label.
In this example, the CPU will jump to the first instruction of the \qVerb{epilogue_0} label~\cite[p.~17]{Patterson2017}.
Therefore, the rush compiler uses the \qVerb{call} instruction for jumps caused by function calls and the \qVerb{j} instruction for jumps between blocks of the current function.

Like explained previously, every function has a \emph{prologue} and an \emph{epilogue}.
Since one of the tasks handled by the epilogue is releasing resources allocated by the prologue, the function's stack pointer is incremented in line 30.
Finally, the \qVerb{ret} instruction in line 31 is used in order to jump back to the instruction whose address is specified in the \qVerb{ra} register~\cite[reference card]{Patterson2017}.

\subsection{Supporting Pointers}

In Section~\ref{sec:pointers}, we have explained how pointers can be used in rush.
Since every rush backend should support all features of the language, pointers also need to be implemented for the \riscv{} architecture.
In order to get a rough understanding of how pointers work in this compiler, the code in Listing~\ref{lst:rush_simple_pointer} and~\ref{lst:rush_simple_pointer_asm} are to be considered.

\begin{minipage}{.34\textwidth}
	\center
	\Lirsting[float=H, fancyvrb={frame=none}, caption={Example rush program containing a pointer.}, label={lst:rush_simple_pointer}]{listings/rush_simple_pointer.rush}
\end{minipage}%
\hspace{3cm}
\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[float=H, fancyvrb={frame=none}, ranges={10-10,18-24}, caption={\riscv{} assembly output generated from Listing~\ref{lst:rush_simple_pointer}.}, label={lst:rush_simple_pointer_asm}]{listings/generated/riscv_rush_simple_pointer.s}
\end{minipage}


The code in Listing~\ref{lst:rush_simple_pointer} shows a rush program in which a variable is referenced to create a pointer which is then dereferenced.
In line 2, the mutable variable \qVerb{a} is defined using an initial value of 42.
Next, in line 3, the variable is referenced in order to use the resulting address to define the variable \qVerb{to_a}.
In line 4, the \qVerb{to_a} pointer variable is dereferenced in order to use the value of \qVerb{a} as the exit code of the program.


Listing~\ref{lst:rush_simple_pointer_asm} includes the most significant part of the compiler output which represents this rush program\footnote{Generated using rush (Git commit \rushCommit{}).}.
In line 18 of this listing, the integer value 42 is placed in the register \qVerb{a0}.
Next, \qVerb{a0} is saved on the stack at \qVerb{-24(fp)} using the \qVerb{sd} instruction.
Like the comment suggests, the instruction in line 20 is used in order to reference a.
Here, the \qVerb{addi} instruction is used to subtract 24 from the value stored in the \qVerb{fp} register.
The result of this subtraction is saved in the register \qVerb{a0}.
Therefore, the register now contains the absolute memory address of the \qVerb{a} variable.
Since the syntax \qVerb{-24(fp)} means that the variable is saved at $fp - 24$, the subtraction uses the exact same information which is already known about the variable.
Here, instead of using the saved memory location of the variable like \qVerb{x(fp)}, the information is used in order to calculate the absolute address of the target variable.
This computation can only be performed at runtime since the value of \qVerb{fp} is not known at compile time.
In line 21, the \qVerb{a0} register which contains the memory address is also saved on the stack.
Therefore, the \qVerb{a} variable is saved at \qVerb{-24(fp)} while \qVerb{to_a} is saved at \qVerb{-32(fp)}.

In order to access the value of \qVerb{a}, \qVerb{to_a} is dereferenced in line 4 of the rush program.
For this, the memory address stored in the variable \qVerb{to_a} first needs to be loaded from the stack.
Here, the \qVerb{ld} instruction in line 22 of the assembly output is used.
The instruction will load the memory address stored at \qVerb{-32(fp)} (in \qVerb{to_a}) into the \qVerb{a0} register.
Next, another \qVerb{ld} instruction in line 23 is used in order to load the value of the variable saved at the previously fetched memory address.
What strikes the eye is that \qVerb{0(a0)} instead of \qVerb{x(fp)} is used for specifying the target memory address of the load instruction.
In this case, \qVerb{0(a0)} means that the instruction should load its value from the address saved in \qVerb{a0} with an offset of 0.
Since an offset of 0 is used, the practical description of the instruction is that it loads a value saved at the memory address specified in \qVerb{a0}.
Because \qVerb{a0} contains the memory address of the \qVerb{a} variable, the instruction loads 42 into the \qVerb{a0} register.

\subsection{Implementation: The rush compiler targeting \riscv{} assembly}

Just like the other compilers presented in this paper, this one also traverses the annotated AST using the postorder technique.
Unlike the LLVM or WASM compiler, this compiler emits \riscv{} assembly files which are later assembled by the assembler.

\subsubsection{Struct Fields}

Before any complex code samples can be considered, important struct fields of the compiler first need to be explained.
The Rust code in Listing~\ref{lst:riscv_compiler_attr} shows important struct fields of the rush compiler targeting \riscv{}.

\Lirsting[ranges={11-11,15-15,19-34}, caption={Fields of the \riscv{} \qVerb{Compiler} struct.}, label={lst:riscv_compiler_attr}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

In line 15, the field \qVerb{blocks} is declared.
This field holds a vector containing values of the type \qVerb{Block}.
That type provides an abstraction representing a label with its basic block in the assembly output.
Therefore, this struct needs to contain a string field for its label and a vector for its instructions.
The Listing~\ref{lst:riscv_instruction_enum} shows parts of the Rust code which declares the \qVerb{Instruction} enum.

\Lirsting[ranges={62-62,74-76,114-114}, caption={The \qVerb{Instruction} enum in the \riscv{} compiler.}, label={lst:riscv_instruction_enum}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/instruction.rs}

Although the listing shows only a few of the implemented instructions, this enum contains all instruction variants which the compiler might need at a later point.
Depending on the type of instruction, the corresponding enum includes fields which define its operands.
For instance, the \qVerb{Li} variant in line 74 represents the \qVerb{li} instruction in assembly.
This instruction loads the immediate integer value specified in the second operand into the register specified in the first operand.
Due to this, the enum also contains a field for a value of the type \qVerb{IntRegister} and a field for a 64-bit signed integer.
The Rust code in Listing~\ref{lst:riscv_intregister_enum} shows parts of the declaration of the \qVerb{IntRegister} enum.
Like the name implies, this enum holds all possible registers which the architecture provides.

\Lirsting[ranges={107-107,137-139,145-145}, caption={The \qVerb{IntRegister} enum in the \riscv{} compiler.}, label={lst:riscv_intregister_enum}, float=H]{deps/rush/crates/rush-compiler-risc-v/src/register.rs}

Even though just the integer registers are shown in this listing, a similar enum for floating-point registers also exists in this implementation.
Another important struct field is declared in line 19 of Listing~\ref{lst:riscv_compiler_attr}.
The \qVerb{curr_block} field saves the index of the basic block which is currently being inserted to.
Next, the \qVerb{data_section} and \qVerb{rodata_section} fields in line 21 and 22 are declared.
Just like the ELF sections, these vectors contain declarations of global variables in the program.
Here, each vector holds items of the type \qVerb{DataObj}.
Since this type specifies data which should be saved in these sections, it contains a string field for the label and an enum field for the actual data saved in the object.
For instance, if the compiler encounters a global variable declaration, a new data object is inserted into the correct section, depending on whether the global variable has been declared as mutable or not.

In line 25, the \qVerb{curr_fn} field is declared.
This field saves a value of the type \qVerb{Function}.
The \qVerb{Function} struct contains a counter of the stack allocations of the current function in bytes and the label of the epilogue block of the current function.
The former is incremented every time a variable declaration is compiled.
This is required in order to allocate the correct amount of stack memory during a function's prologue.

Just like in the other compilers, this one also features a \qVerb{loops} field which saves important labels of the current loop being compiled.
This field is declared in line 27 and holds a vector of \qVerb{Loop} structs.
Each \qVerb{Loop} struct saves the label of the loop's head and the label of the basic block which follows after the loop's body.

Furthermore, the \qVerb{scopes} field in line 29 is managed to associate a variable to some important metadata.
This metadata includes the variables type and its \emph{stack memory position}.
Just like explained in the previous sections, each cell of the stack memory is accessible by specifying a unique index.
The compiler saves this unique index in this HashMap so that it can refer back to the variable later.
Of course, this only works for variables which are saved on the stack.
However, these HashMaps are not used for saving global variables.
Instead, the \qVerb{globals} field in line 31 is used.
Just like the HashMaps in the \qVerb{scopes} field, this map also associates a variable's name to a value of the type \qVerb{Variable}.
This time however, each variable contains the data label under which the global variable was declared.
Last, the \qVerb{used_registers} field in line 33 is declared.
It plays a vital role in the compiler's register allocation algorithm.

By only considering the compiler's struct fields, it has become apparent that this implementation provides several abstractions over the bare strings in which assembly is normally formatted.
Due to this, implementation of the actual compiler is a lot more structured and reliable.
During development of the compiler, this approach has often proven itself to be optimal.

\subsubsection{Data Flow and Register Allocation}

An important characteristic of a compiler is how it represents runtime data at compile time.
In assembly, runtime data is represented by registers which will contain values at runtime.
Since this rush compiler emits \riscv{} assembly, it also represents data by using registers internally.
In the previous paragraphs, we have learned how this implementation uses abstractions in order to represent assembly constructs, including registers.

For reference, the LLVM compiler represents runtime values by passing virtual registers internally.
Similarly, this compiler also passes abstractions representing registers in order to represent the data flow of the program being compiled.
Unlike in LLVM, there is only a finite amount of registers available.
Therefore, this compiler also manages register allocation so that programs can be represented using this limited number of registers.
In under to understand the implementation, the code in Listing~\ref{lst:rush_riscv_simple_sum} and Listing~\ref{lst:rush_riscv_simple_sum} is to be considered.
The former listing contains a rush program which adds two integer variables together in order to use the result as its exit code.
The latter shows parts of the assembly output representing the logic in the \qVerb{main} function.

\begin{minipage}{.34\textwidth}
	\center
	\Lirsting[caption={A rush program calculating the sum of integers.}, label={lst:rush_riscv_simple_sum}, float=H]{listings/simple_add.rush}
\end{minipage}%
\hspace{3cm}
\begin{minipage}{.45\textwidth}
	\center
	\Lirsting[ranges={18-25},caption={Assembly output of the rush program in Listing~\ref{lst:rush_riscv_simple_sum}.}, label={lst:asm_riscv_simple_sum}, float=H]{listings/generated/rush_simple_add.s}
\end{minipage}

In the lines 2 and 3 of the rush program, the integer variables \qVerb{a} and \qVerb{b} are declared.
In line 4, the \qVerb{exit} function is invoked, using the sum of these variables as the call argument.

In the line 22 of the assembly output, the runtime value of the \qVerb{a} variable is loaded into the register \qVerb{a0}.
Next, the same operation is performed for the \qVerb{b} variable.
However, this time, the instruction writes its result in the \qVerb{a1} register instead of the \qVerb{a0} register.
This is because the previously loaded value in \qVerb{a0} would be overwritten if this was the case.
Since both the value of the variable \qVerb{a} and \qVerb{b} are required for the addition, overwriting this register would result in a wrong calculation.
This is an example of how register allocation is required in order to manage registers and to prevent such bugs.

Unlike the register allocation algorithm of a production ready compiler like LLVM, this one only aims to use registers without causing conflicts like the previously explained one.
Therefore, this algorithm does not emphasize performance and instead only performs mandatory task which are required for making a program work.
For instance, all variables are saved on the stack in order to keep all registers unused and free for use in temporary calculations and operations like this one.
Since this algorithm only performs rudimentary register allocation, its implementation is also significantly easier.

The core principle of the register allocator is that each method which can return a register decides which register it returns itself.
In order to choose an output register, each of those methods uses the helper method \qVerb{get_int_reg}.
The Rust code in Listing~\ref{lst:riscv_get_int_reg} shows the \qVerb{get_int_reg} method of the \riscv{} rush compiler.

\Lirsting[ranges={175-186}, float=h, label={lst:riscv_get_int_reg}, caption={The \qVerb{get_int_reg} method of the \riscv{} rush compiler.}]{deps/rush/crates/rush-compiler-risc-v/src/utils.rs}

This method returns the first available register from the register pool containing either integer registers\footnote{The \enquote{i} in \qVerb{get_int_reg} hints that it allocates integer registers}.
Such a register pool contains all possible registers which can hold the data type of that class of registers.
This compiler contains two pools: one for integer registers and one for floating-point registers.
In line 175 of Listing~\ref{lst:riscv_get_int_reg}, the signature of the method is shown.
Here, one can see that the method returns a value of type \qVerb{IntRegister}.
The for-loop in line 176 is used to itrate through the entire \qVerb{INT_REGISTERS} array.
This array is constant and therefore represents the pool containing integer registers.
In the lines 177--180, the if-expression checks if the current register (\qVerb{reg}) is not found in the \qVerb{used_registers} vector.
If this was the case, the current register would be unused and could therefore be returned.
Since the \qVerb{return} statement in line 182 returns the current register if it is unused, the loop only runs until a free register has been found.
Due to the passive nature of the register allocation algorithm used in this compiler, the unreachable-macro in line 185 should never be called since the compiler should not run out of registers.
However, one can see that this method does not mark the newly returned register as used.
This is because marking a register as used is only required in some sections of the compiler where overwriting a register would introduce a bug in the output program.
Therefore, if this method was to be called repeatedly without calls to other methods, it would always yield the same result register.

In order to mark a register as used, it is simply pushed into the \qVerb{used_registers} vector.
For this, a helper method called \qVerb{use_reg} which only performs this simple call is implemented.
Due to the simplicity of this method, a listing of its code is intentionally omitted.
If a register is no longer used and can be overwritten again, it is also simply removed from the \qVerb{used_registers} vector.
For this, another simple helper method called \qVerb{release_reg} is implemented.
Just like the previous method, its implementation is so simple that a code listing is omitted.

\begin{figure}
	\centering
	\begin{tikzpicture}
		\node(stack)[stack=6, rectangle split part align=center,
			rectangle split part fill={gray!20, gray!20, none, none, none, none},
			text width=10ex, text centered, inner xsep=0]{
			\shortstack{used\\\\\texttt{a0}}
			\nodepart{two}{\shortstack{used\\\\\texttt{a1}}}
			\nodepart{three}{\shortstack{unused\\\\\texttt{a2}}}
			\nodepart{four}{\ldots}
			\nodepart{five}{\shortstack{unused\\\\\texttt{a7}}}
			\nodepart{six}{\ldots}
		};
		\node(ff)[below of=stack, yshift=-.5cm] {\scriptsize first free cell};
		\draw[arrow, shorten >= 4pt](ff) -- (stack.three south);
	\end{tikzpicture}
	\caption{Integer register pool of the \riscv{} rush compiler.}\label{fig:riscv_iregister_pool}
\end{figure}

Figure~\ref{fig:riscv_iregister_pool} shows an abstract representation of the compiler's integer register pool.
Here, the pool contains all integer registers of the compiler.
In this figure, only the first section of the pool which contains the \qVerb{ax} registers can be seen.
The gray cells at the beginning indicate that these registers are currently in use by the compiler.
Of course, this information is not saved in the register pool since the \qVerb{used_registers} vector saves this data.
In the figure, the arrow points to the first free register, meaning the one which follows the last used register \qVerb{a1}.
Therefore, if the \qVerb{get_int_reg} method was called when the state of the registers is equivalent to the one displayed in Figure~\ref{fig:riscv_iregister_pool}, it would return the register \qVerb{a2}.
By considering this example, it has become apparent that the method always returns the first free integer register.
In the compiler, an equivalent pool for float registers also exists.

Before register allocation can be explained using code samples, how registers are passed around in the compiler needs to be explained first.
Here, we should focus on the compilation of simple expressions.
For this, the Rust code in Listing~\ref{lst:riscv_expression} is to be considered.

\Lirsting[float=h, ranges={596-602,662-663}, caption={Parts of the \qVerb{expression} method in the \riscv{} rush compiler.}, label={lst:riscv_expression}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

The code in Listing~\ref{lst:riscv_expression} shows parts of the \qVerb{expression} method.
This method is responsible for compiling expressions in the \riscv{} rush compiler.
As the method's signature suggests, it takes a node representing an analyzed expression.
This method returns an \qVerb{Option<Register>} which is \qVerb{None} if the infix-expression contained a call to the \qVerb{exit} function.
Otherwise, the method returns the register in which the result of its computation will be contained at runtime.
The code in the lines 598-602 is executed if a constant integer expression is compiled.
First, a target integer register is allocated by calling the previously shown \qVerb{get_int_reg} method.
Now, the \qVerb{dest_reg} variable contains the register which will contain the result of the expression.
Next, an \qVerb{li} instruction is inserted.
At runtime, this instruction would load the constant integer contained in the variable \qVerb{value} into the register specified \qVerb{dest_reg}.
Finally, the register which now contains the loaded value is returned.
For more complex expressions, the corresponding methods are called, just like in the other compilers.
Now it has become apparent how basic expressions work and how registers are used to hold values.

However, we still do not know when the compiler marks certain registers as used.
In order to understand this problem, the compilation of the rush expression \LirstInline{rush}{n + m} is to be considered.
The Rust code in Listing~\ref{lst:riscv_infix_expr} shows parts of the \qVerb{infix_expr} method of the rush compiler.

\Lirsting[float=h, ranges={761-761,849-864,868-868}, caption={Parts of the \qVerb{infix_expr} method in the \riscv{} rush compiler.}, label={lst:riscv_infix_expr}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

Like the signature of the method suggests, it consumes an annotated tree-node representing an analyzed infix-expression.
In line 853, the left-hand side expression is compiled, and its result register is saved in the variable \qVerb{lhs_reg}.
Next, in line 854, the previously discussed \qVerb{use_reg} method is used in order to mark the previously allocated register as used.
The second argument to the method specifies the size of the data which the register holds, 64 bits for integers or 8 bits for characters for instance.
This information is also saved in the \qVerb{used_registers} vector and is used in case used registers need to be spilled.
In line 856, the right-hand side is expression is compiled, and its result register is saved in the variable \qVerb{rhs_reg}.
After this, the register returned by the compilation of the left-hand side is marked as unused again.
Finally, in line 861, the \qVerb{infix_helper} method is called in order to insert the instruction for the actual calculation.

However, the reason the left-hand side register is being marked as used is not immediately apparent.
As discussed previously, calling the methods responsible for allocating registers, like \qVerb{get_int_reg},
repeatedly without marking registers as used results in the allocator method returning the same register.
In this scenario, this would create an issue since both the left-hand side and the right-hand side would result in the identical register, \qVerb{a0} for instance.
Now, the compilation of the right-hand side expression would overwrite the value stored in the register of the left-hand expression, thus creating invalid output code.
In order to mitigate this issue, the register of the left-hand side is marked as used as seen in Listing~\ref{lst:riscv_infix_expr}.
Therefore, the allocator call caused by the compilation of the right-hand side will respect that the register returned by the left-hand side is currently in use and will therefore return the next one.

Next, we will consider the implementation of the \qVerb{infix_helper} helper method.
This method exists since translation of infix operators is required during compilation of both normal infix-expressions and assign-expressions with additional operations, \qVerb{a += 1} for instance.
The Rust code in Listing~\ref{lst:riscv_infix_helper} shows parts of this method.

\Lirsting[float=h, ranges={871-871,874-881,987-991,1000-1001}, caption={Parts of the \qVerb{infix_helper} method of the \riscv{} rush compiler.}, label={lst:riscv_infix_helper}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

As the method's signature suggests, the left-hand and right-hand side's registers and a type are used its parameters.
Since this register abstraction does not contain type information, as registers are usually untyped, the type information conveys the type of either the left-hand or right-hand side expression.
In case of infix-expressions, which side the type specifies is irrelevant since the analyzer demands that both are identical.
Here, the type information is required order to insert the correct instruction.

In line 874 and 875, an integer and a floating-point output register is allocated.
These registers are saved in a variable for each type, \qVerb{dest_regi} for integers for instance.
Of course, only one of these registers is later used.
However, both are allocated in order to avoid code duplication.
In line 878-881, the code responsible for inserting an integer addition instruction can be seen.
For this, the \qVerb{self.insert} helper method is used.
This inserts a new instruction into the current basic block.
Due to its simplicity its explanation will be omitted.
Here, the \qVerb{Instruction::Add} enum variant is used.
Since the first operand specifies the output reqister, the previously \qVerb{dest_regi} variable is specified.
For the first and second operands, the registers provided as arguments to the \qVerb{infix_helper} method are used.
The \qVerb{Add} enum can only use integer registers, like \qVerb{a0} as its operands.
However, the parameters \qVerb{lhs} and \qVerb{rhs} can be registers of any type.
For this, the conversion method \qVerb{into} is used.
In line 987--990, the code for inserting the float subtraction instruction can be seen.
Since floating-point operations usually require different operators from the one used for integer operations,
it becomes apparent why type information is passed to this method.
Here, the \qVerb{fsub} instruction enum variant is used to represent the addition of floating-point numbers.
In this case, the variable \qVerb{dest_regf} is used as the first operand since it can hold floating-point numbers.

\subsubsection{Functions}

However, before the infix-expression in Listing~\ref{lst:rush_riscv_simple_sum} is compiled,
the compiler considers the functions of the program.
In this case, only the \qVerb{main} function is present.
The Rust code in Listing~\ref{lst:riscv_declare_main_fn} shows the \qVerb{declare_main_fn} method of the rush \riscv{} compiler.

\Lirsting[float=h, ranges={123-156}, caption={The \qVerb{declare_main_fn} method of the \riscv{} rush compiler.}, label={lst:riscv_declare_main_fn}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

Like its signature suggests, the method takes a block, meaning a list of statements as its input.
In the lines 124--126, the \qVerb{_start} label is created and marked as exported so that the linker will later find it.
After this insertion, the \qVerb{curr_block} index is 0, meaning that the block in which is inserted to is the one of the \qVerb{_start} label.

In the lines 128--129, a new block with the \qVerb{main..main} label is created.
As explained previously, this block represents the start of the body of the \qVerb{main} function in rush.
Next, the line 132 inserts a \qVerb{call} instruction which is responsible for calling the \qVerb{main} function when the program is executed.
In the lines 134--135, instructions for calling the \qVerb{exit} function using 0 as the exit code are inserted.
These two instructions are necessary in order to prevent a segmentation fault at the end of the program.

In the lines 137--139, a new epilogue label is generated.
Then, the current function is updated so that it contains this newly created epilogue label.
However, this label is not directly added to the \qVerb{blocks}  vector since it should ideally appear after the body of the function.

Next, in the lines 142--145, the \qVerb{main} function's body is compiled.
For this, the current insertion position is first updated to the end of the previously created \qVerb{main..main} block by using the helper method \qVerb{insert_at} in line 142.
In line 143, a new variable scope is added for the function's body.
Then, the function's body is compiled by calling the \qVerb{function_body} method in line 144.
After the body's compilation, the previously added scope is removed again in line 145.

Now, the code responsible for inserting the prologue is executed.
The prologue is inserted after the function's body even though it introduces each function.
Since the required memory of the function is not known before the function's body is compiled,
no stack space can be allocated before the body of the functions was traversed.
In order to mitigate this issue, the code responsible for a function's prologue is generated after the entire function body has been traversed.

The call to the method \qVerb{prologue} in line 148 generates the instructions which represent the prologue.
Next, in line 149, the insertion position is moved back to the end of the \qVerb{main..main} label.
In line 150, the instructions generated from the function's body are concatenated to the end of prologue instructions.
This way, the variable \qVerb{prologue} now represents a vector containing the instructions of the \qVerb{main} function's prologue followed by the ones of its body.
In line 151, the instructions of the current block, meaning the \qVerb{main..main} block, are overwritten with the contents of the variable.
In other words, the current block now contains the function's prologue and body.

In the lines 152--155, the code responsible for inserting the trailing epilogue code can be seen.
For this, in line 153, the previously created epilogue label is now appended to the \qVerb{blocks} vector.
In line 154, the \qVerb{epilogue} method of the compiler is callled.
The Rust code in Listing~\ref{lst:riscv_epilogue} shows the \qVerb{epilogue} method of the rush \riscv{} compiler.

\Lirsting[float=h, ranges={66-87}, caption={The \qVerb{epilogue} method of the \riscv{} rush compiler.}, label={lst:riscv_epilogue}]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

As the context of the previous code snipped suggests, this method is called in order to generate the instructions for a function's epilogue.
First, in the lines 67--68, the insertion position of the compiler is updated to the end of the epilogue label.
This is done since the epilogue must exist in a separate label in order to be reused when \qVerb{return} statements are encontered.
The instruction insertion in line 70 is responsible for a \qVerb{ld} instruction.
As described previously, this particular instruction restores the previously saved \qVerb{fp} register.
Next, in line 75, another \qVerb{ld} instruction for restoring the \qVerb{ra} register is inserted.
In line 80, an \qVerb{addi} instruction is inserted in order to restore the previously allocated stack space.
Finally, a \qVerb{ret} instruction is inserted which is responsible for transferring control back to the caller.
Now it becomes apparent that the inserted instructions resemble the already known patters observed in previously shown listings.

As for the code in Listing~\ref{lst:riscv_declare_main_fn},
the presented method is very similar to the one which translates other rush functions.
However, the \qVerb{function_declaration} method which is responsible for other functions differs in two ways.
First, it contains code which handles function parameters.
Second, the special instructions for calling to the \qVerb{main} and \qVerb{exi} functions are not required for other functions.

\subsubsection{Let Statements}

In line 2 and 3 of the rush program in Listing~\ref{lst:rush_riscv_simple_sum}, let statements are used in order to save values on the stack.
For this, the rush \riscv{} compiler implements a separate method named \qVerb{let_statement}.
The Rust code in Listing~\ref{lst:riscv_let_stmt} shows the \qVerb{let_statement} method of the rush \riscv{} compiler.

\Lirsting[float=h, ranges={554-561}, caption={The \qVerb{let_statement} method of the \riscv{} rush compiler.}, label={lst:riscv_let_stmt}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

This method only calls the \qVerb{save_expr_on_stack} method in order to save the resulting memory address in the current scope.
The purpose of the \qVerb{save_expr_on_stack} is explained later.
That method returns an abstraction which represents a memory location on the stack.
In line 558 of Listing~\ref{lst:riscv_let_stmt}, this method is called and the resulting relative memory address is saved in the variable \qVerb{ptr}.
In the next line, this memory address is inserted into the current scope,
thus associating the name of the compiled variable in to its relative memory location.
This data is saved so that the variable can be accessed later.
Since the main work is accomplished by the \qVerb{save_expr_on_stack} method, it will now be considered in detail.
The Rust code in Listing~\ref{lst:riscv_save_on_stack} displays parts of the \qVerb{save_expr_on_stack} which was called in line 558 of the previous listing.

\Lirsting[float=h, ranges={563-563,_567-573,586-593}, caption={The \qVerb{save_expr_on_stack} Method in the \riscv{} rush compiler}, label={lst:riscv_save_on_stack}]{deps/rush/crates/rush-compiler-risc-v/src/compiler.rs}

This method takes an expression in order to save it on the stack.
As its signature suggests, the method returns an \qVerb{Option<Pointer>}.
Just like other methods, this one will return \qVerb{None} if the passed expression yields no value.
Otherwise, the method returns the relative memory address which will contain the value of the saved expression at runtime.
In line 569, the passed expression is compiled, and the resulting register is saved in the variable \qVerb{reg}.
In line 571, the \qVerb{get_offset} method is used in order to calculate the fp-offset of variable.
Since types like char or bool require less memory, the data type of the expression is also passed to the helper method.
Now, the \qVerb{offset} variable contains the fp-offset at which the variable can be saved.
Since the \qVerb{get_offset} method is used every time values need to be saved on the stack,
it also increments the \qVerb{stack_allocs} variable, so that components like the prologue or epilogue are aware of this stack allocation.
The \qVerb{match} block in line 573 executes different code based on the register type which the expression yielded.
In the lines 586--589, the code which is executed if the expression yielded a float register can be seen.
Here, the \qVerb{fsd} instruction is used in order to save the yielded register at the memory position relative to \qVerb{fp} which is specified in the variable \qVerb{offset}.
The code for integer registers is omitted since it also differentiates between 8-bit and 64-bit data.
In line 592, the \qVerb{Pointer} abstraction representing the memory location of the expression is returned.
Here, it is apparent that this variant of a \qVerb{Pointer} only saves a register and an offset to this register.
In this case, \qVerb{fp} is specified as the register and the value of \qVerb{offset} is used as the offset.

\subsubsection{Function Calls and Returns}

In line 4 of the rush program in Listing~\ref{lst:rush_riscv_simple_sum}, the \qVerb{exit} function is called.
Even though the presented \qVerb{exit} function is special, the rush \riscv{} compiler is able to translate all sorts of different call-expressions using one internal method.
The Rust code in Listing~\ref{lst:riscv_call_expr} shows the first part of the \qVerb{call_expr} method in the \riscv{} rush compiler.
This listing only shows the first part of the method since it is too large to be included in a single-page listing.

\Lirsting[float=h, ranges={92-120,127-128,235-235}, caption={The \qVerb{call_expr} method in the \riscv{} rush compiler.}, label={lst:riscv_call_expr}]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

Since this method is responsible for translating function calls, its implementation has proven to be very complex and demanding.
As the method's signature suggests, it consumes an analyzed call-expression in order to return an optional register.
No register is returned if a function which returns the \qVerb{()} type or the \qVerb{!} type is called.
In line 4 of the code in Listing~\ref{lst:rush_riscv_simple_sum}, this method would return no register because the \qVerb{exit} function is called.

The parts of code in the shown listing are responsible for preparing the compiler for compilation of the function call.
In the lines 93--102, all registers which are used at the time of the function call are saved on the stack.
This is required since the register allocator of this compiler is so simple that it only considers a function at the time.
In production-ready compiler systems, a register allocation algorithm could also work in an interprocedural manner.
When considering this practical example, it becomes apparent that saving \textbf{all} used registers does not produce the most efficient output code.
However, the presented algorithm remains relatively simple.
Furthermore, throughout the extensive testing conducted on the rush backends, this approach has presented itself as reliable\footnote{For each new commit, \rushCountTests integration tests are conducted on every backend}.
In line 95, a new vector named \qVerb{regs_on_stack} which will later contain registers is created.
The for loop in the lines 96--99 is used to spill every used register to the stack.
For this, the helper method \qVerb{spill_reg} is used.
Due to its similarity to the previously explained \qVerb{save_expr_on_stack} method, this method will not be explained further.
After a register has been saved on the stack, it is added to the previously declared vector.
After the loop, in line 102, the \qVerb{used_registers} vector is moved into the local \qVerb{used_regs_prev} variable.
Therefore, after the assignment, the \qVerb{used_registers} vector will be empty due to its contents being moved into the \qVerb{used_regs_prev} variable.
Through this, the compilation of the argument expressions can use more registers since the spilled registers can be overwritten.

In the lines 104--128, the code determines how much additional memory is required in order to place arguments on the stack, which could not fit into registers.
For most calls, this required memory is usually 0.
However, a call with 9 integer arguments would need 8 additional bytes of memory because the ninth argument would have to be placed on the stack.
The final amount of additional memory is saved in the \qVerb{spill_param_size} variable.
Determination of the required size is performed by the for-loop in line 111.
This loop iterates over each argument expression of the call.
For each expression, the match-block in line 112 executes different code depending on the rush data type of the expression.
For instance, expressions which yield in \qVerb{()} or \qVerb{!} do not require registers and can thus be skipped using the \qVerb{continue} keyword in line 113.
Expressions yielding float variables however are considered in the line 114.
Here, the \qVerb{nth_param} method on the \qVerb{FloatRegister} enum is called.

The Rust code in Listing~\ref{lst:riscv_nth_param} shows parts of this method.

\Lirsting[float=H, ranges={215-217,224-227}, caption={The \qVerb{nth_param} method of the \riscv{} rush compiler.}, label={lst:riscv_nth_param}]{deps/rush/crates/rush-compiler-risc-v/src/register.rs}

This method associates an index of a parameter to a register which could represent this position.
For instance, the index 2 represents the third parameter, which is represented by the register \qVerb{fa2}.
For any other indices, the method return \qVerb{None}.
Therefore, the if-expression in line 115 of Listing~\ref{lst:riscv_call_expr} checks if there is no longer a register which could represent the current argument position.
This position is saved in the \qVerb{float_cnt} and \qVerb{int_cnt} variables which are incremented during some iterations of the for-loop.
Here, two counters are used in order to preserve independence between integer and float arguments.
If there is no register for representing the current \qVerb{float_cnt}, the variable's value is greater than 7 and thus exceeds the capacity provided by the eight float parameter registers.
If this is was case, the \qVerb{spill_param_size} variable is incremented by 8 bytes since in rush, a floating-point number requires 64 bits of information.
At the end of the float-specific block, the \qVerb{float_cnt} is incremented by one.
This way, the for loop is able to determine if there are any additional memory requirements of the current function.
In line 4 if the code in Listing~\ref{lst:rush_riscv_simple_sum}, the \qVerb{exit} function is called with one integer argument.
After the code displayed in Listing~\ref{riscv_call_expr} has executed,
the runtime value of the \qVerb{int_cnt} variable is 1 while the \qVerb{spill_param_size} variable holds 0.
If the exit function was to be called using two integer registers, the \qVerb{int_cnt} variable would hold the value 2.
Through this example, it becomes apparent what the task of the code displayed in Listing~\ref{lst:riscv_call_expr} are.

However, only the first part of the \qVerb{call_expr} method is shown in this listing.
The Rust code in Listing~\ref{lst:riscv_call_expr_2} shows the second part of the method.

\Lirsting[float=H, ranges={130-173,198-199,235-235}, caption={The second part of the \qVerb{call_expr} method of the \riscv{} rush compiler.}, label={lst:riscv_call_expr_2}]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

In the lines 130--131, the \qVerb{int_cnt} and \qVerb{float_cnt} variables are reset to 0.
In line 134, a new empty vector named \qVerb{params_regs} is created.
The lines 137--143 are responsible for inserting an \qVerb{addi} instruction in order to allocate stack space.
However, this instruction is only inserted if the size of the spilled parameters is non-zero,
meaning that parameters have been spilled.
If this was the case, inserting an instruction in order to allocate memory is required.

Next, the for-loop in line 148 iterates over the argument expressions.
Just like in the last listings, the match-block in line 149 executes different code based on the data type of the argument expression.
In case of unit or never types, the expression is compiled and the resulting value is ignored.
This is reasonable since these types of expressions yield no register.
For other data types, like floats, other code is executed.
Expressions which yield floats for instance are handled in line 153.
In the next line, the expression is compiled and the resulting register is saved in the variable \qVerb{res_reg}.
In line 155, different code depending on whether the current argument needs to be spilled is executed.
If the current expression does not need to be spilled, the code after the line 156 is executed.
Here, \qVerb{res_reg} is only marked as used and pushed in the \qVerb{param_regs} vector.
Interestingly, there is no code validating that the correct register for the argument position is returned.
This check is redundant since all registers have been marked as unused prior to this block.
Therefore, the resulting value of argument expressions will always be in the correct registers.
However, if there is no register for the current argument, the value has to be spilled onto the stack.
For this, a \qVerb{fsd} instruction (or \qVerb{sd} instruction for integers) is inserted in order to save the result of the current argument on the stack.
As described in a previous section about the \riscv{} calling convention, spilled arguments are placed on the stack in a way so that the first spilled argument is at the lowest memory position.
For reference, this process is described in detail in Figure~\ref{fig:riscv_call_spill} in Section~\ref{sec:riscv_calling_conv} on page~\pageref{sec:riscv_calling_conv}.
In order to calculate this increasing offset easily, the \qVerb{spill_count} variable is declared in line 146.
Every time an argument is spilled, this counter increases.
In line 165, the code calculating the offset relative to \qVerb{sp} can be seen.
Here, the value of \qVerb{spill_count} is simply multiplied by 8 in order to obtain the correct offset.
Therefore, the memory offset $o$ is calculated like this: $o = \text{count}_\text{spilled} \times 8$.
In line 169, the \qVerb{spill_count} variable is incremented like described previously.
Although just the code for floats is shown here, the algorithm for integer-based types only deviates slightly from the one for floats.

Now it has become clear how the argument expressions are compiled.
Even until now, not the entire method has been shown.
The Rust code in Listing~\ref{lst:riscv_call_expr_2} shows the last part of the method.

\Lirsting[float=H, ranges={201-235}, caption={The third part of the \qVerb{call_expr} method of the \riscv{} rush compiler.}, label={lst:riscv_call_expr_3}]{deps/rush/crates/rush-compiler-risc-v/src/call.rs}

The code in the lines 201--209 is responsible for mangling the name of the called function so that it includes the \qVerb{main..} prefix.
However, if the \qVerb{exit} function is called, the name is not mangled.
In line 201, the \qVerb{call} instruction responsible for invoking the function call is inserted.
At this point, the arguments are in their correct places so that the called function will be able to access them.
Therefore, the instruction can be inserted without additional effort.

The code in the lines 212--219 is responsible for restoring stack space which was allocated in order to fit spilled arguments.
Of course, the responsible \qVerb{addi} instruction is only inserted if there are indeed spilled arguments.
In line 222, the previously emptied \qVerb{used_registers} vector is restored to its state before the call.
This is done in order to allow the register allocation for the call arguments to happen independently of the rest of the compiled code.
The code in the lines 224--231 is responsible for selecting an appropriate output register based on the function's return type.
For instance, functions which return \qVerb{float} values place their return value inside the register \qVerb{fa0}.
Therefore, the variable \qVerb{res_reg} represents the register containing the called function's return value.
For functions which return the \qVerb{()} or \qVerb{!} type, no register is selected and \qVerb{None} is returned.
The invocation of the helper method \qVerb{restore_regs_after_call} is used in order to insert instructions which restore the previously spilled registers after the call.
The \qVerb{used_registers} vector could only be completely emptied due to the prior save of all used registers, these restored registers need to be restored after the call has completed.
What strikes the eye here is that the method takes the \qVerb{res_reg} variable as its first argument.

For instance, a function might return a value of type \qVerb{int}, therefore making \qVerb{a0} the content of \qVerb{res_reg}.
If the register \qVerb{a0} was used before the function call, it would have to be restored by the helper method.
However, restoring the register would result in the function's return value to be overwritten, therefore creating a bug.
In order to mitigate this issue, the method will alter the result register by inserting a \qVerb{mv} instruction if necessary.
Since the method returns the final output register which contains the call's result, it is used as the last expression of the block, thus making it the return value of the \qVerb{call_expr} method.

Now it has become apparent how function calls are implemented in the rush \riscv{} compiler.
However, the question of how a called function returns a value still remains.
In the previous sections, we have covered that every generated function contains an \qVerb{epilogue_x}.
Every time the \qVerb{return} keyword is used in rush, the compiler generates an instruction which jumps to the epilogue label of the function being compiled.
If the function should a value, meaning that the \qVerb{return} statement contains an expression,
it is first compiled in order to observe its output register.
If the output register is already the desired register, like \qVerb{a0} for integer values, the compiler can carry on.
However, if the output register of the compiled expression deviates from the register in which return values shall be passed,
the compiler inserts a \qVerb{mv} instructions prior to the instruction jumping to the epilogue label.
This way, values can be returned at any time while stopping execution of the function.
For implicit returns, meaning trailing expressions which are not terminated by a semicolon,
this procedure is identical.

\subsubsection{Loops}

Since most assembly dialects do not provide high-level control-flow scaffolds like loops,
a compiler targeting assembly has to generate code which behaves like a loop.
The code in Listing~\ref{lst:rush_while_loop} shows a rush program containing a while-loop.
On the right side, Listing~\ref{lst:asm_riscv_while_loop} shows parts of the assembler output generated from the rush program.

\begin{minipage}{.32\textwidth}
	\center
	\Lirsting[caption={A rush program containing a while-loop.}, label={lst:rush_while_loop}, float=H]{listings/while_loop.rush}
\end{minipage}%
\hspace{2.5cm}
\begin{minipage}{.47\textwidth}
	\center
	\Lirsting[ranges={21-36},caption={Assembly output of rush program in Listing~\ref{lst:rush_while_loop}.}, label={lst:asm_riscv_while_loop}, float=H]{listings/generated/rush_while_loop.s}
\end{minipage}

The rush program in Listing~\ref{lst:rush_while_loop} contains a while loop which will iterate ten times.
At the beginning of the program, the integer variable \qVerb{count} is declared.
Before each iteration, the while-loop checks that the condition in its head is true.
If the condition was true, the code inside the loop is executed.
Otherwise, the execution of the loop stops and the code after the loop is executed.
In the assembly output in Listing~\ref{lst:asm_riscv_while_loop}, the contents of the loop is represented by the instructions inside the \qVerb{while_head_0} label.
The instructions generated from code before the loop are not visible but appear before the code shown in the listing.
As the comment in line 22 suggests, the first instructions after the label declaration represent the loop control code.
These instructions are executed every time time loop begins a new iteration, therefore they check if the condition is true before any of the code inside the loop's body is executed.
If the condition is false, the execution of the loop should stop.

This is accomplished by the \qVerb{beqz} instruction in line 26.
This instruction is a pseudoinstruction which jumps to the target label if the value inside the first operand is zero~\cite[p.~105]{Waterman2019}.
Here, this would mean that the instruction would jump to the \qVerb{after_while_0} label if the condition of the loop evaluated to false.
Just like the name of the \qVerb{after_loop} label suggests, it contains code which follows the while-statement.
Therefore, in this example, it contains the instructions calling the \qVerb{exit} function with the code saved in the variable \qVerb{count}.
However, if the condition evaluated to \qVerb{true}, the \qVerb{beqz} instruction would execute without causing a jump.
In this case, the instructions following the comment in line 27 are executed.
As the comment suggests, these instructions represent the code inside the loop's body.
The instructions in the lines 28--31 represent the expression \qVerb{count += 1} in line 4 of the rush code.
In line 32, an unconditional \qVerb{j} instruction jumps back to the beginning of the \qVerb{while_head_0} label.
Since this jump happens unconditionally, this instructions introduces the iteration for which the loop is desired.
Therefore, at the end of a loop, an instruction jumps back to the start, where the condition is then evaluated again.
This way, the compiler is able to generate instructions for the \qVerb{loop}, \qVerb{while}, and \qVerb{for} statements.
However, \qVerb{loop} statements lack the control code which checks a condition as there is no condition in these loops.
Furthermore, \qVerb{for} loops contain code representing its update expression at the end of their body.
By using this approach, the compiler is also able to generate nested loops reliably.
Due to the simplicity of the presented approach, Rust code from the compiler is omitted.
