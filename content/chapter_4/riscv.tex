\newpage

\section{RISC-V: A Compiler for a Modern RISC Architecture}

%\enquote{RISC-V is a recent, clean-slate, minimalist, and open ISA informed by mistakes of past ISAs. The goal of the RISC-V architects is for it to be effective for all computing devices, from the smallest to the fastest. Following von Neumann’s 70-year-old advice, this ISA emphasizes simplicity to keep costs low while having plenty of registers and transparent instruction speed to help compilers and assembly language programmers map actually important problems to appropriate, quick code.}\cite[p.~11]{Patterson2017}
% \begin{itemize}
% 	\item Introduced in 2011 X
% 	\item UC Berkely research project X
% 	\item Since then: rising in popularity X
% 	\item ISA = \enquote{instruction set architecture} X
% 	\item Was developed for: NO
% 	      \begin{itemize}
% 		      \item All sizes of processors: from embedded to high-performance computer
% 		      \item compatibility to popular software stacks and programming languages
% 		      \item serves as extendable base for customized accelerators
% 		      \item Should be stable
% 	      \end{itemize}
% 	\item One of the few ISAs which were developed this decade instead of the 1970s / 1980s X
% 	\item Open ISA: unlike most previous ISAs, it is free from a bond to a single comporation X
% 	\item Base ISA: \qVerb{RV321}.
% 	      Frozen, will never change, gives assembly programmers and compiler writers a stable target.
% 	\item The base instruction set is extendable using extensions like (multiply: \qVerb{RV32M}) or (double-precision floats: \qVerb{RV32D}).
% 	\item \enquote{RISC-V is a recent, clean-slate, minimalist, and open ISA informed by mistakes of past ISAs. The goal of the RISC-V architects is for it to be effective for all computing devices, from the smallest to the fastest. Following von Neumann’s 70-year-old advice, this ISA emphasizes simplicity to keep costs low while having plenty of registers and transparent instruction speed to help compilers and assembly language programmers map actually important problems to appropriate, quick code.}\cite[p.~11]{Patterson2017}
% \end{itemize} \cite[Chapter~1]{Patterson2017}.
%
% \TODO{Also interesting: \cite[p.~10]{Patterson2017}, \cite[Chapter~2]{Patterson2017}.}
%
% \begin{itemize}
% 	\item Present Some example instructions (Refer to chapter 3 of the RISC-V READER)
% 	\item Register layout \& count
% 	      RISC-V has 32 registers, ARM-32 16, x86\_32 has 8\\
% 	      Assembly includes all extensions\\
% 	      Concepts of \emph{pseudoinstructions}~\cite[p.~10]{Patterson2017}\\
% 	      Has basic instructions for add, sub, and logical operations\\
% 	      \emph{Check for all relationships between two registers, some conditional expressions involve rela- tionships between many pairs of registers. The compiler or assembly language programmer could use slt and the logical instructions and, or, xor to resolve more elaborate conditional expressions. The two remaining integer computation instructions Figure 2.1 help with assembly and}
% 	      r0 → constant 0 register\\
% 	      ~\cite[p.~18]{Patterson2017}
% 	\item ASM directives: \cite[p.~39]{Patterson2017}
% 	\item ASM includes 60 pseudoinstructions: \cite[p.~42]{Patterson2017}
% 	\item Another 32 Float registers, float load / store instructions: \cite[pp.~48f.]{Patterson2017}
% 	\item Refer to stack figure: \cite[p.~40]{Patterson2017}
% 	\item Calling convention
% \end{itemize}

The \emph{RISC-V} \emph{ISA}\footnote{Short for: \enquote{instruction set architecture}} is a new and modern \emph{reduced instruction set} architecture focussing on simplicity and expandability.
The initial version was developed at \emph{UC Berkely} in the context of another related research project.
Since its introduction in 2011, the architecture has been rapidly growing in popularity.
Since the beginning, the project has been managed and led by the \emph{RISC-V foundation}, consisting of many individuals contributing to the project.
Today, corporate members of the RISC-V foundation include companies like \emph{Google}, \emph{Microsoft}, \emph{Samsung}, and \emph{IBM}.
Therefore, the general popularity and commercial attraction of the technology is apparent.
However, unlike most previous ISAs, the RISC-V architecture is a completely \emph{open-source} project and is therefore not controlled by a single large corporate entity.
This can be regarded as a large competitive advantage over other popular RISC architectures like \emph{ARM}.
In the past, many ISAs have failed due to them being too restrictive with their licensing, thus preventing widespread commercial adoption.
However, RISC-V is completely open and free to use, so that many companies like \emph{Google} can leverage the technology commercially whilst contributing to the project.
Unlike most of the previous ISAs, which were developed during the 1970s or 80s, RISC-V is one of the few ISAs which were developed during this decade.
Therefore, it seems like RISC-V could be a significant architecture to be used in all sorts of devices in the near future~\cite[preface]{Patterson2017}.

\subsection{Register Layout}

\begin{wraptable}{r}{.4\textwidth}
	\centering
	\caption{Common Registers in RISC-V~\cite[p~.155]{Waterman2019}}\label{tbl:riscv_regs}
	\begin{tabularx}{\linewidth}{l|L}
		\rowcolor{gray!10} Register   & Purpose                         \\ \hline
		\texttt{zero}                 & Hardwired zero                  \\ \hline
		\texttt{ra}                   & Return address                  \\ \hline
		\texttt{sp}                   & Stack pointer                   \\ \hline
		\texttt{t0} —  \texttt{t6}    & Temporary                       \\ \hline
		\texttt{fp}                   & Frame Pointer                   \\ \hline
		\texttt{a0}, \texttt{a1}      & Function argument, return value \\ \hline
		\texttt{a2} — \texttt{a7}     & Function argument               \\ \hline
		\texttt{s1} — \texttt{s11}    & Saved register                  \\ \hline
		\texttt{fa0}, \texttt{fa1}    & FP args, return value           \\ \hline
		\texttt{fa2} — \texttt{fa7}   & FP args                         \\ \hline
		\texttt{fs0} — \texttt{fs11}  & FP saved registers              \\ \hline
		\texttt{ft0} —  \texttt{ft11} & FP temporaries                  \\
	\end{tabularx}
\end{wraptable}

Most RISC architectures typically have a large number of registers~\cite[Chapter~2]{Dandamudi2005}.
When compared to other popular architectures, the truth of this statement becomes clear.
For instance, the \emph{x86\_32} architecture has 8 registers.
The popular RISC architecture \emph{ARM-32} contains twice that amount, meaning 16 registers.
However, RISC-V includes 32 registers, meaning drastically more than the previously mentioned architectures.
Moreover, these 32 registers only include registers holding integer values.
Just for floating-point numbers, the ISA even provides another 32 registers.
Like previously explained, using more registers usually leads to increased efficiency of the output program.
Therefore, a register allocation algorithm targeting the RISC-V architecture could be more aggressive compared to one targeting x\_86 for instance.

The Table~\ref{tbl:riscv_regs} shows most of the registers which the RISC-V platform provides.
For the registers in this table, their official ABI\footnote{Short for: \enquote{application binary interface}} names have been used in order to make the section easier to read.
The \qVerb{zero} register is a special integer register on RISC-V.
Like its name suggests, it always holds the value of a constant 0.
Unlike other registers, it is read-only, meaning that it can never be overwritten by accident.

The \qVerb{ra} register saves the \emph{return address}.
For instance, this register is used when the \qVerb{call} instruction is executed.
First, the address of the instruction after the call-instruction is saved in \qVerb{ra}.
Next, the CPU jumps to the instruction at the specified location.
If a return-instructions was to be used later, the value in \qVerb{ra} would be used to jump back to where the call was made.

The \qVerb{sp} and \qVerb{fp} registers are used for managing stack memory.
Their purpose is explained in a following subsection.
The \qVerb{t0} — \qVerb{t6} registers are often used to store temporary values used in larger computations.
Next, the register \qVerb{a0} and \qVerb{a1} can both serve as function call arguments and return values of functions.
How functions are called using registers will also be explained in a following subsection.
The remaining a-registers \qVerb{a2} — \qVerb{a7} can only be used as function call arguments.
The \emph{saved} registers \qVerb{s1} — \qVerb{s11} are typically preserved accross function calls.
However, this concept will also be explained in more detail later.
All the previously named registers hold integer values.
Depending on the exact RISC-V architecture, all registers either hold 32-bit or 64-bit integers.

Just like their integer counterparts, the floating-point registers \qVerb{fa0} and \qVerb{fa1} are used as function call arguments and as return values.
The registers \qVerb{fa2} — \qVerb{fa7} can only be used as function arguments holding floating-point numbers.
Just like the \qVerb{sx} registers, the \qVerb{fs0} — \qVerb{fs11} registers are usually preserved accross function calls.
Last, the \qVerb{ft0} — \qVerb{ft11} registers can be used as temporary registers for floating-point numbers.~\cite[pp.~18f,p.~34]{Patterson2017},~\cite[p~.155]{Waterman2019}.

Now, it has become apparent that RISC-V includes many registers grouped into categories.
Every category is meant to be used in the specified manner, however, these groups are merely a suggestion of how each register should be used.
More information on the special registers like \qVerb{sp}, \qVerb{fp}, and \qVerb{ra} is given in the next sections.

%RISC-V has 32 registers, ARM-32 16, x86\_32 has 8\\
%Another 32 Float registers, float load / store instructions: \cite[pp.~48f.]{Patterson2017}

\subsection{Memory Access Through the Stack}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{./riscv_stack_draft.png}
	\caption{\textcolor{red}{DRAFT:} Stack Memory on the RISC-V architecture}\label{fig:riscv_stack}
\end{figure}

\begin{itemize}
	\item In the current implementation, \qVerb{sp} includes legal memory locations
	\item \qVerb{fp} points to the first address after the last legal one
\end{itemize}

\subsection{Calling Convention}

\subsection{RISC-V Assembly}

\noindent
\begin{figure}[h]
	\begin{minipage}{.4\textwidth}
		\Lirsting[fancyvrb={frame=none}]{listings/riscv_simple.rush}
	\end{minipage}%
	\begin{minipage}{.6\textwidth}
		\Lirsting[ranges={1-31, -4 53-56}, fancyvrb={frame=none}]{listings/generated/riscv_simple.s}
	\end{minipage}
	\caption{Rush Program Alongside its RISC-V Output}\label{fig:rush_riscv_split}
\end{figure}

The rush program on the left side of Figure~\ref{fig:rush_riscv_split} shows a program which exists.
Because the assembler code of the \qVerb{foo} function would take up too much space in the assembler program, it is intentionally omitted from this listing.
Since the excluded function does not introduce any new concepts anyway, omitting it will not lead to a loss of explained content.
In line 1 of the rush program, a mutable global variable named \qVerb{m} is defined using the initial value 42.
In the main-function, \qVerb{m} is incremented by 1.
Next, the \qVerb{foo} function is called using m as its call argument.
In line 6, a return-statement is used to terminate the main-function explicitly.
However, the \qVerb{foo} function only calls the exit function on its own.
Therefore, the exit code of the program will be 43.

In line 1, the \qVerb{.global} assembler directive is used to declare the global symbol \qVerb{_start}~\cite[p~.36]{Patterson2017}.
On most architectures, the \qVerb{_start} label indicates the program's entry point, therefore marking the first instruction to be executed~\cite[p.~19]{Zhirkov2017-wk}
Object files using the ELF format are usually partitioned into several sections.
Here, every individual section exists to serve a special purpose.
For instance, the \qVerb{.text} section stores all CPU instructions to be executed.
Furthermore, the \qVerb{.data} and \qVerb{.rodata} sections store mutable and read-only data respectively~\cite[p.~76]{Zhirkov2017-wk}.
In line 5, the \qVerb{_start} label is defined using its name followed by a colon.
One might realize that the concepts of labels in RISC-V assembly can be compared to the labels and basic blocks introduced in the chapter about LLVM\@.
However, these labels do not come with all the constraints which were introduced by LLVM basic blocks.
Therefore, a label in assembly might even contain no instructions, does not have to be terminated and could even be terminated twice.
Here, terminating instructions mean jump- and return-instructions.
In line 6, the \qVerb{call} instruction is used to call the \qVerb{main..main} function.
This pseudoinstruction will jump to the first instruction of the specified target label whilst saving the address of the next instruction after the \qVerb{call} instruction in the register \qVerb{ra}.
Since this register holds the address of the next instruction after the function call, similarities to the call-stack of the rush VM can be noticed~\cite[p.~22]{Patterson2017}.
What strikes the eye here is that the already familiar \qVerb{main} contains the \qVerb{main..} prefix.
Due to name mangling implemented by this rush compiler, every function declared in a rush program will contain this prefix.
However, unlike function calls in LLVM, this call instruction must be used alongside the previously explained low-level calling conventions of RISC-V.

In the next line, the \qVerb{li} instruction is used to move the constant integer 0 into the register \qVerb{a0}~\cite[reference]{Patterson2017}.
In line 8, the \qVerb{exit} function is called, however, one cannot see the definition of this function inside the current file.
Since the exit-function is defined in a separate file, this scenario presents referencing an external library which is later resolved by the linker.
The instructions in the lines 7--8 are responsible for terminating the program using exit code 0.
These two instructions are always inserted at the end of the \qVerb{_start} label in order to terminate the program appropriately in case the rush code does not call \qVerb{exit} on its own.

Due to the function call in line 6, we will now shift our focus on the \qVerb{main..main} label in line 10.
An interesting observation is that labels can be called as if they were functions.
However, the \qVerb{call} instruction is only a pseudoinstruction which jumps to the target label whilst performing additional work during the process.
In line 11, the first line of the \qVerb{main} function, a comment indicates the beginning of the function's prologue.
In the rush compiler's implementation, each function contains a \emph{prologue} and an \emph{epilogue}.
The prologue is responsible for allocating space on the stack by incrementing \emph{sp} and \emph{fp} according to the amount of memory required in its function.

For instance, the \qVerb{addi} instruction in line 12 is used to decrement the value of the \qVerb{sp} register by 16.
However, an addition instruction is used even though subtraction is required.
In RISC-V, the \qVerb{addi} instruction requires one register and one immediate value as its operands.
The latter is the cause for the trailing \qVerb{i} (\emph{immediate}) in the instruction's name.
Since this immediate value can be negative, an additional instruction for immediate subtraction is redundant~\cite[reference]{Patterson2017}.
This example shows how the ISA omits redundant instructions were feasible.
In this case, the stack pointer is decremented by 16 since two 8-byte values are stored on the stack in the lines 13 and 14.
Here, the values of the registers for the frame pointer and the \emph{return address} (\emph{ra}) are saved on the stack.
This way, their values can be restored later before returning from this function.
In line 15, the frame pointer is adjusted according to the modifications made to the stack pointer.
The comment in the next line indicates the end of the prologue.
In short, the prologue performs important initialization before any other code of the newly called function is executed.

The comment in line 17 indicates the start of the function's body.
First, the previously explained \qVerb{li} instruction in line 18 places a constant 1 in register \qVerb{a0}.
Next, the \qVerb{ld} instruction in line 19 is used in order to load the value of the global variable \qVerb{m} into the register \qVerb{a0}~\cite[reference]{Patterson2017}.
Global variables, like \qVerb{m} in this example are saved under the \qVerb{.rodata}. section or under the \qVerb{.data} section if they are mutable.
In this example, \qVerb{m} is not declared as mutable and therefore saved under the \qVerb{.rodata} section.
The start of the \qVerb{.rodata} section is represented by the \qVerb{.section} assembler directive found in line 53.
Here, a label called \qVerb{m} is defined.
In this label, the \qVerb{.dword} directive is used to define the global initializer value of the variable.
In RISC-V, this directive stores 64 bit of information in successive memory doublewords~\cite[p.~39]{Patterson2017}.
The initializer value of the global variable is 42 and is represented as \qVerb{0x2a} using hexadecimal in the assembly code. \TODO{Is specification of the base correct here?}
Since these data labels require their data to be specified in hexadecimal, the trailing comment shows the base 10, human-readable version of the number.
Because global variable are not saved on the stack, special instructions like \qVerb{ld} are required to interact with global variables stored in the program's data sections.

Now, the register \qVerb{a0} would contain 1 and \qVerb{a1} would contain 42.
In line 20, the \qVerb{add} instruction is used in order to save the sum of \qVerb{a0} and \qVerb{a1} in the register \qVerb{a2}.
Now, the value of \qVerb{a2} would be 43.
Next, the \qVerb{sd} instruction in line 21, saves the value of the register \qVerb{a2} at the memory location of the global variable \qVerb{m}, meaning that m is updated to reflect its new value 43.
It now becomes apparent that these instructions are responsible for the add-assign expression in line 4 of the rush program.
Another interesting observation is that the \qVerb{sd} instruction uses the temporary register \qVerb{t6} for saving temporary data~\cite[reference]{Patterson2017}.

Next, the previously explained \qVerb{ld} instruction in line 22 is used in order to load the value of the global variable into the register \qVerb{a0}.
Then, the \qVerb{call} instruction in line 23 is used in order to call the \qVerb{foo} function using the value of m as its argument.
However, one cannot easily observe how call arguments are passed here.
Like explained previously, the first integer argument of a function call must be placed in the register \qVerb{a0}.
Since \qVerb{m} was loaded into \qVerb{a0} previously, it is used as the call argument for \qVerb{foo} automatically.
Therefore, the \qVerb{foo} function would be called using 43 as its argument value.

Since the \qVerb{foo} instruction only calls the \qVerb{exit} function, its explanation will not be beneficial through the introduction of new concepts.
The final instruction of the main-function's body is the \qVerb{j} instruction in line 24.
This instruction will cause the CPU to jump to the address of the specified label.
In this example, the CPU will jump to the first instruction of the \qVerb{epilogue_0} label~\cite[p.~17]{Patterson2017}.
Therefore, the rush compiler uses the \qVerb{call} instruction for jumps caused by function calls and the \qVerb{j} instruction for jumps between blocks of the current function.

Like previously hinted, every function has a \emph{prologue} and an \emph{epilogue}.
Just like the name suggests, the epilogue is used to free any resources allocated by the function's prologue.
For instance, the frame pointer is restored to its state before the function call.
Furthermore, the epilogue restores the value saved in the \qVerb{ra} register in order to restore the return address.
Since the return address is vital for returning to the next instruction after the function call in the caller function, it is restored here so that this function returns control to the correct caller instruction.
Since the return address of the caller function is saved in the prologue, nested function calls will cause no issues.
If the prologue would not save the return address on the stack, a nested function call would overwrite the return address of the parent function, therefore creating a bug~\cite[p.33]{Patterson2017}.
Again, this design contains a lot of similarities to the call-design of the rush VM\@.
In the VM, the process of saving and restoring the return address was managed automatically by the VM\@.
However, here, the programmer has to manually pay attention to saving and restoring this important piece of data.
Therefore, implementing a call stack is definitely more demanding in RISC-V assembly than in the rush VM\@.
In line 30, the stack pointer is incremented again in order to deallocate memory used by the function.
Finally, the \qVerb{ret} instruction in line 31 is used in order to jump back to the instruction whose address is specified in the \qVerb{ra} register~\cite[reference]{Patterson2017}.

\subsection{The Core Library}

\subsection{The rush Compiler Targeting RISC-V Assembly}

