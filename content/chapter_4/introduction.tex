In the previous chapter, we have learned how compilation to high-level targets can present an easy way of implementing a compiler.
These compilers generated outputs which were still platform independent and portable.
However, compilers can also target a specific computer architecture directly, thus removing another layer of abstraction.
The concept of compiling to a specific architecture directly is similar to the VM since its compiler also targets its architecture directly.
However, implementing a compiler targeting the architectures presented in this chapter has proven to be a lot more demanding since the VM uses a fictional architecture purposefully developed for this paper.
Reasons for this chapter's difficulty mostly include target-specific constraints which were
still irrelevant in the previous chapter.
This chapter contains the term \enquote{low-level} in its name since the presented compilers
generate code for specific target-architectures directly.

\section{Low-Level Programming Concepts}
Programming using high-level languages does not require knowledge about the intrinsic of the target architecture.
However, in this chapter, two compilers targeting the low-level assembly language are presented.
In order to make sections in which these compilers are explained more approachable,
some of the most important low-level programming concepts are explained in this section.
We will only explain concepts which play a significant role later on.

% \begin{itemize}
%     \item Basic structure of an ELF assembly program (use RISC-V as a simple example)~\cite[p.~35]{Patterson2017}
%     \item Registers \& why their allocation is a problem (with figure describing CPU, registers, Memory)~\cite[p.~10]{Patterson2017}
%     \item Assembly \& Assembler~\cite[p.~5-6]{Dandamudi2005} % TODO: include figures describing how low-level assembly is?
%     \item Stack (with figure) \& Heap (briefly)~\cite[p.40]{Patterson2017}
% 	\item Briefly explain what calling conventions are~\cite[p.42]{Patterson2017}
% \end{itemize}

\subsection{Sections of an ELF File}
Since a program needs to be representable in a low-level manner, special formats are often required.
ELF stands for \enquote{executable and linkable format} and is often found on unix-like systems, e.g. Linux.
Programs using the ELF format can be represented in three different types of files.
For instance, object files generated by a compiler, like in the previous LLVM section, might use the ELF format.
Furthermore, libraries using \emph{shared object files} might also leverage the ELF format.
Most executable program use the format in order to represent a structured container for instructions, data, and additional information.
This way, the unit is mostly self-contained an can be executed by the operating system easily.
Therefore, ELF describes the format of a class of files and not just of an individual type of file~\cite[p.~74-76]{Zhirkov2017-wk}.

Even though a processor only has access to one physical memory unit for both instructions and program data,
most assembly programs like to separate these types of memory into their separate components.
Therefore, an object file and assembly program is divided into so-called \emph{sections}~\cite[p.~19]{Zhirkov2017-wk}.

In ELF programs, important sections which are later used include:
\begin{itemize}
    \item \texttt{.text} stores the logic of the program represented using CPU instructions
    \item \texttt{.rodata} stores read-only global data, it is often used for global constants.
    \item \texttt{.data} stores mutable global data, such as mutable global variables
\end{itemize}

It is to be mentioned that this list only includes entries which are of importance later in later sections of the paper~\cite[p.~76]{Zhirkov2017-wk}.

\subsection{Registers}

\begin{itemize}
    \item Include graphic of computer with registers and memory
    \item Processors contain numerous registers in order to hold data, instructions, and state information 
    \item Largely dependent on the type of CPU used
    \item A large number of registers often improves performance
    \item RISC architectures typically have a large number of registers
    \item Most CPUs have special-purpose registers
\end{itemize}

% Watson 2017: p. 212
% Dandamudi2005: Chapter 2

\subsection{Assemblers and Assembly Language}

\begin{wrapfigure}{R}{.3\textwidth}
    \centering
	\includegraphics[width=.25\textwidth]{./abstractions_draft.png}
	\caption{\textcolor{red}{DRAFT:} Level of Abstraction provided by Assembly}\label{fig:abstractions}
\end{wrapfigure}

Assembly language describes a type of low-level programming languages which are directly influenced by the target architecture.
Since the assembly code provides a slight abstraction over the computer's hardware,
the assembly code must be translated to machine code before it can be executed.
This process is performed by a program named the \emph{assembler} and is often called \emph{assembly}.
A typical characteristic of assembly code is that it seems relatively cryptic to a human reading it.
Furthermore, compared to high-level languages like C, assembly code is relatively low-level since it can be used to interact with the hardware directly.

For instance, the RISC-V instruction \qVerb{add a0, a0, 2} would be used in integer addition.
This example contains most characteristics of an assembly language program.
Like hinted previously, the name of the instruction is a mnemonic.
In this case, \qVerb{addi} stands for \enquote{add immediate}.
Furthermore, the exact semantic meaning of the instruction is not immediately apparent.
At last, the instruction for adding integers differs for most CPU architectures.
For instance, an equivalent instruction for the x\_86 architecture could be `\texttt{add \%rdi, 2}'.
Therefore, the fact that instructions differ on each target architecture is clearly apparent.

In order to understand how much abstraction is provided by assembly, we should consider Figure~\ref{fig:abstractions}.
Here, the highest level of abstraction is provided by high-level programming languages like C or Rust.
In the context of this paper, rush presents roughly the same level of abstraction like these languages.
The next lower level of abstraction is provided by assembly.
Now, the program is no longer independent of its target architecture and is much more demanding to furmulate.
However, the next lower level of abstraction below assembly is represented by code in machine language.
As of today, one only rarely encounters a programmer writing programs using this level of abstraction. 
Since the machine language program is represented in binary, it is nearly impossible for a human to write or understand.
However, the machine language is also just an abstraction of the computer's hardware and operating system.
Therefore, assembly provides enough abstraction to be comprehensible for a human whilst being a low-level representation of the program.
Although assembly provides more abstraction than the two levels at the bottom of the figure, programmers rarely program in assembly directly.
Some of the benefits of using assembly language to formulate a program are increased runtime efficiency and decreased code size.
Therefore, it might be reasonable for a compiler to generate assembly code from the source program.
This way, the program is translated into a low-level, target-specific representation which allows the program to be executed on the target machine directly.
However, an assembler is still required in order to translate the assembly output of the compiler.
Since most assemblers output object files, a linker is required to create the final executable program.
Therefore, a compiler targeting the assembly of a specific architecture depends on these two additional steps before the program can be executed~\cite[p.~5-6]{Dandamudi2005}.

One might argue that the compiler could output object files directly.
However, doing so rarely creates any significant benefits other than the omitted dependence on the assembler.
Furthermore, implementing a compiler using this approach often significantly increases the complexity of the compiler since it now has to perform the role of the assembler as well.
However, the compiler could also emit binary data directly, thus making its implementation significantly more demanding.

\subsection{Using Memory: The Stack and the Heap}
\TODO{@RubixDev}
\subsection{Calling Conventions}
\TODO{@RubixDev}


\TODO{RISC vs. CISC~\cite[p.~5-6]{Dandamudi2005}}
% TODO: the below goes under conclusions
% \section{CISC and RISC Architectures}
%
% \subsubsection{CISC}
% % CISC was chosen to be the first one on purpose
% \begin{itemize}
% 	\item X86 (64) as an example (briefly)
% 	\item CISC architectures date back to the time in which Assembly was written by hand.
% 	      Programs were easier to write and often performed better due to these complex instructions.
% 	      Larger quantity of instructions in CISC architectures.
% 	\item Complex \& many instructions cause the architecture to be a bit slower for compiled programs
% \end{itemize}
%
% \subsubsection{RISC}
%
% \begin{itemize}
% 	\item RISC-V as an example (briefly)
% 	\item Rather modern
% 	\item Better for modern CPUs which mostly execute machine-written code
% 	\item Harder to write manually
% 	\item Easier to implement a compiler for
% 	\item Usually small and very simple instruction set
% 	\item Gain in popularity (ARM / RISC-V)
% \end{itemize}
