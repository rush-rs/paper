\subsection{The Compiler Targeting the rush VM}\label{sec:vm_compiler}

Since the rush VM interprets instructions directly, there must be a compiler targeting its architecture.
For this purpose, we have implemented a compiler translating rush source code into instructions which can be understood by the VM\@.
Since the VM's architecture was developed with the features of rush in mind,
the compiler sometimes requires surprisingly little effort for translating certain AST-nodes.
For instance, the compiler translates infix-expressions, such as `\texttt{n + m}', into instructions using the \qVerb{infix_expr} method.
This method is displayed in Listing~\ref{lst:vm_compile_infix_expr}.

\Lirsting[ranges={522-524,536-543}, caption={Compilation of infix-expressions targeting the VM.}, label={lst:vm_compile_infix_expr}, float=h]{deps/rush/crates/rush-interpreter-vm/src/compiler.rs}

This method differentiates between the `\texttt{Or}' / `\texttt{And}' operators and other possible operators since the former require some extra code to be emitted.
However, due to simplicity, the focus only lies on the compilation of the latter, meaning any other type of infix-expression.
In line 538, the left-hand side expression is compiled first.
In the next line, the right-hand side is compiled too.
Finally, in line 540, the matching instruction representing the infix-operator is inserted.
The final instruction is generated by a helper function which converts an infix-operator into a matching instruction.
It is to be mentioned that most of the other rush compilers required significantly more code in order to implement the translation of infix-expressions.
The reason for the simplicity of this implementation is the fact that the rush VM implements one instruction for each infix-operator.
Since this VM implements all features of the source language, complex hacks for implementing some operations are not required and thereby simplify the compiler's implementation.

\Lirsting[ranges={445-447,457-461}, caption={Compilation of expressions targeting the VM.}, label={lst:vm_compile_expr}, float=h]{deps/rush/crates/rush-interpreter-vm/src/compiler.rs}

The code in Listing~\ref{lst:vm_compile_expr} shows parts of the `\texttt{expression}' method of the rush VM compiler.
When we examine the method's signature, it becomes apparent that it consumes an \qVerb{AnalyzedExpresssion}.
However, the method does not return anything which represents the runtime value of the expression.
This is possible because the results of the expressions displayed in the snipped are pushed onto the stack directly.
In line 447, the code for translating a constant integer expression can be seen.
Here, a push instruction using the constant int value as its operand is used.
By pushing the values of expressions onto the stack directly, most tree traversing methods do not need to return values.
Due to this, short and elegant code like the one in Listing~\ref{lst:vm_compile_infix_expr} can be implemented.
In other compilers, the method responsible for compiling expressions would usually return the register which contains the value of the compiled expression at runtime.
Due to the values being saved on the VM's stack, other parts of the compiled program can still use the runtime values of compiled expressions.
In line 457, the method for compiling call-expressions would be invoked.
Similar to the `\texttt{expression}' method in the analyzer, this method also dispatches the traversal of more complex expressions to specialized methods in order to keep this method simple.

Another reason for the compiler's simplicity regarding infix-expressions is that the rush VM includes a special instruction for the mathematical power operation.
In rush, the expression `\texttt{n ** m}' can be used to denote following mathematical term: $n^m$.
Since many real architectures lack such a power instruction, most other rush compilers demanded implementation of special edge-cases in order to make compiling power-expressions feasible.
On the opposite, implementing a rush compiler targeting the VM has proven to be less demanding since the VM supports a power-instruction.
Furthermore, the VM also includes an `\texttt{exit}' instruction which terminates the fetch-decode-execute cycle instantly.
These examples showed how a carefully chosen target architecture simplifies the implementation of its compiler by a great deal.

However, there is also one aspect of the VM which made implementation of the compiler targeting the VM more demanding than usual.
For instance, in most Assembly dialects, \emph{labels} can be used to allow jumps between blocks of code.
However, the VM intentionally does not support the use of such labels.
Since the VM would have to look up the exact instruction index of a label at runtime,
each jump targeting a label would involve some additional overhead.
This overhead is eliminated by the assembler during assembly of a program.
Since the assembler performs these lookups during translation,
the CPU does not have to deal with label lookups at runtime.
Like seen in the previous examples, jumping VM instruction require the exact index of the target instruction as their operands.
Therefore, the exact target index to which the instruction should jump must be known.
To illustrate this issue, we will consider how loops are implemented in the VM\@.
The rush code in Figure~\ref{fig:vm_loops} presents a program containing a loop.
In the loop's body, the variable `\texttt{n}' is incremented by 1.
Next, the `\texttt{break}' keyword is used to terminate loop execution.
Therefore, the total amount of iterations is 1.

\noindent
\begin{figure}[h]
	\begin{minipage}{.5\textwidth}
		\centering
		\Lirsting[fancyvrb={frame=none}]{listings/vm_basic_loop.rush}
	\end{minipage}%
	\hfill
	\begin{minipage}{.5\textwidth}
		\centering
		\Lirsting[fancyvrb={frame=none}]{listings/vm_basic_loop_instructions.s}
	\end{minipage}
	\caption{Representation of loops in the VM.}\label{fig:vm_loops}
\end{figure}

The rush VM instructions of the `\texttt{main}' function are displayed on the right side of Figure~\ref{fig:vm_loops}.
Here, lines 2 and 3 are responsible for declaring a variable named `\texttt{n}'.
The instructions in the lines 4--9 are used to increment `\texttt{n}' by 1.
A new instruction which we have not covered so far is the `\texttt{clone}' instruction.
This instruction \emph{clones} the top item on the stack it without prior calls to `\texttt{pop}'.
Therefore, after the instruction has been executed, two identical values exist on the top of the stack.
This instruction is only used in assign-expressions in order to duplicate the address value of the assignee variable.

After `\texttt{n}' was incremented, the instruction in line 10 jumps to the instruction index 11.
However, the last valid index is 10, it is represented by the `\texttt{jmp 3}' instruction in line 11.
If this jump is executed, the VM has no next instruction to fetch and therefore stops its fetch-decode-execute cycle.
Since this instruction jumps to a position outside the loop, it represents the \qVerb{break} statement in line 5 of the source program.
The `\texttt{jmp}' instruction in line 11 is responsible for the repetition introduced by the loop.
This instruction jumps to the first instruction of the loop's body in line 4.
Therefore, the instructions inside the loop's body are executed repeatedly.
The difficulty presented by this design is that the index of the jump's target instruction must be known before the target instruction is inserted.
The code in Listing~\ref{lst:rush_vm_compiler_loop} displays a part of the method responsible for compiling loops for the rush VM\@.

\Lirsting[ranges={320-323,331-331,337-344}, caption={Implementation of loops in the rush VM compiler.}, label={lst:rush_vm_compiler_loop}, float=h]{deps/rush/crates/rush-interpreter-vm/src/compiler.rs}

In line 331, the loop's body is compiled and instructions generated during this process are inserted into the output sequence.
The next statement in line 337 inserts an instruction responsible for jumping back to the start of the loop's body.
The variable `\texttt{loop\_head\_pos}' was previously defined and species the index of the first instruction of the loop's body.
Therefore, this inserted instruction performs continuous jumps, thereby introducing the repetition for which the loop is desired.

In line 340, the top loop is popped from the `\texttt{loops}' stack.
In line 322, this loop was previously pushed onto the identical stack.
This stack is an internal field used by the compiler in order to save information about loops.
The top item on this stack always represents the loop currently traversed by the compiler.
Each loop item saves two lists, each containing the indices of jump-instructions whose target index needs to be adjusted.
The first list contains the indices of jump-instructions generated by `\texttt{break}' statements which were encountered during traversal of the loop's body.
The second list saves the indices of jump-instructions emitted by `\texttt{continue}' statements inside the loop's body.
For instance, if the compiler encounters a `\texttt{break}' statement, the code in Listing~\ref{lst:rush_vm_compiler_break} is executed.

\Lirsting[ranges={253-253,268-273,287-288}, caption={Compilation of \qVerb{break} statements in the rush VM compiler.}, label={lst:rush_vm_compiler_break}, float=h]{deps/rush/crates/rush-interpreter-vm/src/compiler.rs}

Here, the `\texttt{pos}' variable saves the index of the jump-instruction to be inserted.
In line 271, this index is then inserted into the list containing the placeholder indices of the current loop.
Lastly, a `\texttt{jmp}' instruction is inserted containing a placeholder target index.
Therefore, at the end of the compilation of a loop's body, there will be a list containing the indices of instructions whose target indices need to be adjusted.
In line 342 of Listing~\ref{lst:rush_vm_compiler_loop}, the `\texttt{self.fill\_blank\_jmps}' method is used to set the target indices of the specified jump-instructions to `\texttt{pos}'.
We will omit the explanation of this method because it only iterates over the passed list of indices, replacing the target of the jump-instruction at the current index during the process.

As a conclusion, design, and implementation of the compiler targeting the rush VM has presented itself as a reasonable task.
Altering the target architecture to mitigate difficulties which occurred during the implementation of the compiler was often extremely helpful.
Therefore, compared to the rush compiler targeting \riscv{},
implementation of this compiler was significantly simpler.
Furthermore, the rush VM uses a stack-based design which made implementing its compiler less demanding as well.
