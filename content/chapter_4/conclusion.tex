\section{Conclusion: RISC vs. CISC Architectures}

During implementation of the \riscv{} and x64 compilers, it has become apparent how each type of architecture affects the project's  complexity.
One metric for the complexity is line count:
In Git commit \rushCommit{}, the \riscv{} compiler consisted of \tokei{./deps/rush/crates/rush-compiler-risc-v} lines of code while
its x64 counterpart required \tokei{./deps/rush/crates/rush-compiler-x86-64}, meaning that the latter required roughly 500 lines more than \riscv{}.
Even though the observable difference in line count might be reasonable, this metric might differ drastically when considering more advanced compilers.
Apart from objective metrics, implementation of the x64 compiler has presented itself as slightly more demanding compared to the \riscv{} version.
For instance, the previously explained issues of integer division and float comparison presented just an example of how the architecture complicated development.

Furthermore, documentation and learning resources also showed a significant discrepancy.
While there are many resources on the \riscv{} architecture available,
complete guides for implementing programs in its assembly were sparse.
For x64, online resources covering assembly were slightly more prominent due to its larger popularity.
However, easy to comprehend instruction references were only provided by third-party individuals,
as the official Intel reference lacks structure to the point where it has to been helpful. \TODO{Is this correct?}
For \riscv{}, the official ISA specification is held up-to-date and is easily accessible,
making it very helpful during the design of a compiler.
Overall, it seemed like the \riscv{} teams put a lot of effort into its documentation,
making the architecture available for everyone.

Due to the discussed factors, mainly the latter one,
\riscv{} seems like a very promising architecture which will probably gain a lot more popularity in the future.
Simultaneously, CISC architectures, like x64, are becoming increasingly obsolete.
Furthermore, significant licensing fees introduced by large corporate entities like Intel
lead to the architecture being unsuitable for third-party chip manufactures.
Since \riscv{} is an open-source architecture, no licensing fees are required,
thus making the architecture available to anyone.

It is to be mentioned that CISC architectures, like x64, itself cannot be considered bad.
For instance, since the introduction of x64, it has served in millions of devices.
However, since it dates back to the time when assembly programs were still written by hand,
its features are just not up-to-date in a world where code is mostly generated by compilers.
Since CISC architectures provide a lot more, increasingly complex instructions,
handwritten assembly programs will run faster at the expense of programs generated by a compiler.
The differences in documentation and reference material can also be explained when considering the age.
Because \riscv{} intents to attract cooperations to use their architecture, good documentation is vital.

To summarize the paragraphs from above,
during creation of the rush project and this paper,
\riscv{} has presented itself as the more attractive architecture,
both in objective metrics and subjective experiences.
Therefore, if the reader intents to develop a compiler on their own,
we strongly recommend choosing a RISC over a CISC architecture as the compiler's target.
Here, \riscv{} could be considered as a modern and relevant RISC architecture.
