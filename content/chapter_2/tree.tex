\section{Tree-Walking Interpreters}

            \begin{itemize}
                \item walks the analyzed tree
                \item probably the simplest form of language implementation
                      \begin{itemize}
                          \item but generally slow
                      \end{itemize}
                \item easy to support dynamic typing
                \item again one method for each node type
                \item example with variables and function calls (fib?)
                      \begin{itemize}
                          \item scopes and value enum
                          \item backtracking for returns etc.
                          \item builtin functions
                      \end{itemize}
                \item pointers and Rc
            \end{itemize}

            A \emph{tree-walking} interpreter is probably the simplest form of programming language implementation, hence it is the first one explained here.
            \TODO{mention slowness here?}
            It requires no further intermediate steps after the analysis but simply accepts the AST as input.
            Just like the parser and analyzer, it walks the tree, hence the name, and therefore again requires one method per node type.

            The struct definition is also rather small as seen in Listing~\ref{lst:tree_struct}.
            It stores a list of \emph{scopes}, that being maps of variable names to their value at runtime, starting with the global scope at index 0 and ending with the current scope at any point in time.
            \TODO{are rush's scoping rules already explained?}
            \TODO{is runtime / compile time already explained?}
            \TODO{are globals already mentioned?}
            Why the \qVerb{Value} is wrapped inside \textcolor{red}{a/an} \qVerb{Rc<RefCell<Value>>} here is explained later in Section~\ref{sec:tree_pointers}.
            Additionally, a map of function names to their tree node is saved.
            The \qVerb{Rc<_>} here is only necessary to conform to Rust's borrowing rules without unnecessarily cloning.

            \Lirsting[ranges={7-15}, path prefix={deps/rush}, float=htb, label={lst:tree_struct}, caption={Tree-Walking Interpreter Type Definitions}]{deps/rush/crates/rush-interpreter-tree/src/interpreter.rs}

            In addition to the struct itself, result types for expressions and statements are defined.
            Statements either return \qVerb{()}\footnote{Rust's `unit' type, a type containing no data, comparable to `void' in other languages. Its notation describes an empty tuple.} on success or an \qVerb{InterruptKind} on failure.
            Expressions use the same error type, but return a \qVerb{Value} on success, holding the evaluated result.
            The definitions for both \qVerb{Value} and \qVerb{InterruptKind} are visible in Listing~\ref{lst:tree_value}.
            It is clearly visible that the interpreter simply makes use of Rust's types and does not need to worry about the hidden implementation details.

            \Lirsting[ranges={4-11, 20-26}, path prefix={deps/rush}, float=htb, label={lst:tree_value}, caption={Tree-Walking Interpreter \qVerb{Value} and \qVerb{InterruptKind} Definitions}]{deps/rush/crates/rush-interpreter-tree/src/value.rs}

            \qVerb{InterruptKind} describes the different ways the interpreter can be interrupted.
            The first three variants, `return', `break', and `continue', are only partial interrupts, i.e., they do not necessarily stop execution of the whole program.
            Instead, they are `caught' when \ldots
            The remaining two variants are for one runtime errors, produced by things like division by zero, and \qVerb{Exit(i64)}, created by rush's builtin \qVerb{exit(int)} function.
            They cause the interpreter to backtrack all the way back to the AST's root and with that cancel execution, as this is the desired behavior for errors and exit calls.

            \subsection{Supporting Pointers}\label{sec:tree_pointers}

            \section{Tree-Walking Interpreters}

        \begin{itemize}
            \item walks the analyzed tree
            \item probably the simplest form of language implementation
                  \begin{itemize}
                      \item but generally slow
                  \end{itemize}
            \item easy to support dynamic typing
            \item again one method for each node type
            \item example with variables and function calls (fib?)
                  \begin{itemize}
                      \item scopes and value enum
                      \item backtracking for returns etc.
                      \item builtin functions
                  \end{itemize}
            \item pointers and Rc
        \end{itemize}

        A \emph{tree-walking} interpreter is probably the simplest form of programming language implementation, hence it is the first one explained here.
        \TODO{mention slowness here?}
        It requires no further intermediate steps after the analysis but simply accepts the AST as input.
        Just like the parser and analyzer, it walks the tree, hence the name, and therefore again requires one method per node type.

        The struct definition is also rather small as seen in Listing~\ref{lst:tree_struct}.
        It stores a list of \emph{scopes}, that being maps of variable names to their value at runtime, starting with the global scope at index 0 and ending with the current scope at any point in time.
        \TODO{are rush's scoping rules already explained?}
        \TODO{is runtime / compile time already explained?}
        \TODO{are globals already mentioned?}
        Why the \qVerb{Value} is wrapped inside \textcolor{red}{a/an} \qVerb{Rc<RefCell<Value>>} here is explained later in Section~\ref{sec:tree_pointers}.
        Additionally, a map of function names to their tree node is saved.
        The \qVerb{Rc<_>} here is only necessary to conform to Rust's borrowing rules without unnecessarily cloning.

        \Lirsting[ranges={7-15}, path prefix={deps/rush}, float=htb, label={lst:tree_struct}, caption={Tree-Walking Interpreter Type Definitions}]{deps/rush/crates/rush-interpreter-tree/src/interpreter.rs}

        In addition to the struct itself, result types for expressions and statements are defined.
        Statements either return \qVerb{()}\footnote{Rust's `unit' type, a type containing no data, comparable to `void' in other languages. Its notation describes an empty tuple.} on success or an \qVerb{InterruptKind} on failure.
        Expressions use the same error type, but return a \qVerb{Value} on success, holding the evaluated result.
        The definitions for both \qVerb{Value} and \qVerb{InterruptKind} are visible in Listing~\ref{lst:tree_value}.
        It is clearly visible that the interpreter simply makes use of Rust's types and does not need to worry about the hidden implementation details.

        \Lirsting[ranges={4-11, 20-26}, path prefix={deps/rush}, float=htb, label={lst:tree_value}, caption={Tree-Walking Interpreter \qVerb{Value} and \qVerb{InterruptKind} Definitions}]{deps/rush/crates/rush-interpreter-tree/src/value.rs}

        \qVerb{InterruptKind} describes the different ways the interpreter can be interrupted.
        The first three variants, `return', `break', and `continue', are only partial interrupts, i.e., they do not necessarily stop execution of the whole program.
        Instead, they are `caught' when \ldots
        The remaining two variants are for one runtime errors, produced by things like division by zero, and \qVerb{Exit(i64)}, created by rush's builtin \qVerb{exit(int)} function.
        They cause the interpreter to backtrack all the way back to the AST's root and with that cancel execution, as this is the desired behavior for errors and exit calls.

        \subsection{Supporting Pointers}\label{sec:tree_pointers}

        \section{Tree-Walking Interpreters}

    \begin{itemize}
        \item walks the analyzed tree
        \item probably the simplest form of language implementation
              \begin{itemize}
                  \item but generally slow
              \end{itemize}
        \item easy to support dynamic typing
        \item again one method for each node type
        \item example with variables and function calls (fib?)
              \begin{itemize}
                  \item scopes and value enum
                  \item backtracking for returns etc.
                  \item builtin functions
              \end{itemize}
        \item pointers and Rc
    \end{itemize}

    A \emph{tree-walking} interpreter is probably the simplest form of programming language implementation, hence it is the first one explained here.
    \TODO{mention slowness here?}
    It requires no further intermediate steps after the analysis but simply accepts the AST as input.
    Just like the parser and analyzer, it walks the tree, hence the name, and therefore again requires one method per node type.

    The struct definition is also rather small as seen in Listing~\ref{lst:tree_struct}.
    It stores a list of \emph{scopes}, that being maps of variable names to their value at runtime, starting with the global scope at index 0 and ending with the current scope at any point in time.
    \TODO{are rush's scoping rules already explained?}
    \TODO{is runtime / compile time already explained?}
    \TODO{are globals already mentioned?}
    Why the \qVerb{Value} is wrapped inside \textcolor{red}{a/an} \qVerb{Rc<RefCell<Value>>} here is explained later in Section~\ref{sec:tree_pointers}.
    Additionally, a map of function names to their tree node is saved.
    The \qVerb{Rc<_>} here is only necessary to conform to Rust's borrowing rules without unnecessarily cloning.

    \Lirsting[ranges={7-15}, path prefix={deps/rush}, float=htb, label={lst:tree_struct}, caption={Tree-Walking Interpreter Type Definitions}]{deps/rush/crates/rush-interpreter-tree/src/interpreter.rs}

    In addition to the struct itself, result types for expressions and statements are defined.
    Statements either return \qVerb{()}\footnote{Rust's `unit' type, a type containing no data, comparable to `void' in other languages. Its notation describes an empty tuple.} on success or an \qVerb{InterruptKind} on failure.
    Expressions use the same error type, but return a \qVerb{Value} on success, holding the evaluated result.
    The definitions for both \qVerb{Value} and \qVerb{InterruptKind} are visible in Listing~\ref{lst:tree_value}.
    It is clearly visible that the interpreter simply makes use of Rust's types and does not need to worry about the hidden implementation details.

    \Lirsting[ranges={4-11, 20-26}, path prefix={deps/rush}, float=htb, label={lst:tree_value}, caption={Tree-Walking Interpreter \qVerb{Value} and \qVerb{InterruptKind} Definitions}]{deps/rush/crates/rush-interpreter-tree/src/value.rs}

    \qVerb{InterruptKind} describes the different ways the interpreter can be interrupted.
    The first three variants, `return', `break', and `continue', are only partial interrupts, i.e., they do not necessarily stop execution of the whole program.
    asd
    Instead, they are `caught' when\ldots
    The remaining two variants are for one runtime errors, produced by things like division by zero, and \qVerb{Exit(i64)}, created by rush's builtin \qVerb{exit(int)} function.
    They cause the interpreter to backtrack all the way back to the AST's root and with that cancel execution, as this is the desired behavior for errors and exit calls.

    \subsection{Supporting Pointers}\label{sec:tree_pointers}

    \section{Tree-Walking Interpreters}

\begin{itemize}
	\item walks the analyzed tree
	\item probably the simplest form of language implementation
	      \begin{itemize}
		      \item but generally slow
	      \end{itemize}
	\item easy to support dynamic typing
	\item again one method for each node type
	\item example with variables and function calls (fib?)
	      \begin{itemize}
		      \item scopes and value enum
		      \item backtracking for returns etc.
		      \item builtin functions
	      \end{itemize}
	\item pointers and Rc
\end{itemize}

A \emph{tree-walking} interpreter is probably the simplest form of programming language implementation, hence it is the first one explained here.
\TODO{mention slowness here?}
It requires no further intermediate steps after the analysis but simply accepts the AST as input.
Just like the parser and analyzer, it walks the tree, hence the name, and therefore again requires one method per node type.

The struct definition is also rather small as seen in Listing~\ref{lst:tree_struct}.
It stores a list of \emph{scopes}, that being maps of variable names to their value at runtime, starting with the global scope at index 0 and ending with the current scope at any point in time.
\TODO{are rush's scoping rules already explained?}
\TODO{is runtime / compile time already explained?}
\TODO{are globals already mentioned?}
Why the \qVerb{Value} is wrapped inside \textcolor{red}{a/an} \qVerb{Rc<RefCell<Value>>} here is explained later in Section~\ref{sec:tree_pointers}.
Additionally, a map of function names to their tree node is saved.
The \qVerb{Rc<_>} here is only necessary to conform to Rust's borrowing rules without unnecessarily cloning.

\Lirsting[ranges={7-15}, path prefix={deps/rush}, float=htb, label={lst:tree_struct}, caption={Tree-Walking Interpreter Type Definitions}]{deps/rush/crates/rush-interpreter-tree/src/interpreter.rs}

In addition to the struct itself, result types for expressions and statements are defined.
Statements either return \qVerb{()}\footnote{Rust's `unit' type, a type containing no data, comparable to `void' in other languages. Its notation describes an empty tuple.} on success or an \qVerb{InterruptKind} on failure.
Expressions use the same error type, but return a \qVerb{Value} on success, holding the evaluated result.
The definitions for both \qVerb{Value} and \qVerb{InterruptKind} are visible in Listing~\ref{lst:tree_value}.
It is clearly visible that the interpreter simply makes use of Rust's types and does not need to worry about the hidden implementation details.

\Lirsting[ranges={4-11, 20-26}, path prefix={deps/rush}, float=htb, label={lst:tree_value}, caption={Tree-Walking Interpreter \qVerb{Value} and \qVerb{InterruptKind} Definitions}]{deps/rush/crates/rush-interpreter-tree/src/value.rs}

\qVerb{InterruptKind} describes the different ways the interpreter can be interrupted.
The first three variants, `return', `break', and `continue', are only partial interrupts, i.e., they do not necessarily stop execution of the whole program.
Instead, they are `caught' when\ldots
The remaining two variants are for one runtime errors, produced by things like division by zero, and \qVerb{Exit(i64)}, created by rush's builtin \qVerb{exit(int)} function.
They cause the interpreter to backtrack all the way back to the AST's root and with that cancel execution, as this is the desired behavior for errors and exit calls.

\subsection{Supporting Pointers}\label{sec:tree_pointers}

% RefCell to enforce Rust's borrowing rules at runtime rather than compile time.
