\newpage
\section{Conclusion: RISC vs. CISC Architectures}

During implementation of the \riscv{} and x64 compilers, it has become apparent how each type of architecture affects the project's  complexity.
One metric for the that is line count.
At the state of Git commit \rushCommit{}, the \riscv{} compiler consisted of \tokei{./deps/rush/crates/rush-compiler-risc-v} lines of code while
its x64 counterpart required \tokei{./deps/rush/crates/rush-compiler-x86-64}, meaning that the latter required roughly 500 lines more than the former.
Apart from objective metrics, implementation of the x64 compiler has presented itself as slightly more demanding compared to the one targeting \riscv{}.
For instance, the previously explained issues of integer division and float comparison presented just an example of how the architecture complicated development.

Furthermore, documentation and learning resources also showed a significant discrepancy.
While there are many resources on the \riscv{} architecture available,
complete guides for implementing programs in its assembly were sparse.
For x64, online resources covering assembly were slightly more prominent due to its larger popularity.
However, easy to comprehend instruction references were only provided by third-party individuals,
as the official Intel references lack structure to the point where it can be considered unhelpful.
For \riscv{}, the official ISA specification is held up-to-date and is easily accessible,
making it very helpful during the design of a compiler.
Overall, it seemed like the \riscv{} community put a lot of effort into documentation,
making the architecture available for everyone.

Due to the discussed factors, mainly the latter one,
\riscv{} seems like a very promising architecture which will probably gain a lot more popularity in the future.
Simultaneously, CISC architectures, like x64, seem like they are becoming increasingly obsolete.
Furthermore, significant licensing fees introduced by large corporate entities like Intel
lead to the architecture being unsuitable for third-party chip manufacturers.
Since \riscv{} is an open source architecture, no licensing fees are required.

It is to be mentioned that CISC architectures, like x64, itself cannot be considered bad.
For instance, since the introduction of x64, it has served in millions of devices.
However, since it dates back to the time when assembly programs were still written by hand,
its features are just not up-to-date in a world where code is mostly generated by compilers.
Since CISC architectures provide a lot more, increasingly complex instructions,
handwritten assembly programs will run faster at the expense of programs generated by a compiler.
The differences in documentation and reference material can also be explained when considering the age of the architectures.
Because \riscv{} intents to attract cooperations to use their architecture, good documentation is vital.

To summarize, during creation of the rush project and this paper,
\riscv{} has presented itself as the more attractive architecture,
both in objective metrics and subjective experiences.
Therefore, if the reader intents to develop a compiler on their own,
we strongly recommend choosing a RISC over a CISC architecture as the compiler's target.
